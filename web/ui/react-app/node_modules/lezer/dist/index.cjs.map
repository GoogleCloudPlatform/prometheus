{"version":3,"file":"index.cjs","sources":["../src/stack.ts","../src/token.ts","../src/decode.ts","../src/parse.ts"],"sourcesContent":["import {Action, Term, StateFlag, ParseState, Seq} from \"./constants\"\nimport {Parse, ContextTracker} from \"./parse\"\nimport {Tree, TreeBuffer, BufferCursor} from \"lezer-tree\"\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nexport class Stack {\n  /// @internal\n  constructor(\n    /// A the parse that this stack is part of @internal\n    readonly p: Parse,\n    /// Holds state, pos, value stack pos (15 bits array index, 15 bits\n    /// buffer index) triplets for all but the top state\n    /// @internal\n    readonly stack: number[],\n    /// The current parse state @internal\n    public state: number,\n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    public reducePos: number,\n    /// The input position up to which this stack has parsed.\n    public pos: number,\n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    public score: number,\n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    readonly buffer: number[],\n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    readonly bufferBase: number,\n    /// @internal\n    public curContext: StackContext | null,\n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    readonly parent: Stack | null\n  ) {}\n\n  /// @internal\n  toString() {\n    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`\n  }\n\n  // Start an empty stack\n  /// @internal\n  static start(p: Parse, state: number, pos = 0) {\n    let cx = p.parser.context\n    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, null)\n  }\n\n  /// The stack's current [context](#lezer.ContextTracker) value, if\n  /// any. Its type will depend on the context tracker's type\n  /// parameter, or it will be `null` if there is no context\n  /// tracker.\n  get context() { return this.curContext ? this.curContext.context : null }\n\n  // Push a state onto the stack, tracking its start position as well\n  // as the buffer base at that point.\n  /// @internal\n  pushState(state: number, start: number) {\n    this.stack.push(this.state, start, this.bufferBase + this.buffer.length)\n    this.state = state\n  }\n\n  // Apply a reduce action\n  /// @internal\n  reduce(action: number) {\n    let depth = action >> Action.ReduceDepthShift, type = action & Action.ValueMask\n    let {parser} = this.p\n\n    let dPrec = parser.dynamicPrecedence(type)\n    if (dPrec) this.score += dPrec\n\n    if (depth == 0) {\n      // Zero-depth reductions are a special caseâ€”they add stuff to\n      // the stack without popping anything off.\n      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true)\n      this.pushState(parser.getGoto(this.state, type, true), this.reducePos)\n      this.reduceContext(type)\n      return\n    }\n\n    // Find the base index into `this.stack`, content after which will\n    // be dropped. Note that with `StayFlag` reductions we need to\n    // consume two extra frames (the dummy parent node for the skipped\n    // expression and the state that we'll be staying in, which should\n    // be moved to `this.state`).\n    let base = this.stack.length - ((depth - 1) * 3) - (action & Action.StayFlag ? 6 : 0)\n    let start = this.stack[base - 2]\n    let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase\n    // Store normal terms or `R -> R R` repeat reductions\n    if (type < parser.minRepeatTerm || (action & Action.RepeatFlag)) {\n      let pos = parser.stateFlag(this.state, StateFlag.Skipped) ? this.pos : this.reducePos\n      this.storeNode(type, start, pos, count + 4, true)\n    }\n    if (action & Action.StayFlag) {\n      this.state = this.stack[base]\n    } else {\n      let baseStateID = this.stack[base - 3]\n      this.state = parser.getGoto(baseStateID, type, true)\n    }\n    while (this.stack.length > base) this.stack.pop()\n    this.reduceContext(type)\n  }\n\n  // Shift a value into the buffer\n  /// @internal\n  storeNode(term: number, start: number, end: number, size = 4, isReduce = false) {\n    if (term == Term.Err) { // Try to omit/merge adjacent error nodes\n      let cur: Stack | null = this, top = this.buffer.length\n      if (top == 0 && cur.parent) {\n        top = cur.bufferBase - cur.parent.bufferBase\n        cur = cur.parent\n      }\n      if (top > 0 && cur.buffer[top - 4] == Term.Err && cur.buffer[top - 1] > -1) {\n        if (start == end) return\n        if (cur.buffer[top - 2] >= start) { cur.buffer[top - 2] = end; return }\n      }\n    }\n\n    if (!isReduce || this.pos == end) { // Simple case, just append\n      this.buffer.push(term, start, end, size)\n    } else { // There may be skipped nodes that have to be moved forward\n      let index = this.buffer.length\n      if (index > 0 && this.buffer[index - 4] != Term.Err) while (index > 0 && this.buffer[index - 2] > end) {\n        // Move this record forward\n        this.buffer[index] = this.buffer[index - 4]\n        this.buffer[index + 1] = this.buffer[index - 3]\n        this.buffer[index + 2] = this.buffer[index - 2]\n        this.buffer[index + 3] = this.buffer[index - 1]\n        index -= 4\n        if (size > 4) size -= 4\n      }\n      this.buffer[index] = term\n      this.buffer[index + 1] = start\n      this.buffer[index + 2] = end\n      this.buffer[index + 3] = size\n    }\n  }\n\n  // Apply a shift action\n  /// @internal\n  shift(action: number, next: number, nextEnd: number) {\n    if (action & Action.GotoFlag) {\n      this.pushState(action & Action.ValueMask, this.pos)\n    } else if ((action & Action.StayFlag) == 0) { // Regular shift\n      let start = this.pos, nextState = action, {parser} = this.p\n      if (nextEnd > this.pos || next <= parser.maxNode) {\n        this.pos = nextEnd\n        if (!parser.stateFlag(nextState, StateFlag.Skipped)) this.reducePos = nextEnd\n      }\n      this.pushState(nextState, start)\n      if (next <= parser.maxNode) this.buffer.push(next, start, nextEnd, 4)\n      this.shiftContext(next)\n    } else { // Shift-and-stay, which means this is a skipped token\n      if (next <= this.p.parser.maxNode) this.buffer.push(next, this.pos, nextEnd, 4)\n      this.pos = nextEnd\n    }\n  }\n\n  // Apply an action\n  /// @internal\n  apply(action: number, next: number, nextEnd: number) {\n    if (action & Action.ReduceFlag) this.reduce(action)\n    else this.shift(action, next, nextEnd)\n  }\n\n  // Add a prebuilt node into the buffer. This may be a reused node or\n  // the result of running a nested parser.\n  /// @internal\n  useNode(value: Tree | TreeBuffer, next: number) {\n    let index = this.p.reused.length - 1\n    if (index < 0 || this.p.reused[index] != value) {\n      this.p.reused.push(value)\n      index++\n    }\n    let start = this.pos\n    this.reducePos = this.pos = start + value.length\n    this.pushState(next, start)\n    this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */)\n    if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this.p.input, this))\n  }\n\n  // Split the stack. Due to the buffer sharing and the fact\n  // that `this.stack` tends to stay quite shallow, this isn't very\n  // expensive.\n  /// @internal\n  split() {\n    let parent: Stack | null = this\n    let off = parent.buffer.length\n    // Because the top of the buffer (after this.pos) may be mutated\n    // to reorder reductions and skipped tokens, and shared buffers\n    // should be immutable, this copies any outstanding skipped tokens\n    // to the new buffer, and puts the base pointer before them.\n    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4\n    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off\n    // Make sure parent points to an actual parent with content, if there is such a parent.\n    while (parent && base == parent.bufferBase) parent = parent.parent\n    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos,\n                     this.score, buffer, base, this.curContext, parent)\n  }\n\n  // Try to recover from an error by 'deleting' (ignoring) one token.\n  /// @internal\n  recoverByDelete(next: number, nextEnd: number) {\n    let isNode = next <= this.p.parser.maxNode\n    if (isNode) this.storeNode(next, this.pos, nextEnd)\n    this.storeNode(Term.Err, this.pos, nextEnd, isNode ? 8 : 4)\n    this.pos = this.reducePos = nextEnd\n    this.score -= Recover.Token\n  }\n\n  /// Check if the given term would be able to be shifted (optionally\n  /// after some reductions) on this stack. This can be useful for\n  /// external tokenizers that want to make sure they only provide a\n  /// given token when it applies.\n  canShift(term: number) {\n    for (let sim = new SimulatedStack(this);;) {\n      let action = this.p.parser.stateSlot(sim.top, ParseState.DefaultReduce) || this.p.parser.hasAction(sim.top, term)\n      if ((action & Action.ReduceFlag) == 0) return true\n      if (action == 0) return false\n      sim.reduce(action)\n    }\n  }\n\n  /// Find the start position of the rule that is currently being parsed.\n  get ruleStart() {\n    for (let state = this.state, base = this.stack.length;;) {\n      let force = this.p.parser.stateSlot(state, ParseState.ForcedReduce)\n      if (!(force & Action.ReduceFlag)) return 0\n      base -= 3 * (force >> Action.ReduceDepthShift)\n      if ((force & Action.ValueMask) < this.p.parser.minRepeatTerm)\n        return this.stack[base + 1]\n      state = this.stack[base]\n    }\n  }\n\n  /// Find the start position of an instance of any of the given term\n  /// types, or return `null` when none of them are found.\n  ///\n  /// **Note:** this is only reliable when there is at least some\n  /// state that unambiguously matches the given rule on the stack.\n  /// I.e. if you have a grammar like this, where the difference\n  /// between `a` and `b` is only apparent at the third token:\n  ///\n  ///     a { b | c }\n  ///     b { \"x\" \"y\" \"x\" }\n  ///     c { \"x\" \"y\" \"z\" }\n  ///\n  /// Then a parse state after `\"x\"` will not reliably tell you that\n  /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n  /// for either of those two rules (assuming that `a` isn't part of\n  /// some rule that includes other things starting with `\"x\"`).\n  ///\n  /// When `before` is given, this keeps scanning up the stack until\n  /// it finds a match that starts before that position.\n  ///\n  /// Note that you have to be careful when using this in tokenizers,\n  /// since it's relatively easy to introduce data dependencies that\n  /// break incremental parsing by using this method.\n  startOf(types: readonly number[], before?: number) {\n    let state = this.state, frame = this.stack.length, {parser} = this.p\n    for (;;) {\n      let force = parser.stateSlot(state, ParseState.ForcedReduce)\n      let depth = force >> Action.ReduceDepthShift, term = force & Action.ValueMask\n      if (types.indexOf(term) > -1) {\n        let base = frame - (3 * (force >> Action.ReduceDepthShift)), pos = this.stack[base + 1]\n        if (before == null || before > pos) return pos\n      }\n      if (frame == 0) return null\n      if (depth == 0) {\n        frame -= 3\n        state = this.stack[frame]\n      } else {\n        frame -= 3 * (depth - 1)\n        state = parser.getGoto(this.stack[frame - 3], term, true)\n      }\n    }\n  }\n\n  // Apply up to Recover.MaxNext recovery actions that conceptually\n  // inserts some missing token or rule.\n  /// @internal\n  recoverByInsert(next: number): Stack[] {\n    if (this.stack.length >= Recover.MaxInsertStackDepth) return []\n\n    let nextStates = this.p.parser.nextStates(this.state)\n    if (nextStates.length > Recover.MaxNext << 1 || this.stack.length >= Recover.DampenInsertStackDepth) {\n      let best = []\n      for (let i = 0, s; i < nextStates.length; i += 2) {\n        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n          best.push(nextStates[i], s)\n      }\n      if (this.stack.length < Recover.DampenInsertStackDepth)\n        for (let i = 0; best.length < Recover.MaxNext << 1 && i < nextStates.length; i += 2) {\n          let s = nextStates[i + 1]\n          if (!best.some((v, i) => (i & 1) && v == s)) best.push(nextStates[i], s)\n        }\n      nextStates = best\n    }\n    let result: Stack[] = []\n    for (let i = 0; i < nextStates.length && result.length < Recover.MaxNext; i += 2) {\n      let s = nextStates[i + 1]\n      if (s == this.state) continue\n      let stack = this.split()\n      stack.storeNode(Term.Err, stack.pos, stack.pos, 4, true)\n      stack.pushState(s, this.pos)\n      stack.shiftContext(nextStates[i])\n      stack.score -= Recover.Token\n      result.push(stack)\n    }\n    return result\n  }\n\n  // Force a reduce, if possible. Return false if that can't\n  // be done.\n  /// @internal\n  forceReduce() {\n    let reduce = this.p.parser.stateSlot(this.state, ParseState.ForcedReduce)\n    if ((reduce & Action.ReduceFlag) == 0) return false\n    if (!this.p.parser.validAction(this.state, reduce)) {\n      this.storeNode(Term.Err, this.reducePos, this.reducePos, 4, true)\n      this.score -= Recover.Reduce\n    }\n    this.reduce(reduce)\n    return true\n  }\n\n  /// @internal\n  forceAll() {\n    while (!this.p.parser.stateFlag(this.state, StateFlag.Accepting) && this.forceReduce()) {}\n    return this\n  }\n\n  /// Check whether this state has no further actions (assumed to be a direct descendant of the\n  /// top state, since any other states must be able to continue\n  /// somehow). @internal\n  get deadEnd() {\n    if (this.stack.length != 3) return false\n    let {parser} = this.p\n    return parser.data[parser.stateSlot(this.state, ParseState.Actions)] == Seq.End &&\n      !parser.stateSlot(this.state, ParseState.DefaultReduce)\n  }\n\n  /// Restart the stack (put it back in its start state). Only safe\n  /// when this.stack.length == 3 (state is directly below the top\n  /// state). @internal\n  restart() {\n    this.state = this.stack[0]\n    this.stack.length = 0\n  }\n\n  /// @internal\n  sameState(other: Stack) {\n    if (this.state != other.state || this.stack.length != other.stack.length) return false\n    for (let i = 0; i < this.stack.length; i += 3)\n      if (this.stack[i] != other.stack[i]) return false\n    return true\n  }\n\n  /// Get the parser used by this stack.\n  get parser() { return this.p.parser }\n\n  /// Test whether a given dialect (by numeric ID, as exported from\n  /// the terms file) is enabled.\n  dialectEnabled(dialectID: number) { return this.p.parser.dialect.flags[dialectID] }\n\n  private shiftContext(term: number) {\n    if (this.curContext)\n      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this.p.input, this))\n  }\n\n  private reduceContext(term: number) {\n    if (this.curContext)\n      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this.p.input, this))\n  }\n\n  /// @internal\n  emitContext() {\n    let cx = this.curContext!\n    if (!cx.tracker.strict) return\n    let last = this.buffer.length - 1\n    if (last < 0 || this.buffer[last] != -2)\n      this.buffer.push(cx.hash, this.reducePos, this.reducePos, -2)\n  }\n\n  private updateContext(context: any) {\n    if (context != this.curContext!.context) {\n      let newCx = new StackContext(this.curContext!.tracker, context)\n      if (newCx.hash != this.curContext!.hash) this.emitContext()\n      this.curContext = newCx\n    }\n  }\n}\n\nclass StackContext {\n  readonly hash: number\n  constructor(readonly tracker: ContextTracker<any>, readonly context: any) {\n    this.hash = tracker.hash(context)\n  }\n}\n\nexport const enum Recover {\n  Token = 200,\n  Reduce = 100,\n  MaxNext = 4,\n  MaxInsertStackDepth = 300,\n  DampenInsertStackDepth = 120\n}\n\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n  top: number\n  rest: number[]\n  offset: number\n\n  constructor(readonly stack: Stack) {\n    this.top = stack.state\n    this.rest = stack.stack\n    this.offset = this.rest.length\n  }\n\n  reduce(action: number) {\n    let term = action & Action.ValueMask, depth = action >> Action.ReduceDepthShift\n    if (depth == 0) {\n      if (this.rest == this.stack.stack) this.rest = this.rest.slice()\n      this.rest.push(this.top, 0, 0)\n      this.offset += 3\n    } else {\n      this.offset -= (depth - 1) * 3\n    }\n    let goto = this.stack.p.parser.getGoto(this.rest[this.offset - 3], term, true)\n    this.top = goto\n  }\n}\n\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nexport class StackBufferCursor implements BufferCursor {\n  buffer: number[]\n\n  constructor(public stack: Stack, public pos: number, public index: number) {\n    this.buffer = stack.buffer\n    if (this.index == 0) this.maybeNext()\n  }\n\n  static create(stack: Stack) {\n    return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length)\n  }\n\n  maybeNext() {\n    let next = this.stack.parent\n    if (next != null) {\n      this.index = this.stack.bufferBase - next.bufferBase\n      this.stack = next\n      this.buffer = next.buffer\n    }\n  }\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  next() {\n    this.index -= 4\n    this.pos -= 4\n    if (this.index == 0) this.maybeNext()\n  }\n\n  fork() {\n    return new StackBufferCursor(this.stack, this.pos, this.index)\n  }\n}\n","import {Input} from \"lezer-tree\"\nimport {Stack} from \"./stack\"\n\n/// Tokenizers write the tokens they read into instances of this class.\nexport class Token {\n  /// The start of the token. This is set by the parser, and should not\n  /// be mutated by the tokenizer.\n  start = -1\n  /// This starts at -1, and should be updated to a term id when a\n  /// matching token is found.\n  value = -1\n  /// When setting `.value`, you should also set `.end` to the end\n  /// position of the token. (You'll usually want to use the `accept`\n  /// method.)\n  end = -1\n\n  /// Accept a token, setting `value` and `end` to the given values.\n  accept(value: number, end: number) {\n    this.value = value\n    this.end = end\n  }\n}\n\nexport interface Tokenizer {\n  token(input: Input, token: Token, stack: Stack): void\n  contextual: boolean\n  fallback: boolean\n  extend: boolean\n}\n\n/// @internal\nexport class TokenGroup implements Tokenizer {\n  contextual!: boolean\n  fallback!: boolean\n  extend!: boolean\n\n  constructor(readonly data: Readonly<Uint16Array>, readonly id: number) {}\n\n  token(input: Input, token: Token, stack: Stack) { readToken(this.data, input, token, stack, this.id) }\n}\n\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false\n\ninterface ExternalOptions {\n  /// When set to true, mark this tokenizer as depending on the\n  /// current parse stack, which prevents its result from being cached\n  /// between parser actions at the same positions.\n  contextual?: boolean,\n  /// By defaults, when a tokenizer returns a token, that prevents\n  /// tokenizers with lower precedence from even running. When\n  /// `fallback` is true, the tokenizer is allowed to run when a\n  /// previous tokenizer returned a token that didn't match any of the\n  /// current state's actions.\n  fallback?: boolean\n  /// When set to true, tokenizing will not stop after this tokenizer\n  /// has produced a token. (But it will still fail to reach this one\n  /// if a higher-precedence tokenizer produced a token.)\n  extend?: boolean\n}\n\n/// Exports that are used for `@external tokens` in the grammar should\n/// export an instance of this class.\nexport class ExternalTokenizer {\n  /// @internal\n  contextual: boolean\n  /// @internal\n  fallback: boolean\n  /// @internal\n  extend: boolean\n\n  /// Create a tokenizer. The first argument is the function that,\n  /// given an input stream and a token object,\n  /// [fills](#lezer.Token.accept) the token object if it recognizes a\n  /// token. `token.start` should be used as the start position to\n  /// scan from.\n  constructor(\n    /// @internal\n    readonly token: (input: Input, token: Token, stack: Stack) => void,\n    options: ExternalOptions = {}\n  ) {\n    this.contextual = !!options.contextual\n    this.fallback = !!options.fallback\n    this.extend = !!options.extend\n  }\n}\n\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data: Readonly<Uint16Array>,\n                   input: Input,\n                   token: Token,\n                   stack: Stack,\n                   group: number) {\n  let state = 0, groupMask = 1 << group, dialect = stack.p.parser.dialect\n  scan: for (let pos = token.start;;) {\n    if ((groupMask & data[state]) == 0) break\n    let accEnd = data[state + 1]\n    // Check whether this state can lead to a token in the current group\n    // Accept tokens in this state, possibly overwriting\n    // lower-precedence / shorter tokens\n    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {\n      let term = data[i]\n      if (dialect.allows(term) &&\n          (token.value == -1 || token.value == term || stack.p.parser.overrides(term, token.value))) {\n        token.accept(term, pos)\n        break\n      }\n    }\n    let next = input.get(pos++)\n    // Do a binary search on the state's edges\n    for (let low = 0, high = data[state + 2]; low < high;) {\n      let mid = (low + high) >> 1\n      let index = accEnd + mid + (mid << 1)\n      let from = data[index], to = data[index + 1]\n      if (next < from) high = mid\n      else if (next >= to) low = mid + 1\n      else { state = data[index + 2]; continue scan }\n    }\n    break\n  }\n}\n","// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\n\nimport {Encode} from \"./constants\"\n\nexport function decodeArray<T extends {[i: number]: number} = Uint16Array>(\n  input: string | T,\n  Type: {new (n: number): T} = Uint16Array as any\n): T {\n  if (typeof input != \"string\") return input\n  let array: T | null = null\n  for (let pos = 0, out = 0; pos < input.length;) {\n    let value = 0\n    for (;;) {\n      let next = input.charCodeAt(pos++), stop = false\n      if (next == Encode.BigValCode) { value = Encode.BigVal; break }\n      if (next >= Encode.Gap2) next--\n      if (next >= Encode.Gap1) next--\n      let digit = next - Encode.Start\n      if (digit >= Encode.Base) { digit -= Encode.Base; stop = true }\n      value += digit\n      if (stop) break\n      value *= Encode.Base\n    }\n    if (array) array[out++] = value\n    else array = new Type(value)\n  }\n  return array!\n}\n","import {DefaultBufferLength, Tree, TreeBuffer, TreeFragment, NodeSet, NodeType, NodeProp, NodePropSource,\n        Input, stringInput, PartialParse, ParseContext} from \"lezer-tree\"\nimport {Stack, StackBufferCursor} from \"./stack\"\nimport {Action, Specialize, Term, Seq, StateFlag, ParseState, File} from \"./constants\"\nimport {Token, Tokenizer, TokenGroup, ExternalTokenizer} from \"./token\"\nimport {decodeArray} from \"./decode\"\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG!)\n\nlet stackIDs: WeakMap<Stack, string> | null = null\n\n/// Used to configure a [nested parse](#lezer.Parser.withNested).\nexport type NestedParserSpec = {\n  /// The inner parser. Will be passed the input,\n  /// [clipped](#lezer.Input.clip) to the size of the parseable\n  /// region, the start position of the inner region as `startPos`,\n  /// and an optional array of tree fragments from a previous parse\n  /// that can be reused.\n  ///\n  /// When this property isn't given, the inner region is simply\n  /// skipped over intead of parsed.\n  startParse?: (input: Input, startPos: number, context: ParseContext) => PartialParse\n  /// When given, an additional node will be wrapped around the\n  /// part of the tree produced by this inner parse.\n  wrapType?: NodeType | number\n  /// When given, this will be called with the token that ends the\n  /// inner region. It can return `false` to cause a given end token\n  /// to be ignored.\n  filterEnd?(endToken: string): boolean\n}\n\n/// This type is used to specify a nested parser. It may directly be a\n/// nested parse [spec](#lezer.NestedParseSpec), or a function that,\n/// given an input document and a stack, returns such a spec or `null`\n/// to indicate that the nested parse should not happen (and the\n/// grammar's fallback expression should be used).\nexport type NestedParser = NestedParserSpec | ((input: Input, stack: Stack) => NestedParserSpec | null)\n\nfunction cutAt(tree: Tree, pos: number, side: 1 | -1) {\n  let cursor = tree.cursor(pos)\n  for (;;) {\n    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (;;) {\n      if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n        return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 5)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 5))\n      if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break\n      if (!cursor.parent()) return side < 0 ? 0 : tree.length\n    }\n  }\n}\n\nclass FragmentCursor {\n  i = 0\n  fragment: TreeFragment | null = null\n  safeFrom = -1\n  safeTo = -1\n  trees: Tree[] = []\n  start: number[] = []\n  index: number[] = []\n  nextStart!: number\n\n  constructor(readonly fragments: readonly TreeFragment[]) {\n    this.nextFragment()\n  }\n\n  nextFragment() {\n    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]\n    if (fr) {\n      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from\n      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to\n      while (this.trees.length) { this.trees.pop(); this.start.pop(); this.index.pop() }\n      this.trees.push(fr.tree)\n      this.start.push(-fr.offset)\n      this.index.push(0)\n      this.nextStart = this.safeFrom\n    } else {\n      this.nextStart = 1e9\n    }\n  }\n\n  // `pos` must be >= any previously given `pos` for this cursor\n  nodeAt(pos: number): Tree | TreeBuffer | null {\n    if (pos < this.nextStart) return null\n    while (this.fragment && this.safeTo <= pos) this.nextFragment()\n    if (!this.fragment) return null\n\n    for (;;) {\n      let last = this.trees.length - 1\n      if (last < 0) { // End of tree\n        this.nextFragment()\n        return null\n      }\n      let top = this.trees[last], index = this.index[last]\n      if (index == top.children.length) {\n        this.trees.pop()\n        this.start.pop()\n        this.index.pop()\n        continue\n      }\n      let next = top.children[index]\n      let start = this.start[last] + top.positions[index]\n      if (start > pos) {\n        this.nextStart = start\n        return null\n      } else if (start == pos && start + next.length <= this.safeTo) {\n        return start == pos && start >= this.safeFrom ? next : null\n      }\n      if (next instanceof TreeBuffer) {\n        this.index[last]++\n        this.nextStart = start + next.length\n      } else {\n        this.index[last]++\n        if (start + next.length >= pos) { // Enter this node\n          this.trees.push(next)\n          this.start.push(start)\n          this.index.push(0)\n        }\n      }\n    }\n  }\n}\n\nclass CachedToken extends Token {\n  extended = -1\n  mask = 0\n  context = 0\n\n  clear(start: number) {\n    this.start = start\n    this.value = this.extended = -1\n  }\n}\n\nconst dummyToken = new Token\n\nclass TokenCache {\n  tokens: CachedToken[] = []\n  mainToken: Token = dummyToken\n\n  actions: number[] = []\n\n  constructor(parser: Parser) {\n    this.tokens = parser.tokenizers.map(_ => new CachedToken)\n  }\n\n  getActions(stack: Stack, input: Input) {\n    let actionIndex = 0\n    let main: Token | null = null\n    let {parser} = stack.p, {tokenizers} = parser\n\n    let mask = parser.stateSlot(stack.state, ParseState.TokenizerMask)\n    let context = stack.curContext ? stack.curContext.hash : 0\n    for (let i = 0; i < tokenizers.length; i++) {\n      if (((1 << i) & mask) == 0) continue\n      let tokenizer = tokenizers[i], token = this.tokens[i]\n      if (main && !tokenizer.fallback) continue\n      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n        this.updateCachedToken(token, tokenizer, stack, input)\n        token.mask = mask\n        token.context = context\n      }\n\n      if (token.value != Term.Err) {\n        let startIndex = actionIndex\n        if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex)\n        actionIndex = this.addActions(stack, token.value, token.end, actionIndex)\n        if (!tokenizer.extend) {\n          main = token\n          if (actionIndex > startIndex) break\n        }\n      }\n    }\n\n    while (this.actions.length > actionIndex) this.actions.pop()\n    if (!main) {\n      main = dummyToken\n      main.start = stack.pos\n      if (stack.pos == input.length) main.accept(stack.p.parser.eofTerm, stack.pos)\n      else main.accept(Term.Err, stack.pos + 1)\n    }\n    this.mainToken = main\n    return this.actions\n  }\n\n  updateCachedToken(token: CachedToken, tokenizer: Tokenizer, stack: Stack, input: Input) {\n    token.clear(stack.pos)\n    tokenizer.token(input, token, stack)\n    if (token.value > -1) {\n      let {parser} = stack.p\n\n      for (let i = 0; i < parser.specialized.length; i++) if (parser.specialized[i] == token.value) {\n        let result = parser.specializers[i](input.read(token.start, token.end), stack)\n        if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n          if ((result & 1) == Specialize.Specialize) token.value = result >> 1\n          else token.extended = result >> 1\n          break\n        }\n      }\n    } else if (stack.pos == input.length) {\n      token.accept(stack.p.parser.eofTerm, stack.pos)\n    } else {\n      token.accept(Term.Err, stack.pos + 1)\n    }\n  }\n\n  putAction(action: number, token: number, end: number, index: number) {\n    // Don't add duplicate actions\n    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index\n    this.actions[index++] = action\n    this.actions[index++] = token\n    this.actions[index++] = end\n    return index\n  }\n\n  addActions(stack: Stack, token: number, end: number, index: number) {\n    let {state} = stack, {parser} = stack.p, {data} = parser\n    for (let set = 0; set < 2; set++) {\n      for (let i = parser.stateSlot(state, set ? ParseState.Skip : ParseState.Actions);; i += 3) {\n        if (data[i] == Seq.End) {\n          if (data[i + 1] == Seq.Next) {\n            i = pair(data, i + 2)\n          } else {\n            if (index == 0 && data[i + 1] == Seq.Other)\n              index = this.putAction(pair(data, i + 1), token, end, index)\n            break\n          }\n        }\n        if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index)\n      }\n    }\n    return index\n  }\n}\n\nconst enum Rec {\n  Distance = 5,\n  MaxRemainingPerStep = 3,\n  MinBufferLengthPrune = 200,\n  ForceReduceLimit = 10\n}\n\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nexport class Parse implements PartialParse {\n  // Active parse stacks.\n  stacks: Stack[]\n  // The position to which the parse has advanced.\n  pos = 0\n  recovering = 0\n  fragments: FragmentCursor | null\n  nextStackID = 0x2654\n  nested: PartialParse | null = null\n  nestEnd = 0\n  nestWrap: NodeType | null = null\n\n  reused: (Tree | TreeBuffer)[] = []\n  tokens: TokenCache\n  topTerm: number\n\n  constructor(\n    public parser: Parser,\n    public input: Input,\n    public startPos: number,\n    public context: ParseContext\n  ) {\n    this.tokens = new TokenCache(parser)\n    this.topTerm = parser.top[1]\n    this.stacks = [Stack.start(this, parser.top[0], this.startPos)]\n    let fragments = context?.fragments\n    this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null\n  }\n\n  // Move the parser forward. This will process all parse stacks at\n  // `this.pos` and try to advance them to a further position. If no\n  // stack for such a position is found, it'll start error-recovery.\n  //\n  // When the parse is finished, this will return a syntax tree. When\n  // not, it returns `null`.\n  advance() {\n    if (this.nested) {\n      let result = this.nested.advance()\n      this.pos = this.nested.pos\n      if (result) {\n        this.finishNested(this.stacks[0], result)\n        this.nested = null\n      }\n      return null\n    }\n\n    let stacks = this.stacks, pos = this.pos\n    // This will hold stacks beyond `pos`.\n    let newStacks: Stack[] = this.stacks = []\n    let stopped: Stack[] | undefined, stoppedTokens: number[] | undefined\n    let maybeNest\n\n    // Keep advancing any stacks at `pos` until they either move\n    // forward or can't be advanced. Gather stacks that can't be\n    // advanced further in `stopped`.\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], nest\n      for (;;) {\n        if (stack.pos > pos) {\n          newStacks.push(stack)\n        } else if (nest = this.checkNest(stack)) {\n          if (!maybeNest || maybeNest.stack.score < stack.score) maybeNest = nest\n        } else if (this.advanceStack(stack, newStacks, stacks)) {\n          continue\n        } else {\n          if (!stopped) { stopped = []; stoppedTokens = [] }\n          stopped.push(stack)\n          let tok = this.tokens.mainToken\n          stoppedTokens!.push(tok.value, tok.end)\n        }\n        break\n      }\n    }\n\n    if (maybeNest) {\n      this.startNested(maybeNest)\n      return null\n    }\n\n    if (!newStacks.length) {\n      let finished = stopped && findFinished(stopped)\n      if (finished) return this.stackToTree(finished)\n\n      if (this.parser.strict) {\n        if (verbose && stopped)\n          console.log(\"Stuck with token \" + this.parser.getName(this.tokens.mainToken.value))\n        throw new SyntaxError(\"No parse at \" + pos)\n      }\n      if (!this.recovering) this.recovering = Rec.Distance\n    }\n\n    if (this.recovering && stopped) {\n      let finished = this.runRecovery(stopped, stoppedTokens!, newStacks)\n      if (finished) return this.stackToTree(finished.forceAll())\n    }\n\n    if (this.recovering) {\n      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * Rec.MaxRemainingPerStep\n      if (newStacks.length > maxRemaining) {\n        newStacks.sort((a, b) => b.score - a.score)\n        while (newStacks.length > maxRemaining) newStacks.pop()\n      }\n      if (newStacks.some(s => s.reducePos > pos)) this.recovering--\n    } else if (newStacks.length > 1) {\n      // Prune stacks that are in the same state, or that have been\n      // running without splitting for a while, to avoid getting stuck\n      // with multiple successful stacks running endlessly on.\n      outer: for (let i = 0; i < newStacks.length - 1; i++) {\n        let stack = newStacks[i]\n        for (let j = i + 1; j < newStacks.length; j++) {\n          let other = newStacks[j]\n          if (stack.sameState(other) ||\n              stack.buffer.length > Rec.MinBufferLengthPrune && other.buffer.length > Rec.MinBufferLengthPrune) {\n            if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n              newStacks.splice(j--, 1)\n            } else {\n              newStacks.splice(i--, 1)\n              continue outer\n            }\n          }\n        }\n      }\n    }\n\n    this.pos = newStacks[0].pos\n    for (let i = 1; i < newStacks.length; i++) if (newStacks[i].pos < this.pos) this.pos = newStacks[i].pos\n    return null\n  }\n\n  // Returns an updated version of the given stack, or null if the\n  // stack can't advance normally. When `split` and `stacks` are\n  // given, stacks split off by ambiguous operations will be pushed to\n  // `split`, or added to `stacks` if they move `pos` forward.\n  private advanceStack(stack: Stack, stacks: null | Stack[], split: null | Stack[]) {\n    let start = stack.pos, {input, parser} = this\n    let base = verbose ? this.stackID(stack) + \" -> \" : \"\"\n\n    if (this.fragments) {\n      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext!.hash : 0\n      for (let cached = this.fragments.nodeAt(start); cached;) {\n        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1\n        if (match > -1 && cached.length && (!strictCx || ((cached as any).contextHash || 0) == cxHash)) {\n          stack.useNode(cached, match)\n          if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`)\n          return true\n        }\n        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0) break\n        let inner = cached.children[0]\n        if (inner instanceof Tree) cached = inner\n        else break\n      }\n    }\n\n    let defaultReduce = parser.stateSlot(stack.state, ParseState.DefaultReduce)\n    if (defaultReduce > 0) {\n      stack.reduce(defaultReduce)\n      if (verbose)\n        console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & Action.ValueMask)})`)\n      return true\n    }\n\n    let actions = this.tokens.getActions(stack, input)\n    for (let i = 0; i < actions.length;) {\n      let action = actions[i++], term = actions[i++], end = actions[i++]\n      let last = i == actions.length || !split\n      let localStack = last ? stack : stack.split()\n      localStack.apply(action, term, end)\n      if (verbose)\n        console.log(base + this.stackID(localStack) + ` (via ${(action & Action.ReduceFlag) == 0 ? \"shift\"\n                     : `reduce of ${parser.getName(action & Action.ValueMask)}`} for ${\n        parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`)\n      if (last) return true\n      else if (localStack.pos > start) stacks!.push(localStack)\n      else split!.push(localStack)\n    }\n\n    return false\n  }\n\n  // Advance a given stack forward as far as it will go. Returns the\n  // (possibly updated) stack if it got stuck, or null if it moved\n  // forward and was given to `pushStackDedup`.\n  private advanceFully(stack: Stack, newStacks: Stack[]) {\n    let pos = stack.pos\n    for (;;) {\n      let nest = this.checkNest(stack)\n      if (nest) return nest\n      if (!this.advanceStack(stack, null, null)) return false\n      if (stack.pos > pos) {\n        pushStackDedup(stack, newStacks)\n        return true\n      }\n    }\n  }\n\n  private runRecovery(stacks: Stack[], tokens: number[], newStacks: Stack[]) {\n    let finished: Stack | null = null, restarted = false\n    let maybeNest\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1]\n      let base = verbose ? this.stackID(stack) + \" -> \" : \"\"\n\n      if (stack.deadEnd) {\n        if (restarted) continue\n        restarted = true\n        stack.restart()\n        if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\")\n        let done = this.advanceFully(stack, newStacks)\n        if (done) {\n          if (done !== true) maybeNest = done\n          continue\n        }\n      }\n\n      let force = stack.split(), forceBase = base\n      for (let j = 0; force.forceReduce() && j < Rec.ForceReduceLimit; j++) {\n        if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\")\n        let done = this.advanceFully(force, newStacks)\n        if (done) {\n          if (done !== true) maybeNest = done\n          break\n        }\n        if (verbose) forceBase = this.stackID(force) + \" -> \"\n      }\n\n      for (let insert of stack.recoverByInsert(token)) {\n        if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\")\n        this.advanceFully(insert, newStacks)\n      }\n\n      if (this.input.length > stack.pos) {\n        if (tokenEnd == stack.pos) {\n          tokenEnd++\n          token = Term.Err\n        }\n        stack.recoverByDelete(token, tokenEnd)\n        if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`)\n        pushStackDedup(stack, newStacks)\n      } else if (!finished || finished.score < stack.score) {\n        finished = stack\n      }\n    }\n\n    if (finished) return finished\n\n    if (maybeNest) for (let s of this.stacks) if (s.score > maybeNest.stack.score) {\n      maybeNest = undefined\n      break\n    }\n    if (maybeNest) this.startNested(maybeNest)\n    return null\n  }\n\n  forceFinish() {\n    let stack = this.stacks[0].split()\n    if (this.nested) this.finishNested(stack, this.nested.forceFinish())\n    return this.stackToTree(stack.forceAll())\n  }\n\n  // Convert the stack's buffer to a syntax tree.\n  stackToTree(stack: Stack, pos: number = stack.pos): Tree {\n    if (this.parser.context) stack.emitContext()\n    return Tree.build({buffer: StackBufferCursor.create(stack),\n                       nodeSet: this.parser.nodeSet,\n                       topID: this.topTerm,\n                       maxBufferLength: this.parser.bufferLength,\n                       reused: this.reused,\n                       start: this.startPos,\n                       length: pos - this.startPos,\n                       minRepeatType: this.parser.minRepeatTerm})\n  }\n\n  private checkNest(stack: Stack) {\n    let info = this.parser.findNested(stack.state)\n    if (!info) return null\n    let spec: NestedParser | null = info.value\n    if (typeof spec == \"function\") spec = spec(this.input, stack)\n    return spec ? {stack, info, spec} : null\n  }\n\n  private startNested(nest: {stack: Stack, info: NestInfo, spec: NestedParserSpec}) {\n    let {stack, info, spec} = nest\n    this.stacks = [stack]\n    this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd)\n    this.nestWrap = typeof spec.wrapType == \"number\" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null\n    if (spec.startParse) {\n      this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context)\n    } else {\n      this.finishNested(stack)\n    }\n  }\n\n  private scanForNestEnd(stack: Stack, endToken: TokenGroup, filter?: (token: string) => boolean) {\n    for (let pos = stack.pos; pos < this.input.length; pos++) {\n      dummyToken.start = pos\n      dummyToken.value = -1\n      endToken.token(this.input, dummyToken, stack)\n      if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end)))) return pos\n    }\n    return this.input.length\n  }\n\n  private finishNested(stack: Stack, tree?: Tree) {\n    if (this.nestWrap) tree = new Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos)\n    else if (!tree) tree = new Tree(NodeType.none, [], [], this.nestEnd - stack.pos)\n    let info = this.parser.findNested(stack.state)!\n    stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true))\n    if (verbose) console.log(this.stackID(stack) + ` (via unnest)`)\n  }\n\n  private stackID(stack: Stack) {\n    let id = (stackIDs || (stackIDs = new WeakMap)).get(stack)\n    if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++))\n    return id + stack\n  }\n}\n\nfunction pushStackDedup(stack: Stack, newStacks: Stack[]) {\n  for (let i = 0; i < newStacks.length; i++) {\n    let other = newStacks[i]\n    if (other.pos == stack.pos && other.sameState(stack)) {\n      if (newStacks[i].score < stack.score) newStacks[i] = stack\n      return\n    }\n  }\n  newStacks.push(stack)\n}\n\nexport class Dialect {\n  constructor(readonly source: string | undefined,\n              readonly flags: readonly boolean[],\n              readonly disabled: null | Uint8Array) {}\n\n  allows(term: number) { return !this.disabled || this.disabled[term] == 0 }\n}\n\nconst id: <T>(x: T) => T = x => x\n\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\nexport class ContextTracker<T> {\n  /// @internal\n  start: T\n  /// @internal\n  shift: (context: T, term: number, input: Input, stack: Stack) => T\n  /// @internal\n  reduce: (context: T, term: number, input: Input, stack: Stack) => T\n  /// @internal\n  reuse: (context: T, node: Tree | TreeBuffer, input: Input, stack: Stack) => T\n  /// @internal\n  hash: (context: T) => number\n  /// @internal\n  strict: boolean\n\n  /// The export used in a `@context` declaration should be of this\n  /// type.\n  constructor(spec: {\n    /// The initial value of the context.\n    start: T,\n    /// Update the context when the parser executes a\n    /// [shift](https://en.wikipedia.org/wiki/LR_parser#Shift_and_reduce_actions)\n    /// action.\n    shift?(context: T, term: number, input: Input, stack: Stack): T\n    /// Update the context when the parser executes a reduce action.\n    reduce?(context: T, term: number, input: Input, stack: Stack): T\n    /// Update the context when the parser reuses a node from a tree\n    /// fragment.\n    reuse?(context: T, node: Tree | TreeBuffer, input: Input, stack: Stack): T\n    /// Reduce a context value to a number (for cheap storage and\n    /// comparison).\n    hash(context: T): number\n    /// By default, nodes can only be reused during incremental\n    /// parsing if they were created in the same context as the one in\n    /// which they are reused. Set this to false to disable that\n    /// check.\n    strict?: boolean\n  }) {\n    this.start = spec.start\n    this.shift = spec.shift || id\n    this.reduce = spec.reduce || id\n    this.reuse = spec.reuse || id\n    this.hash = spec.hash\n    this.strict = spec.strict !== false\n  }\n}\n\ntype ParserSpec = {\n  version: number,\n  states: string | Uint32Array,\n  stateData: string | Uint16Array,\n  goto: string | Uint16Array,\n  nodeNames: string,\n  maxTerm: number,\n  repeatNodeCount: number,\n  nodeProps?: [NodeProp<any>, ...(string | number)[]][],\n  skippedNodes?: number[],\n  tokenData: string,\n  tokenizers: (Tokenizer | number)[],\n  topRules: {[name: string]: [number, number]},\n  context: ContextTracker<any> | null,\n  nested?: [string, NestedParser, string | Uint16Array, number][],\n  dialects?: {[name: string]: number},\n  dynamicPrecedences?: {[term: number]: number},\n  specialized?: {term: number, get: (value: string, stack: Stack) => number}[],\n  tokenPrec: number,\n  termNames?: {[id: number]: string}\n}\n\ntype NestInfo = {\n  // A name, used by `withNested`\n  name: string,\n  value: NestedParser,\n  // A token-recognizing automaton for the end of the nesting\n  end: TokenGroup,\n  // The id of the placeholder term that appears in the grammar at\n  // the position of this nesting\n  placeholder: number\n}\n\n/// Configuration options to pass to a parser.\nexport interface ParserConfig {\n  /// Node props to add to the parser's node set.\n  props?: readonly NodePropSource[],\n  /// The name of the @top declaration to parse from. If not\n  /// specified, the first @top declaration is used.\n  top?: string,\n  /// A space-separated string of dialects to enable.\n  dialect?: string,\n  /// The nested grammars to use. This can be used to, for example,\n  /// swap in a different language for a nested grammar or fill in a\n  /// nested grammar that was left blank by the original grammar.\n  nested?: {[name: string]: NestedParser},\n  /// Replace the given external tokenizers with new ones.\n  tokenizers?: {from: ExternalTokenizer, to: ExternalTokenizer}[],\n  /// When true, the parser will raise an exception, rather than run\n  /// its error-recovery strategies, when the input doesn't match the\n  /// grammar.\n  strict?: boolean\n  /// The maximum length of the TreeBuffers generated in the output\n  /// tree. Defaults to 1024.\n  bufferLength?: number\n}\n\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nexport class Parser {\n  /// The parse states for this grammar @internal\n  readonly states: Readonly<Uint32Array>\n  /// A blob of data that the parse states, as well as some\n  /// of `Parser`'s fields, point into @internal\n  readonly data: Readonly<Uint16Array>\n  /// The goto table. See `computeGotoTable` in\n  /// lezer-generator for details on the format @internal\n  readonly goto: Readonly<Uint16Array>\n  /// A node set with the node types used by this parser.\n  readonly nodeSet: NodeSet\n  /// The highest term id @internal\n  readonly maxTerm: number\n  /// The first repeat-related term id @internal\n  readonly minRepeatTerm: number\n  /// The tokenizer objects used by the grammar @internal\n  readonly tokenizers: readonly Tokenizer[]\n  /// Maps top rule names to [state ID, top term ID] pairs. @internal\n  readonly topRules: {[name: string]: [number, number]}\n  /// @internal\n  readonly context: ContextTracker<unknown> | null\n  /// Metadata about nested grammars used in this grammar @internal\n  readonly nested: readonly NestInfo[]\n  /// A mapping from dialect names to the tokens that are exclusive\n  /// to them. @internal\n  readonly dialects: {[name: string]: number}\n  /// Null if there are no dynamic precedences, a map from term ids\n  /// to precedence otherwise. @internal\n  readonly dynamicPrecedences: {[term: number]: number} | null\n  /// The token types have specializers (in this.specializers) @internal\n  readonly specialized: Uint16Array\n  /// The specializer functions for the token types in specialized @internal\n  readonly specializers: ((value: string, stack: Stack) => number)[]\n  /// Points into this.data at an array that holds the\n  /// precedence order (higher precedence first) for ambiguous\n  /// tokens @internal\n  readonly tokenPrecTable: number\n  /// An optional object mapping term ids to name strings @internal\n  readonly termNames: null | {[id: number]: string}\n  /// @internal\n  readonly maxNode: number\n  /// @internal\n  readonly dialect: Dialect\n  /// @internal\n  readonly top: [number, number]\n  /// @internal\n  readonly bufferLength = DefaultBufferLength\n  /// @internal\n  readonly strict = false\n\n  private cachedDialect: Dialect | null = null\n\n  /// @internal\n  constructor(spec: ParserSpec) {\n    if (spec.version != File.Version)\n      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${File.Version})`)\n    let tokenArray = decodeArray<Uint16Array>(spec.tokenData)\n    let nodeNames = spec.nodeNames.split(\" \")\n    this.minRepeatTerm = nodeNames.length\n    this.context = spec.context\n    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push(\"\")\n    let nodeProps: [NodeProp<any>, any][][] = []\n    for (let i = 0; i < nodeNames.length; i++) nodeProps.push([])\n    function setProp(nodeID: number, prop: NodeProp<any>, value: any) {\n      nodeProps[nodeID].push([prop, prop.deserialize(String(value))])\n    }\n    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {\n      let prop = propSpec[0]\n      for (let i = 1; i < propSpec.length;) {\n        let next = propSpec[i++]\n        if (next >= 0) {\n          setProp(next as number, prop, propSpec[i++] as string)\n        } else {\n          let value = propSpec[i + -next] as string\n          for (let j = -next; j > 0; j--) setProp(propSpec[i++] as number, prop, value)\n          i++\n        }\n      }\n    }\n    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0)\n    this.specializers = []\n    if (spec.specialized) for (let i = 0; i < spec.specialized.length; i++) {\n      this.specialized[i] = spec.specialized[i].term\n      this.specializers[i] = spec.specialized[i].get\n    }\n\n    this.states = decodeArray(spec.states, Uint32Array)\n    this.data = decodeArray(spec.stateData)\n    this.goto = decodeArray(spec.goto)\n    let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1])\n    this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n      name: i >= this.minRepeatTerm ? undefined: name,\n      id: i,\n      props: nodeProps[i],\n      top: topTerms.indexOf(i) > -1,\n      error: i == 0,\n      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n    })))\n    this.maxTerm = spec.maxTerm\n    this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value)\n    this.topRules = spec.topRules\n    this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {\n      return {name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder}\n    })\n    this.dialects = spec.dialects || {}\n    this.dynamicPrecedences = spec.dynamicPrecedences || null\n    this.tokenPrecTable = spec.tokenPrec\n    this.termNames = spec.termNames || null\n    this.maxNode = this.nodeSet.types.length - 1\n\n    this.dialect = this.parseDialect()\n    this.top = this.topRules[Object.keys(this.topRules)[0]]\n  }\n\n  /// Parse a given string or stream.\n  parse(input: Input | string, startPos: number = 0, context: ParseContext = {}) {\n    if (typeof input == \"string\") input = stringInput(input)\n    let cx = new Parse(this, input, startPos, context)\n    for (;;) {\n      let done = cx.advance()\n      if (done) return done\n    }\n  }\n\n  /// Start an incremental parse.\n  startParse(input: Input | string, startPos: number = 0, context: ParseContext = {}): PartialParse {\n    if (typeof input == \"string\") input = stringInput(input)\n    return new Parse(this, input, startPos, context)\n  }\n\n  /// Get a goto table entry @internal\n  getGoto(state: number, term: number, loose = false) {\n    let table = this.goto\n    if (term >= table[0]) return -1\n    for (let pos = table[term + 1];;) {\n      let groupTag = table[pos++], last = groupTag & 1\n      let target = table[pos++]\n      if (last && loose) return target\n      for (let end = pos + (groupTag >> 1); pos < end; pos++)\n        if (table[pos] == state) return target\n      if (last) return -1\n    }\n  }\n\n  /// Check if this state has an action for a given terminal @internal\n  hasAction(state: number, terminal: number) {\n    let data = this.data\n    for (let set = 0; set < 2; set++) {\n      for (let i = this.stateSlot(state, set ? ParseState.Skip : ParseState.Actions), next;; i += 3) {\n        if ((next = data[i]) == Seq.End) {\n          if (data[i + 1] == Seq.Next) next = data[i = pair(data, i + 2)]\n          else if (data[i + 1] == Seq.Other) return pair(data, i + 2)\n          else break\n        }\n        if (next == terminal || next == Term.Err) return pair(data, i + 1)\n      }\n    }\n    return 0\n  }\n\n  /// @internal\n  stateSlot(state: number, slot: number) {\n    return this.states[(state * ParseState.Size) + slot]\n  }\n\n  /// @internal\n  stateFlag(state: number, flag: number) {\n    return (this.stateSlot(state, ParseState.Flags) & flag) > 0\n  }\n\n  /// @internal\n  findNested(state: number) {\n    let flags = this.stateSlot(state, ParseState.Flags)\n    return flags & StateFlag.StartNest ? this.nested[flags >> StateFlag.NestShift] : null\n  }\n\n  /// @internal\n  validAction(state: number, action: number) {\n    if (action == this.stateSlot(state, ParseState.DefaultReduce)) return true\n    for (let i = this.stateSlot(state, ParseState.Actions);; i += 3) {\n      if (this.data[i] == Seq.End) {\n        if (this.data[i + 1] == Seq.Next) i = pair(this.data, i + 2)\n        else return false\n      }\n      if (action == pair(this.data, i + 1)) return true\n    }\n  }\n\n  /// Get the states that can follow this one through shift actions or\n  /// goto jumps. @internal\n  nextStates(state: number): readonly number[] {\n    let result: number[] = []\n    for (let i = this.stateSlot(state, ParseState.Actions);; i += 3) {\n      if (this.data[i] == Seq.End) {\n        if (this.data[i + 1] == Seq.Next) i = pair(this.data, i + 2)\n        else break\n      }\n      if ((this.data[i + 2] & (Action.ReduceFlag >> 16)) == 0) {\n        let value = this.data[i + 1]\n        if (!result.some((v, i) => (i & 1) && v == value)) result.push(this.data[i], value)\n      }\n    }\n    return result\n  }\n\n  /// @internal\n  overrides(token: number, prev: number) {\n    let iPrev = findOffset(this.data, this.tokenPrecTable, prev)\n    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev\n  }\n\n  /// Configure the parser. Returns a new parser instance that has the\n  /// given settings modified. Settings not provided in `config` are\n  /// kept from the original parser.\n  configure(config: ParserConfig) {\n    // Hideous reflection-based kludge to make it easy to create a\n    // slightly modified copy of a parser.\n    let copy = Object.assign(Object.create(Parser.prototype), this)\n    if (config.props)\n      copy.nodeSet = this.nodeSet.extend(...config.props)\n    if (config.top) {\n      let info = this.topRules[config.top!]\n      if (!info) throw new RangeError(`Invalid top rule name ${config.top}`)\n      copy.top = info\n    }\n    if (config.tokenizers)\n      copy.tokenizers = this.tokenizers.map(t => {\n        let found = config.tokenizers!.find(r => r.from == t)\n        return found ? found.to : t\n      })\n    if (config.dialect)\n      copy.dialect = this.parseDialect(config.dialect)\n    if (config.nested)\n      copy.nested = this.nested.map(obj => {\n        if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name)) return obj\n        return {name: obj.name, value: config.nested![obj.name], end: obj.end, placeholder: obj.placeholder}\n      })\n    if (config.strict != null)\n      copy.strict = config.strict\n    if (config.bufferLength != null)\n      copy.bufferLength = config.bufferLength\n    return copy as Parser\n  }\n\n  /// Returns the name associated with a given term. This will only\n  /// work for all terms when the parser was generated with the\n  /// `--names` option. By default, only the names of tagged terms are\n  /// stored.\n  getName(term: number): string {\n    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term)\n  }\n\n  /// The eof term id is always allocated directly after the node\n  /// types. @internal\n  get eofTerm() { return this.maxNode + 1 }\n\n  /// Tells you whether this grammar has any nested grammars.\n  get hasNested() { return this.nested.length > 0 }\n\n  /// The type of top node produced by the parser.\n  get topNode() { return this.nodeSet.types[this.top[1]] }\n\n  /// @internal\n  dynamicPrecedence(term: number) {\n    let prec = this.dynamicPrecedences\n    return prec == null ? 0 : prec[term] || 0\n  }\n\n  /// @internal\n  parseDialect(dialect?: string) {\n    if (this.cachedDialect && this.cachedDialect.source == dialect) return this.cachedDialect\n    let values = Object.keys(this.dialects), flags = values.map(() => false)\n    if (dialect) for (let part of dialect.split(\" \")) {\n      let id = values.indexOf(part)\n      if (id >= 0) flags[id] = true\n    }\n    let disabled: Uint8Array | null = null\n    for (let i = 0; i < values.length; i++) if (!flags[i]) {\n      for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != Seq.End;)\n        (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1\n    }\n    return this.cachedDialect = new Dialect(dialect, flags, disabled)\n  }\n\n  /// (used by the output of the parser generator) @internal\n  static deserialize(spec: ParserSpec) {\n    return new Parser(spec)\n  }\n}\n\nfunction pair(data: Readonly<Uint16Array>, off: number) { return data[off] | (data[off + 1] << 16) }\n\nfunction findOffset(data: Readonly<Uint16Array>, start: number, term: number) {\n  for (let i = start, next; (next = data[i]) != Seq.End; i++)\n    if (next == term) return i - start\n  return -1\n}\n\nfunction findFinished(stacks: Stack[]) {\n  let best: Stack | null = null\n  for (let stack of stacks) {\n    if (stack.pos == stack.p.input.length &&\n        stack.p.parser.stateFlag(stack.state, StateFlag.Accepting) &&\n        (!best || best.score < stack.score))\n      best = stack\n  }\n  return best\n}\n"],"names":["TreeBuffer","Tree","NodeType","DefaultBufferLength","NodeSet","stringInput"],"mappings":"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"}