{"version":3,"file":"tree.es.js","sources":["../src/tree.ts"],"sourcesContent":["/// The default maximum length of a `TreeBuffer` node.\nexport const DefaultBufferLength = 1024\n\nlet nextPropID = 0\n\nconst CachedNode = new WeakMap<Tree, TreeNode>()\n\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nexport class NodeProp<T> {\n  /// @internal\n  id: number\n\n  /// A method that deserializes a value of this prop from a string.\n  /// Can be used to allow a prop to be directly written in a grammar\n  /// file. Defaults to raising an error.\n  deserialize: (str: string) => T\n\n  /// Create a new node prop type. You can optionally pass a\n  /// `deserialize` function.\n  constructor({deserialize}: {deserialize?: (str: string) => T} = {}) {\n    this.id = nextPropID++\n    this.deserialize = deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\")\n    })\n  }\n\n  /// Create a string-valued node prop whose deserialize function is\n  /// the identity function.\n  static string() { return new NodeProp<string>({deserialize: str => str}) }\n\n  /// Create a number-valued node prop whose deserialize function is\n  /// just `Number`.\n  static number() { return new NodeProp<number>({deserialize: Number}) }\n\n  /// Creates a boolean-valued node prop whose deserialize function\n  /// returns true for any input.\n  static flag() { return new NodeProp<boolean>({deserialize: () => true}) }\n\n  /// Store a value for this prop in the given object. This can be\n  /// useful when building up a prop object to pass to the\n  /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n  /// argument.\n  set(propObj: {[prop: number]: any}, value: T) {\n    propObj[this.id] = value\n    return propObj\n  }\n\n  /// This is meant to be used with\n  /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n  /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n  /// values for each node type in the set. Takes a [match\n  /// object](#tree.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  add(match: {[selector: string]: T} | ((type: NodeType) => T | undefined)): NodePropSource {\n    if (typeof match != \"function\") match = NodeType.match(match)\n    return (type) => {\n      let result = (match as (type: NodeType) => T | undefined)(type)\n      return result === undefined ? null : [this, result]\n    }\n  }\n\n  /// Prop that is used to describe matching delimiters. For opening\n  /// delimiters, this holds an array of node names (written as a\n  /// space-separated string when declaring this prop in a grammar)\n  /// for the node types of closing delimiters that match it.\n  static closedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n  /// attached to closing delimiters, holding an array of node names\n  /// of types of matching opening delimiters.\n  static openedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// Used to assign node types to groups (for example, all node\n  /// types that represent an expression could be tagged with an\n  /// `\"Expression\"` group).\n  static group = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n}\n\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node set.\nexport type NodePropSource = (type: NodeType) => null | [NodeProp<any>, any]\n\n// Note: this is duplicated in lezer/src/constants.ts\nconst enum NodeFlag {\n  Top = 1,\n  Skipped = 2,\n  Error = 4,\n  Anonymous = 8\n}\n\nconst noProps: {[propID: number]: any} = Object.create(null)\n\n/// Each node in a syntax tree has a node type associated with it.\nexport class NodeType {\n  /// @internal\n  constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    readonly name: string,\n    /// @internal\n    readonly props: {readonly [prop: number]: any},\n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    readonly id: number,\n    /// @internal\n    readonly flags: number = 0) {}\n\n  static define(spec: {\n    /// The ID of the node type. When this type is used in a\n    /// [set](#tree.NodeSet), the ID must correspond to its index in\n    /// the type array.\n    id: number, \n    /// The name of the node type. Leave empty to define an anonymous\n    /// node.\n    name?: string,\n    /// [Node props](#tree.NodeProp) to assign to the type. The value\n    /// given for any given prop should correspond to the prop's type.\n    props?: readonly ([NodeProp<any>, any] | NodePropSource)[],\n    /// Whether is is a [top node](#tree.NodeType.isTop).\n    top?: boolean,\n    /// Whether this node counts as an [error\n    /// node](#tree.NodeType.isError).\n    error?: boolean,\n    /// Whether this node is a [skipped](#tree.NodeType.isSkipped)\n    /// node.\n    skipped?: boolean\n  }) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps\n    let flags = (spec.top ? NodeFlag.Top : 0) | (spec.skipped ? NodeFlag.Skipped : 0) |\n      (spec.error ? NodeFlag.Error : 0) | (spec.name == null ? NodeFlag.Anonymous : 0)\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags)\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type)!\n      if (src) src[0].set(props, src[1])\n    }\n    return type\n  }\n\n  /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n  prop<T>(prop: NodeProp<T>): T | undefined { return this.props[prop.id] }\n\n  /// True when this is the top node of a grammar.\n  get isTop() { return (this.flags & NodeFlag.Top) > 0 }\n\n  /// True when this node is produced by a skip rule.\n  get isSkipped() { return (this.flags & NodeFlag.Skipped) > 0 }\n\n  /// Indicates whether this is an error node.\n  get isError() { return (this.flags & NodeFlag.Error) > 0 }\n\n  /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n  get isAnonymous() { return (this.flags & NodeFlag.Anonymous) > 0 }\n\n  /// Returns true when this node's name or one of its\n  /// [groups](#tree.NodeProp^group) matches the given string.\n  is(name: string | number) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true\n      let group = this.prop(NodeProp.group)\n      return group ? group.indexOf(name) > -1 : false\n    }\n    return this.id == name\n  }\n\n  /// An empty dummy node type to use when no actual type is available.\n  static none: NodeType = new NodeType(\"\", Object.create(null), 0, NodeFlag.Anonymous)\n\n  /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#tree.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n  static match<T>(map: {[selector: string]: T}): (node: NodeType) => T | undefined {\n    let direct = Object.create(null)\n    for (let prop in map)\n      for (let name of prop.split(\" \")) direct[name] = map[prop]\n    return (node: NodeType) => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups![i]]\n        if (found) return found\n      }\n    }\n  }\n}\n\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nexport class NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor(\n    /// The node types in this set, by id.\n    readonly types: readonly NodeType[]\n  ) {\n    for (let i = 0; i < types.length; i++) if (types[i].id != i)\n      throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\")\n  }\n\n  /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#tree.NodeProp.add).\n  extend(...props: NodePropSource[]): NodeSet {\n    let newTypes: NodeType[] = []\n    for (let type of this.types) {\n      let newProps = null\n      for (let source of props) {\n        let add = source(type)\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props)\n          add[0].set(newProps, add[1])\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type)\n    }\n    return new NodeSet(newTypes)\n  }\n}\n\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\nexport class Tree {\n  /// Construct a new tree. You usually want to go through\n  /// [`Tree.build`](#tree.Tree^build) instead.\n  constructor(\n    readonly type: NodeType,\n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    readonly children: readonly (Tree | TreeBuffer)[],\n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    readonly positions: readonly number[],\n    /// The total length of this tree\n    readonly length: number\n  ) {}\n\n  /// @internal\n  toString(): string {\n    let children = this.children.map(c => c.toString()).join()\n    return !this.type.name ? children :\n      (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n      (children.length ? \"(\" + children + \")\" : \"\")\n  }\n\n  /// The empty tree\n  static empty = new Tree(NodeType.none, [], [], 0)\n\n  /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n  /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n  /// to the given position and side.\n  cursor(pos?: number, side: -1 | 0 | 1 = 0): TreeCursor {\n    let scope = (pos != null && CachedNode.get(this)) || (this.topNode as TreeNode)\n    let cursor = new TreeCursor(scope)\n    if (pos != null) {\n      cursor.moveTo(pos, side)\n      CachedNode.set(this, cursor._tree)\n    }\n    return cursor\n  }\n\n  /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n  /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n  /// nodes.\n  fullCursor(): TreeCursor {\n    return new TreeCursor(this.topNode as TreeNode, true)\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n  /// tree.\n  get topNode(): SyntaxNode {\n    return new TreeNode(this, 0, 0, null)\n  }\n\n  /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor(pos, side).node\n  }\n\n  /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, the given node\n  /// will not have its children iterated over (or `leave` called).\n  iterate(spec: {\n    enter(type: NodeType, from: number, to: number): false | void,\n    leave?(type: NodeType, from: number, to: number): void,\n    from?: number,\n    to?: number\n  }) {\n    let {enter, leave, from = 0, to = this.length} = spec\n    for (let c = this.cursor();;) {\n      let mustLeave = false\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n        if (c.firstChild()) continue\n        if (!c.type.isAnonymous) mustLeave = true\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to)\n        mustLeave = c.type.isAnonymous\n        if (c.nextSibling()) break\n        if (!c.parent()) return\n        mustLeave = true\n      }\n    }\n  }\n\n  /// Balance the direct children of this tree.\n  balance(maxBufferLength = DefaultBufferLength) {\n    return this.children.length <= BalanceBranchFactor ? this\n      : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0,\n                     maxBufferLength, this.length, 0)\n  }\n\n  /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n  static build(data: BuildData) { return buildTree(data) }\n}\n\n// For trees that need a context hash attached, we're using this\n// kludge which assigns an extra property directly after\n// initialization (creating a single new object shape).\nfunction withHash(tree: Tree, hash: number) {\n  if (hash) (tree as any).contextHash = hash\n  return tree\n}\n\ntype BuildData = {\n  /// The buffer or buffer cursor to read the node data from.\n  ///\n  /// When this is an array, it should contain four values for every\n  /// node in the tree.\n  ///\n  ///  - The first holds the node's type, as a node ID pointing into\n  ///    the given `NodeSet`.\n  ///  - The second holds the node's start offset.\n  ///  - The third the end offset.\n  ///  - The fourth the amount of space taken up in the array by this\n  ///    node and its children. Since there's four values per node,\n  ///    this is the total number of nodes inside this node (children\n  ///    and transitive children) plus one for the node itself, times\n  ///    four.\n  ///\n  /// Parent nodes should appear _after_ child nodes in the array. As\n  /// an example, a node of type 10 spanning positions 0 to 4, with\n  /// two children, of type 11 and 12, might look like this:\n  ///\n  ///     [11, 0, 1, 4, 12, 2, 4, 4, 10, 0, 4, 12]\n  buffer: BufferCursor | readonly number[],\n  /// The node types to use.\n  nodeSet: NodeSet,\n  /// The id of the top node type, if any.\n  topID?: number,\n  /// The position the tree should start at. Defaults to 0.\n  start?: number,\n  /// The length of the wrapping node. The end offset of the last\n  /// child is used when not provided.\n  length?: number,\n  /// The maximum buffer length to use. Defaults to\n  /// [`DefaultBufferLength`](#tree.DefaultBufferLength).\n  maxBufferLength?: number,\n  /// An optional set of reused nodes that the buffer can refer to.\n  reused?: (Tree | TreeBuffer)[],\n  /// The first node type that indicates repeat constructs in this\n  /// grammar.\n  minRepeatType?: number\n}\n\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nexport class TreeBuffer {\n  /// Create a tree buffer @internal\n  constructor(\n    /// @internal\n    readonly buffer: Uint16Array,\n    // The total length of the group of nodes in the buffer.\n    readonly length: number,\n    /// @internal\n    readonly set: NodeSet,\n    readonly type = NodeType.none\n  ) {}\n\n  /// @internal\n  toString() {\n    let result: string[] = []\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result.join(\",\")\n  }\n\n  /// @internal\n  childString(index: number): string {\n    let id = this.buffer[index], endIndex = this.buffer[index + 3]\n    let type = this.set.types[id], result = type.name\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result)\n    index += 4\n    if (endIndex == index) return result\n    let children: string[] = []\n    while (index < endIndex) {\n      children.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result + \"(\" + children.join(\",\") + \")\"\n  }\n\n  /// @internal\n  findChild(startIndex: number, endIndex: number, dir: 1 | -1, after: number) {\n    let {buffer} = this, pick = -1\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (after != After.None) {\n        let start = buffer[i + 1], end = buffer[i + 2]\n        if (dir > 0) {\n          if (end > after) pick = i\n          if (end > after) break\n        } else {\n          if (start < after) pick = i\n          if (end >= after) break\n        }\n      } else {\n        pick = i\n        if (dir > 0) break\n      }\n    }\n    return pick\n  }\n}\n\nconst enum After { None = -1e8 }\n\n/// A syntax node provides an immutable pointer at a given node in a\n/// tree. When iterating over large amounts of nodes, you may want to\n/// use a mutable [cursor](#tree.TreeCursor) instead, which is more\n/// efficient.\nexport interface SyntaxNode {\n  /// The type of the node.\n  type: NodeType\n  /// The name of the node (`.type.name`).\n  name: string\n  /// The start position of the node.\n  from: number\n  /// The end position of the node.\n  to: number\n\n  /// The node's parent node, if any.\n  parent: SyntaxNode | null\n  /// The first child, if the node has children.\n  firstChild: SyntaxNode | null\n  /// The node's last child, if available.\n  lastChild: SyntaxNode | null\n  /// The first child that starts at or after `pos`.\n  childAfter(pos: number): SyntaxNode | null\n  /// The last child that ends at or before `pos`.\n  childBefore(pos: number): SyntaxNode | null\n  /// This node's next sibling, if any.\n  nextSibling: SyntaxNode | null\n  /// This node's previous sibling.\n  prevSibling: SyntaxNode | null\n  /// A [tree cursor](#tree.TreeCursor) starting at this node.\n  cursor: TreeCursor\n  /// Find the node around, before (if `side` is -1), or after (`side`\n  /// is 1) the given position. Will look in parent nodes if the\n  /// position is outside this node.\n  resolve(pos: number, side?: -1 | 0 | 1): SyntaxNode\n\n  /// Get the first child of the given type (which may be a [node\n  /// name](#tree.NodeProp.name) or a [group\n  /// name](#tree.NodeProp^group)). If `before` is non-null, only\n  /// return children that occur somewhere after a node with that name\n  /// or group. If `after` is non-null, only return children that\n  /// occur somewhere before a node with that name or group.\n  getChild(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode | null\n\n  /// Like [`getChild`](#tree.SyntaxNode.getChild), but return all\n  /// matching children, not just the first.\n  getChildren(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode[]\n}\n\nclass TreeNode implements SyntaxNode {\n  constructor(readonly node: Tree,\n              readonly from: number,\n              readonly index: number,\n              readonly _parent: TreeNode | null) {}\n\n  get type() { return this.node.type }\n\n  get name() { return this.node.type.name }\n\n  get to() { return this.from + this.node.length }\n\n  nextChild(i: number, dir: 1 | -1, after: number, full = false): TreeNode | BufferNode | null {\n    for (let parent: TreeNode = this;;) {\n      for (let {children, positions} = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i], start = positions[i] + parent.from\n        if (after != After.None && (dir < 0 ? start >= after : start + next.length <= after))\n          continue\n        if (next instanceof TreeBuffer) {\n          let index = next.findChild(0, next.buffer.length, dir, after == After.None ? After.None : after - start)\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index)\n        } else if (full || (!next.type.isAnonymous || hasChild(next))) {\n          let inner = new TreeNode(next, start, i, parent)\n          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after)\n        }\n      }\n      if (full || !parent.type.isAnonymous) return null\n      i = parent.index + dir\n      parent = parent._parent!\n      if (!parent) return null\n    }\n  }\n\n  get firstChild() { return this.nextChild(0, 1, After.None) }\n  get lastChild() { return this.nextChild(this.node.children.length - 1, -1, After.None) }\n\n  childAfter(pos: number) { return this.nextChild(0, 1, pos) }\n  childBefore(pos: number) { return this.nextChild(this.node.children.length - 1, -1, pos) }\n\n  nextSignificantParent() {\n    let val: TreeNode = this\n    while (val.type.isAnonymous && val._parent) val = val._parent\n    return val\n  }\n\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null\n  }\n\n  get nextSibling() {\n    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null\n  }\n  get prevSibling() {\n    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n\n  /// @internal\n  toString() { return this.node.toString() }\n}\n\nfunction getChildren(node: SyntaxNode, type: string | number, before: string | number | null, after: string | number | null): SyntaxNode[] {\n  let cur = node.cursor, result: SyntaxNode[] = []\n  if (!cur.firstChild()) return result\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result\n    if (cur.type.is(type)) result.push(cur.node)\n    if (!cur.nextSibling()) return after == null ? result : []\n  }\n}\n\nclass BufferContext {\n  constructor(readonly parent: TreeNode,\n              readonly buffer: TreeBuffer,\n              readonly index: number,\n              readonly start: number) {}\n}\n\nclass BufferNode implements SyntaxNode {\n  type: NodeType\n\n  get name() { return this.type.name }\n\n  get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] }\n\n  get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] }\n\n  constructor(readonly context: BufferContext,\n              readonly _parent: BufferNode | null,\n              readonly index: number) {\n    this.type = context.buffer.set.types[context.buffer.buffer[index]]\n  }\n\n  child(dir: 1 | -1, after: number): BufferNode | null {\n    let {buffer} = this.context\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.context.start)\n    return index < 0 ? null : new BufferNode(this.context, this, index)\n  }\n\n  get firstChild() { return this.child(1, After.None) }\n  get lastChild() { return this.child(-1, After.None) }\n\n  childAfter(pos: number) { return this.child(1, pos) }\n  childBefore(pos: number) { return this.child(-1, pos) }\n\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent()\n  }\n\n  externalSibling(dir: 1 | -1) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1)\n  }\n\n  get nextSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let after = buffer.buffer[this.index + 3]\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n      return new BufferNode(this.context, this._parent, after)\n    return this.externalSibling(1)\n  }\n\n  get prevSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let parentStart = this._parent ? this._parent.index + 4 : 0\n    if (this.index == parentStart) return this.externalSibling(-1)\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, After.None))\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  /// @internal\n  toString() { return this.context.buffer.childString(this.index) }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n}\n\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nexport class TreeCursor {\n  /// The node's type.\n  type!: NodeType\n\n  /// Shorthand for `.type.name`.\n  get name() { return this.type.name }\n\n  /// The start source offset of this node.\n  from!: number\n\n  /// The end source offset.\n  to!: number\n\n  /// @internal\n  _tree!: TreeNode\n  private buffer: BufferContext | null = null\n  private stack: number[] = []\n  private index: number = 0\n  private bufferNode: BufferNode | null = null\n\n  /// @internal\n  constructor(node: TreeNode | BufferNode, readonly full = false) {\n    if (node instanceof TreeNode) {\n      this.yieldNode(node)\n    } else {\n      this._tree = node.context.parent\n      this.buffer = node.context\n      for (let n: BufferNode | null = node._parent; n; n = n._parent) this.stack.unshift(n.index)\n      this.bufferNode = node\n      this.yieldBuf(node.index)\n    }\n  }\n\n  private yieldNode(node: TreeNode | null) {\n    if (!node) return false\n    this._tree = node\n    this.type = node.type\n    this.from = node.from\n    this.to = node.to\n    return true\n  }\n\n  private yieldBuf(index: number, type?: NodeType) {\n    this.index = index\n    let {start, buffer} = this.buffer!\n    this.type = type || buffer.set.types[buffer.buffer[index]]\n    this.from = start + buffer.buffer[index + 1]\n    this.to = start + buffer.buffer[index + 2]\n    return true\n  }\n\n  private yield(node: TreeNode | BufferNode | null) {\n    if (!node) return false\n    if (node instanceof TreeNode) {\n      this.buffer = null\n      return this.yieldNode(node)\n    }\n    this.buffer = node.context\n    return this.yieldBuf(node.index, node.type)\n  }\n\n  /// @internal\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()\n  }\n\n  /// @internal\n  enter(dir: 1 | -1, after: number) {\n    if (!this.buffer)\n      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full))\n\n    let {buffer} = this.buffer\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.buffer.start)\n    if (index < 0) return false\n    this.stack.push(this.index)\n    return this.yieldBuf(index)\n  }\n\n  /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n  firstChild() { return this.enter(1, After.None) }\n\n  /// Move the cursor to this node's last child.\n  lastChild() { return this.enter(-1, After.None) }\n\n  /// Move the cursor to the first child that starts at or after `pos`.\n  childAfter(pos: number) { return this.enter(1, pos) }\n\n  /// Move to the last child that ends at or before `pos`.\n  childBefore(pos: number) { return this.enter(-1, pos) }\n\n  /// Move the node's parent node, if this isn't the top node.\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent)\n    if (this.stack.length) return this.yieldBuf(this.stack.pop()!)\n    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent()\n    this.buffer = null\n    return this.yieldNode(parent)\n  }\n\n  /// @internal\n  sibling(dir: 1 | -1) {\n    if (!this.buffer)\n      return !this._tree._parent ? false\n        : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, After.None, this.full))\n\n    let {buffer} = this.buffer, d = this.stack.length - 1\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4\n      if (this.index != parentStart)\n        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, After.None))\n    } else {\n      let after = buffer.buffer[this.index + 3]\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n        return this.yieldBuf(after)\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, After.None, this.full)) : false\n  }\n\n  /// Move to this node's next sibling, if any.\n  nextSibling() { return this.sibling(1) }\n\n  /// Move to this node's previous sibling, if any.\n  prevSibling() { return this.sibling(-1) }\n\n  private atLastNode(dir: 1 | -1) {\n    let index, parent: TreeNode | null, {buffer} = this\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false\n      }\n      ;({index, parent} = buffer)\n    } else {\n      ({index, _parent: parent} = this._tree)\n    }\n    for (; parent; {index, _parent: parent} = parent) {\n      for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i]\n        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child)) return false\n      }\n    }\n    return true\n  }\n\n  private move(dir: 1 | -1) {\n    if (this.enter(dir, After.None)) return true\n    for (;;) {\n      if (this.sibling(dir)) return true\n      if (this.atLastNode(dir) || !this.parent()) return false\n    }\n  }\n\n  /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty, its next sibling or the next sibling of\n  /// the first parent node that has one.\n  next() { return this.move(1) }\n\n  /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by ist last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n  prev() { return this.move(-1) }\n\n  /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n  moveTo(pos: number, side: -1 | 0 | 1 = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to ||\n           (side < 1 ? this.from >= pos : this.from > pos) ||\n           (side > -1 ? this.to <= pos : this.to < pos))\n      if (!this.parent()) break\n\n    // Then scan down into child nodes as far as possible\n    for (;;) {\n      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos)) break\n      if (this.from == this.to ||\n          (side < 1 ? this.from >= pos : this.from > pos) ||\n          (side > -1 ? this.to <= pos : this.to < pos)) {\n        this.parent()\n        break\n      }\n    }\n    return this\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n  /// position.\n  get node(): SyntaxNode {\n    if (!this.buffer) return this._tree\n    \n    let cache = this.bufferNode, result: BufferNode | null = null, depth = 0\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c: BufferNode | null = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c\n          result = c\n          depth = d + 1\n          break scan\n        }\n        index = this.stack[--d]\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i])\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index)\n  }\n\n  /// Get the [tree](#tree.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#tree.TreeBuffer).\n  get tree(): Tree | null {\n    return this.buffer ? null : this._tree.node\n  }\n}\n\nfunction hasChild(tree: Tree): boolean {\n  return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch))\n}\n\n/// This is used by `Tree.build` as an abstraction for iterating over\n/// a tree buffer. A cursor initially points at the very last element\n/// in the buffer. Every time `next()` is called it moves on to the\n/// previous one.\nexport interface BufferCursor {\n  /// The current buffer position (four times the number of nodes\n  /// remaining).\n  pos: number\n  /// The node ID of the next node in the buffer.\n  id: number\n  /// The start position of the next node in the buffer.\n  start: number\n  /// The end position of the next node.\n  end: number\n  /// The size of the next node (the number of nodes inside, counting\n  /// the node itself, times 4).\n  size: number\n  /// Moves `this.pos` down by 4.\n  next(): void\n  /// Create a copy of this cursor.\n  fork(): BufferCursor\n}\n\nclass FlatBufferCursor implements BufferCursor {\n  constructor(readonly buffer: readonly number[], public index: number) {}\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  get pos() { return this.index }\n\n  next() { this.index -= 4 }\n\n  fork() { return new FlatBufferCursor(this.buffer, this.index) }\n}\n\nconst BalanceBranchFactor = 8\n\nfunction buildTree(data: BuildData) {\n  let {buffer, nodeSet, topID = 0,\n       maxBufferLength = DefaultBufferLength,\n       reused = [],\n       minRepeatType = nodeSet.types.length} = data as BuildData\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer as BufferCursor\n  let types = nodeSet.types\n\n  let contextHash = 0\n\n  function takeNode(parentStart: number, minPos: number,\n                    children: (Tree | TreeBuffer)[], positions: number[],\n                    inRepeat: number) {\n    let {id, start, end, size} = cursor\n    let startPos = start - parentStart\n    if (size < 0) {\n      if (size == -1) { // Reused node\n        children.push(reused[id])\n        positions.push(startPos)\n      } else { // Context change\n        contextHash = id\n      }\n      cursor.next()\n      return\n    }\n\n    let type = types[id], node, buffer: {size: number, start: number, skip: number} | undefined\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip)\n      let endPos = cursor.pos - buffer.size, index = data.length\n      while (cursor.pos > endPos)\n        index = copyToBuffer(buffer.start, data, index, inRepeat)\n      node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat])\n      startPos = buffer.start - parentStart\n    } else { // Make it a node\n      let endPos = cursor.pos - size\n      cursor.next()\n      let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n      let localInRepeat = id >= minRepeatType ? id : -1\n      while (cursor.pos > endPos) {\n        if (cursor.id == localInRepeat) cursor.next()\n        else takeNode(start, endPos, localChildren, localPositions, localInRepeat)\n      }\n      localChildren.reverse(); localPositions.reverse()\n\n      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)\n        node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength,\n                            end - start, contextHash)\n      else\n        node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash)\n    }\n\n    children.push(node)\n    positions.push(startPos)\n  }\n\n  function findBufferSize(maxSize: number, inRepeat: number) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork()\n    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength\n    let result = {size: 0, start: 0, skip: 0}\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size; result.start = start; result.skip = skip\n        skip += 4; size += 4\n        fork.next()\n        continue\n      }\n      let nodeSize = fork.size, startPos = fork.pos - nodeSize\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0\n      let nodeStart = fork.start\n      fork.next()\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan\n        if (fork.id >= minRepeatType) localSkipped += 4\n        fork.next()\n      }\n      start = nodeStart\n      size += nodeSize\n      skip += localSkipped\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size; result.start = start; result.skip = skip\n    }\n    return result.size > 4 ? result : undefined\n  }\n\n  function copyToBuffer(bufferStart: number, buffer: Uint16Array, index: number, inRepeat: number): number {\n    let {id, start, end, size} = cursor\n    cursor.next()\n    if (id == inRepeat) return index\n    let startIndex = index\n    if (size > 4) {\n      let endPos = cursor.pos - (size - 4)\n      while (cursor.pos > endPos)\n        index = copyToBuffer(bufferStart, buffer, index, inRepeat)\n    }\n    if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n      buffer[--index] = startIndex\n      buffer[--index] = end - bufferStart\n      buffer[--index] = start - bufferStart\n      buffer[--index] = id\n    }\n    return index\n  }\n\n  let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n  while (cursor.pos > 0) takeNode(data.start || 0, 0, children, positions, -1)\n  let length = data.length ?? (children.length ? positions[0] + children[0].length : 0)\n  return new Tree(types[topID], children.reverse(), positions.reverse(), length)\n}\n\nfunction balanceRange(outerType: NodeType, innerType: NodeType,\n                      children: readonly (Tree | TreeBuffer)[], positions: readonly number[],\n                      from: number, to: number,\n                      start: number, maxBufferLength: number,\n                      length: number, contextHash: number): Tree {\n  let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n  if (length <= maxBufferLength) {\n    for (let i = from; i < to; i++) {\n      localChildren.push(children[i])\n      localPositions.push(positions[i] - start)\n    }\n  } else {\n    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor))\n    for (let i = from; i < to;) {\n      let groupFrom = i, groupStart = positions[i]\n      i++\n      for (; i < to; i++) {\n        let nextEnd = positions[i] + children[i].length\n        if (nextEnd - groupStart > maxChild) break\n      }\n      if (i == groupFrom + 1) {\n        let only = children[groupFrom]\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n          for (let j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j])\n            localPositions.push(only.positions[j] + groupStart - start)\n          }\n          continue\n        }\n        localChildren.push(only)\n      } else if (i == groupFrom + 1) {\n        localChildren.push(children[groupFrom])\n      } else {\n        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart,\n                                 maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash)\n        if (innerType != NodeType.none && !containsType(inner.children, innerType))\n          inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash)\n        localChildren.push(inner)\n      }\n      localPositions.push(groupStart - start)\n    }\n  }\n  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash)\n}\n\nfunction containsType(nodes: readonly (Tree | TreeBuffer)[], type: NodeType) {\n  for (let elt of nodes) if (elt.type == type) return true\n  return false\n}\n\n/// The [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges)\n/// method expects changed ranges in this format.\nexport interface ChangedRange {\n  /// The start of the change in the start document\n  fromA: number\n  /// The end of the change in the start document\n  toA: number\n  /// The start of the replacement in the new document\n  fromB: number\n  /// The end of the replacement in the new document\n  toB: number\n}\n\nconst enum Open { Start = 1, End = 2 }\n\n/// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\nexport class TreeFragment {\n  constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    readonly from: number,\n    /// The end of the unchanged range.\n    readonly to: number,\n    /// The tree that this fragment is based on.\n    readonly tree: Tree,\n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    readonly offset: number,\n    private open: number\n  ) {}\n\n  get openStart() { return (this.open & Open.Start) > 0 }\n\n  get openEnd() { return (this.open & Open.End) > 0 }\n\n  /// Apply a set of edits to an array of fragments, removing or\n  /// splitting fragments as necessary to remove edited ranges, and\n  /// adjusting offsets for fragments that moved.\n  static applyChanges(fragments: readonly TreeFragment[], changes: readonly ChangedRange[], minGap = 128) {\n    if (!changes.length) return fragments\n    let result: TreeFragment[] = []\n    let fI = 1, nextF = fragments.length ? fragments[0] : null\n    let cI = 0, pos = 0, off = 0\n    for (;;) {\n      let nextC = cI < changes.length ? changes[cI++] : null\n      let nextPos = nextC ? nextC.fromA : 1e9\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut: TreeFragment | null = nextF\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off\n          cut = fFrom >= fTo ? null :\n            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off,\n                             (cI > 0 ? Open.Start : 0) | (nextC ? Open.End : 0))\n        }\n        if (cut) result.push(cut)\n        if (nextF.to > nextPos) break\n        nextF = fI < fragments.length ? fragments[fI++] : null\n      }\n      if (!nextC) break\n      pos = nextC.toA\n      off = nextC.toA - nextC.toB\n    }\n    return result\n  }\n\n  /// Create a set of fragments from a freshly parsed tree, or update\n  /// an existing set of fragments by replacing the ones that overlap\n  /// with a tree with content from the new tree. When `partial` is\n  /// true, the parse is treated as incomplete, and the token at its\n  /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n  static addTree(tree: Tree, fragments: readonly TreeFragment[] = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? Open.End : 0)]\n    for (let f of fragments) if (f.to > tree.length) result.push(f)\n    return result\n  }\n}\n\n/// Interface used to represent an in-progress parse, which can be\n/// moved forward piece-by-piece.\nexport interface PartialParse {\n  /// Advance the parse state by some amount.\n  advance(): Tree | null\n  /// The current parse position.\n  pos: number\n  /// Get the currently parsed content as a tree, even though the\n  /// parse hasn't finished yet.\n  forceFinish(): Tree\n}\n\n/// A parse context is an object providing additional information to the\n/// parser. It is passed through to nested parsers.\nexport interface ParseContext {\n  /// A set of fragments from a previous parse to be used for incremental\n  /// parsing. These should be aligned with the current document\n  /// (through a call to\n  /// [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges))\n  /// if any changes were made since they were produced. The parser\n  /// will try to reuse nodes from the fragments in the new parse,\n  /// greatly speeding up the parse when it can do so for most of the\n  /// document.\n  fragments?: readonly TreeFragment[]\n}\n\n/// This is the interface the parser uses to access the document. It\n/// exposes a sequence of UTF16 code units. Most (but not _all_)\n/// access, especially through `get`, will be sequential, so\n/// implementations can optimize for that.\nexport interface Input {\n  /// The end of the stream.\n  length: number\n  /// Get the code unit at the given position. Will return -1 when\n  /// asked for a point below 0 or beyond the end of the stream.\n  get(pos: number): number\n  /// Returns the string between `pos` and the next newline character\n  /// or the end of the document. Not used by the built-in tokenizers,\n  /// but can be useful in custom tokenizers or completely custom\n  /// parsers.\n  lineAfter(pos: number): string\n  /// Read part of the stream as a string\n  read(from: number, to: number): string\n  /// Return a new `Input` over the same data, but with a lower\n  /// `length`. Used, for example, when nesting grammars to give the\n  /// inner grammar a narrower view of the input.\n  clip(at: number): Input\n}\n\n// Creates an `Input` that is backed by a single, flat string.\nexport function stringInput(input: string): Input { return new StringInput(input) }\n\nclass StringInput implements Input {\n  constructor(readonly string: string, readonly length = string.length) {}\n\n  get(pos: number) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos)\n  }\n\n  lineAfter(pos: number) {\n    if (pos < 0) return \"\"\n    let end = this.string.indexOf(\"\\n\", pos)\n    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length))\n  }\n  \n  read(from: number, to: number): string { return this.string.slice(from, Math.min(this.length, to)) }\n\n  clip(at: number) { return new StringInput(this.string, at) }\n}\n"],"names":[],"mappings":"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"}