{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nvar lezer_promql_1 = require(\"lezer-promql\");\n\nvar path_finder_1 = require(\"./path-finder\");\n\nvar type_1 = require(\"./type\");\n\nvar matcher_1 = require(\"./matcher\");\n\nvar language_1 = require(\"@codemirror/language\");\n\nvar types_1 = require(\"../types\");\n\nvar vector_1 = require(\"./vector\");\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(state) {\n    this.tree = language_1.syntaxTree(state);\n    this.state = state;\n    this.diagnostics = [];\n  }\n\n  Parser.prototype.getDiagnostics = function () {\n    return this.diagnostics.sort(function (a, b) {\n      return a.from - b.from;\n    });\n  };\n\n  Parser.prototype.analyze = function () {\n    // when you are at the root of the tree, the first node is not `Expr` but a node with no name.\n    // So to be able to iterate other the node relative to the promql node, we have to get the first child at the beginning\n    this.checkAST(this.tree.topNode.firstChild);\n    this.diagnoseAllErrorNodes();\n  };\n\n  Parser.prototype.diagnoseAllErrorNodes = function () {\n    var cursor = this.tree.cursor();\n\n    while (cursor.next()) {\n      // usually there is an error node at the end of the expression when user is typing\n      // so it's not really a useful information to say the expression is wrong.\n      // Hopefully if there is an error node at the end of the tree, checkAST should yell more precisely\n      if (cursor.type.id === 0 && cursor.to !== this.tree.topNode.to) {\n        var node = cursor.node.parent;\n        this.diagnostics.push({\n          severity: 'error',\n          message: 'unexpected expression',\n          from: node ? node.from : cursor.from,\n          to: node ? node.to : cursor.to\n        });\n      }\n    }\n  }; // checkAST is inspired of the same named method from prometheus/prometheus:\n  // https://github.com/prometheus/prometheus/blob/3470ee1fbf9d424784eb2613bab5ab0f14b4d222/promql/parser/parse.go#L433\n\n\n  Parser.prototype.checkAST = function (node) {\n    if (!node) {\n      return types_1.ValueType.none;\n    }\n\n    switch (node.type.id) {\n      case lezer_promql_1.Expr:\n        return this.checkAST(node.firstChild);\n\n      case lezer_promql_1.AggregateExpr:\n        this.checkAggregationExpr(node);\n        break;\n\n      case lezer_promql_1.BinaryExpr:\n        this.checkBinaryExpr(node);\n        break;\n\n      case lezer_promql_1.FunctionCall:\n        this.checkCallFunction(node);\n        break;\n\n      case lezer_promql_1.ParenExpr:\n        this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n        break;\n\n      case lezer_promql_1.UnaryExpr:\n        var unaryExprType = this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n\n        if (unaryExprType !== types_1.ValueType.scalar && unaryExprType !== types_1.ValueType.vector) {\n          this.addDiagnostic(node, \"unary expression only allowed on expressions of type scalar or instant vector, got \" + unaryExprType);\n        }\n\n        break;\n\n      case lezer_promql_1.SubqueryExpr:\n        var subQueryExprType = this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n\n        if (subQueryExprType !== types_1.ValueType.vector) {\n          this.addDiagnostic(node, \"subquery is only allowed on instant vector, got \" + subQueryExprType + \" in \" + node.name + \" instead\");\n        }\n\n        break;\n\n      case lezer_promql_1.MatrixSelector:\n        this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n        break;\n\n      case lezer_promql_1.VectorSelector:\n        this.checkVectorSelector(node);\n        break;\n\n      case lezer_promql_1.StepInvariantExpr:\n        var exprValue = this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n\n        if (exprValue !== types_1.ValueType.vector && exprValue !== types_1.ValueType.matrix) {\n          this.addDiagnostic(node, \"@ modifier must be preceded by an instant selector vector or range vector selector or a subquery\");\n        } // if you are looking at the Prometheus code, you will likely find that some checks are missing here.\n        // Specially the one checking if the timestamp after the `@` is ok: https://github.com/prometheus/prometheus/blob/ad5ed416ba635834370bfa06139258b31f8c33f9/promql/parser/parse.go#L722-L725\n        // Since Javascript is managing the number as a float64 and so on 53 bits, we cannot validate that the maxInt64 number is a valid value.\n        // So, to manage properly this issue, we would need to use the BigInt which is possible or by using ES2020.BigInt, or by using the lib: https://github.com/GoogleChromeLabs/jsbi.\n        //   * Introducing a lib just for theses checks is quite overkilled\n        //   * Using ES2020 would be the way to go. Unfortunately moving to ES2020 is breaking the build of the lib.\n        //     So far I didn't find the way to fix it. I think it's likely due to the fact we are building an ESM package which is now something stable in nodeJS/javascript but still experimental in typescript.\n        // For the above reason, we decided to drop these checks.\n\n\n        break;\n    }\n\n    return type_1.getType(node);\n  };\n\n  Parser.prototype.checkAggregationExpr = function (node) {\n    var _a; // according to https://github.com/promlabs/lezer-promql/blob/master/src/promql.grammar#L26\n    // the name of the aggregator function is stored in the first child\n\n\n    var aggregateOp = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n\n    if (!aggregateOp) {\n      this.addDiagnostic(node, 'aggregation operator expected in aggregation expression but got nothing');\n      return;\n    }\n\n    var expr = path_finder_1.walkThrough(node, lezer_promql_1.FunctionCallBody, lezer_promql_1.FunctionCallArgs, lezer_promql_1.Expr);\n\n    if (!expr) {\n      this.addDiagnostic(node, 'unable to find the parameter for the expression');\n      return;\n    }\n\n    this.expectType(expr, types_1.ValueType.vector, 'aggregation expression'); // get the parameter of the aggregation operator\n\n    var params = path_finder_1.walkThrough(node, lezer_promql_1.FunctionCallBody, lezer_promql_1.FunctionCallArgs, lezer_promql_1.FunctionCallArgs, lezer_promql_1.Expr);\n\n    if (aggregateOp.type.id === lezer_promql_1.Topk || aggregateOp.type.id === lezer_promql_1.Bottomk || aggregateOp.type.id === lezer_promql_1.Quantile) {\n      if (!params) {\n        this.addDiagnostic(node, 'no parameter found');\n        return;\n      }\n\n      this.expectType(params, types_1.ValueType.scalar, 'aggregation parameter');\n    }\n\n    if (aggregateOp.type.id === lezer_promql_1.CountValues) {\n      if (!params) {\n        this.addDiagnostic(node, 'no parameter found');\n        return;\n      }\n\n      this.expectType(params, types_1.ValueType.string, 'aggregation parameter');\n    }\n  };\n\n  Parser.prototype.checkBinaryExpr = function (node) {\n    var e_1, _a, e_2, _b; // Following the definition of the BinaryExpr, the left and the right\n    // expression are respectively the first and last child\n    // https://github.com/promlabs/lezer-promql/blob/master/src/promql.grammar#L52\n\n\n    var lExpr = node.firstChild;\n    var rExpr = node.lastChild;\n\n    if (!lExpr || !rExpr) {\n      this.addDiagnostic(node, 'left or right expression is missing in binary expression');\n      return;\n    }\n\n    var lt = this.checkAST(lExpr);\n    var rt = this.checkAST(rExpr);\n    var boolModifierUsed = path_finder_1.walkThrough(node, lezer_promql_1.BinModifiers, lezer_promql_1.Bool);\n    var isComparisonOperator = path_finder_1.containsAtLeastOneChild(node, lezer_promql_1.Eql, lezer_promql_1.Neq, lezer_promql_1.Lte, lezer_promql_1.Lss, lezer_promql_1.Gte, lezer_promql_1.Gtr);\n    var isSetOperator = path_finder_1.containsAtLeastOneChild(node, lezer_promql_1.And, lezer_promql_1.Or, lezer_promql_1.Unless); // BOOL modifier check\n\n    if (boolModifierUsed) {\n      if (!isComparisonOperator) {\n        this.addDiagnostic(node, 'bool modifier can only be used on comparison operators');\n      }\n    } else {\n      if (isComparisonOperator && lt === types_1.ValueType.scalar && rt === types_1.ValueType.scalar) {\n        this.addDiagnostic(node, 'comparisons between scalars must use BOOL modifier');\n      }\n    }\n\n    var vectorMatching = vector_1.buildVectorMatching(this.state, node);\n\n    if (vectorMatching !== null && vectorMatching.on) {\n      try {\n        for (var _c = __values(vectorMatching.matchingLabels), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var l1 = _d.value;\n\n          try {\n            for (var _e = (e_2 = void 0, __values(vectorMatching.include)), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var l2 = _f.value;\n\n              if (l1 === l2) {\n                this.addDiagnostic(node, \"label \\\"\" + l1 + \"\\\" must not occur in ON and GROUP clause at once\");\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    if (lt !== types_1.ValueType.scalar && lt !== types_1.ValueType.vector) {\n      this.addDiagnostic(lExpr, 'binary expression must contain only scalar and instant vector types');\n    }\n\n    if (rt !== types_1.ValueType.scalar && rt !== types_1.ValueType.vector) {\n      this.addDiagnostic(rExpr, 'binary expression must contain only scalar and instant vector types');\n    }\n\n    if ((lt !== types_1.ValueType.vector || rt !== types_1.ValueType.vector) && vectorMatching !== null) {\n      if (vectorMatching.matchingLabels.length > 0) {\n        this.addDiagnostic(node, 'vector matching only allowed between instant vectors');\n      }\n    } else {\n      if (isSetOperator) {\n        if ((vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) === types_1.VectorMatchCardinality.CardOneToMany || (vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) === types_1.VectorMatchCardinality.CardManyToOne) {\n          this.addDiagnostic(node, 'no grouping allowed for set operations');\n        }\n\n        if ((vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) !== types_1.VectorMatchCardinality.CardManyToMany) {\n          this.addDiagnostic(node, 'set operations must always be many-to-many');\n        }\n      }\n    }\n\n    if ((lt === types_1.ValueType.scalar || rt === types_1.ValueType.scalar) && isSetOperator) {\n      this.addDiagnostic(node, 'set operator not allowed in binary scalar expression');\n    }\n  };\n\n  Parser.prototype.checkCallFunction = function (node) {\n    var _a;\n\n    var funcID = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n\n    if (!funcID) {\n      this.addDiagnostic(node, 'function not defined');\n      return;\n    }\n\n    var args = path_finder_1.retrieveAllRecursiveNodes(path_finder_1.walkThrough(node, lezer_promql_1.FunctionCallBody), lezer_promql_1.FunctionCallArgs, lezer_promql_1.Expr);\n    var funcSignature = types_1.getFunction(funcID.type.id);\n    var nargs = funcSignature.argTypes.length;\n\n    if (funcSignature.variadic === 0) {\n      if (args.length !== nargs) {\n        this.addDiagnostic(node, \"expected \" + nargs + \" argument(s) in call to \\\"\" + funcSignature.name + \"\\\", got \" + args.length);\n      }\n    } else {\n      var na = nargs - 1;\n\n      if (na > args.length) {\n        this.addDiagnostic(node, \"expected at least \" + na + \" argument(s) in call to \\\"\" + funcSignature.name + \"\\\", got \" + args.length);\n      } else {\n        var nargsmax = na + funcSignature.variadic;\n\n        if (funcSignature.variadic > 0 && nargsmax < args.length) {\n          this.addDiagnostic(node, \"expected at most \" + nargsmax + \" argument(s) in call to \\\"\" + funcSignature.name + \"\\\", got \" + args.length);\n        }\n      }\n    }\n\n    var j = 0;\n\n    for (var i = 0; i < args.length; i++) {\n      j = i;\n\n      if (j >= funcSignature.argTypes.length) {\n        if (funcSignature.variadic === 0) {\n          // This is not a vararg function so we should not check the\n          // type of the extra arguments.\n          break;\n        }\n\n        j = funcSignature.argTypes.length - 1;\n      }\n\n      this.expectType(args[i], funcSignature.argTypes[j], \"call to function \\\"\" + funcSignature.name + \"\\\"\");\n    }\n  };\n\n  Parser.prototype.checkVectorSelector = function (node) {\n    var labelMatchers = matcher_1.buildLabelMatchers(path_finder_1.retrieveAllRecursiveNodes(path_finder_1.walkThrough(node, lezer_promql_1.LabelMatchers, lezer_promql_1.LabelMatchList), lezer_promql_1.LabelMatchList, lezer_promql_1.LabelMatcher), this.state);\n    var vectorSelectorName = ''; // VectorSelector ( MetricIdentifier ( Identifier ) )\n    // https://github.com/promlabs/lezer-promql/blob/71e2f9fa5ae6f5c5547d5738966cd2512e6b99a8/src/promql.grammar#L200\n\n    var vectorSelectorNodeName = path_finder_1.walkThrough(node, lezer_promql_1.MetricIdentifier, lezer_promql_1.Identifier);\n\n    if (vectorSelectorNodeName) {\n      vectorSelectorName = this.state.sliceDoc(vectorSelectorNodeName.from, vectorSelectorNodeName.to);\n    }\n\n    if (vectorSelectorName !== '') {\n      // In this case the last LabelMatcher is checking for the metric name\n      // set outside the braces. This checks if the name has already been set\n      // previously\n      var labelMatcherMetricName = labelMatchers.find(function (lm) {\n        return lm.name === '__name__';\n      });\n\n      if (labelMatcherMetricName) {\n        this.addDiagnostic(node, \"metric name must not be set twice: \" + vectorSelectorName + \" or \" + labelMatcherMetricName.value);\n      } // adding the metric name as a Matcher to avoid a false positive for this kind of expression:\n      // foo{bare=''}\n\n\n      labelMatchers.push(new types_1.Matcher(lezer_promql_1.EqlSingle, '__name__', vectorSelectorName));\n    } // A Vector selector must contain at least one non-empty matcher to prevent\n    // implicit selection of all metrics (e.g. by a typo).\n\n\n    var empty = labelMatchers.every(function (lm) {\n      return lm.matchesEmpty();\n    });\n\n    if (empty) {\n      this.addDiagnostic(node, 'vector selector must contain at least one non-empty matcher');\n    }\n  };\n\n  Parser.prototype.expectType = function (node, want, context) {\n    var t = this.checkAST(node);\n\n    if (t !== want) {\n      this.addDiagnostic(node, \"expected type \" + want + \" in \" + context + \", got \" + t);\n    }\n  };\n\n  Parser.prototype.addDiagnostic = function (node, msg) {\n    this.diagnostics.push({\n      severity: 'error',\n      message: msg,\n      from: node.from,\n      to: node.to\n    });\n  };\n\n  return Parser;\n}();\n\nexports.Parser = Parser;","map":{"version":3,"sources":["../../../src/lang-promql/parser/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nvar lezer_promql_1 = require(\"lezer-promql\");\nvar path_finder_1 = require(\"./path-finder\");\nvar type_1 = require(\"./type\");\nvar matcher_1 = require(\"./matcher\");\nvar language_1 = require(\"@codemirror/language\");\nvar types_1 = require(\"../types\");\nvar vector_1 = require(\"./vector\");\nvar Parser = /** @class */ (function () {\n    function Parser(state) {\n        this.tree = language_1.syntaxTree(state);\n        this.state = state;\n        this.diagnostics = [];\n    }\n    Parser.prototype.getDiagnostics = function () {\n        return this.diagnostics.sort(function (a, b) {\n            return a.from - b.from;\n        });\n    };\n    Parser.prototype.analyze = function () {\n        // when you are at the root of the tree, the first node is not `Expr` but a node with no name.\n        // So to be able to iterate other the node relative to the promql node, we have to get the first child at the beginning\n        this.checkAST(this.tree.topNode.firstChild);\n        this.diagnoseAllErrorNodes();\n    };\n    Parser.prototype.diagnoseAllErrorNodes = function () {\n        var cursor = this.tree.cursor();\n        while (cursor.next()) {\n            // usually there is an error node at the end of the expression when user is typing\n            // so it's not really a useful information to say the expression is wrong.\n            // Hopefully if there is an error node at the end of the tree, checkAST should yell more precisely\n            if (cursor.type.id === 0 && cursor.to !== this.tree.topNode.to) {\n                var node = cursor.node.parent;\n                this.diagnostics.push({\n                    severity: 'error',\n                    message: 'unexpected expression',\n                    from: node ? node.from : cursor.from,\n                    to: node ? node.to : cursor.to,\n                });\n            }\n        }\n    };\n    // checkAST is inspired of the same named method from prometheus/prometheus:\n    // https://github.com/prometheus/prometheus/blob/3470ee1fbf9d424784eb2613bab5ab0f14b4d222/promql/parser/parse.go#L433\n    Parser.prototype.checkAST = function (node) {\n        if (!node) {\n            return types_1.ValueType.none;\n        }\n        switch (node.type.id) {\n            case lezer_promql_1.Expr:\n                return this.checkAST(node.firstChild);\n            case lezer_promql_1.AggregateExpr:\n                this.checkAggregationExpr(node);\n                break;\n            case lezer_promql_1.BinaryExpr:\n                this.checkBinaryExpr(node);\n                break;\n            case lezer_promql_1.FunctionCall:\n                this.checkCallFunction(node);\n                break;\n            case lezer_promql_1.ParenExpr:\n                this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n                break;\n            case lezer_promql_1.UnaryExpr:\n                var unaryExprType = this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n                if (unaryExprType !== types_1.ValueType.scalar && unaryExprType !== types_1.ValueType.vector) {\n                    this.addDiagnostic(node, \"unary expression only allowed on expressions of type scalar or instant vector, got \" + unaryExprType);\n                }\n                break;\n            case lezer_promql_1.SubqueryExpr:\n                var subQueryExprType = this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n                if (subQueryExprType !== types_1.ValueType.vector) {\n                    this.addDiagnostic(node, \"subquery is only allowed on instant vector, got \" + subQueryExprType + \" in \" + node.name + \" instead\");\n                }\n                break;\n            case lezer_promql_1.MatrixSelector:\n                this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n                break;\n            case lezer_promql_1.VectorSelector:\n                this.checkVectorSelector(node);\n                break;\n            case lezer_promql_1.StepInvariantExpr:\n                var exprValue = this.checkAST(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n                if (exprValue !== types_1.ValueType.vector && exprValue !== types_1.ValueType.matrix) {\n                    this.addDiagnostic(node, \"@ modifier must be preceded by an instant selector vector or range vector selector or a subquery\");\n                }\n                // if you are looking at the Prometheus code, you will likely find that some checks are missing here.\n                // Specially the one checking if the timestamp after the `@` is ok: https://github.com/prometheus/prometheus/blob/ad5ed416ba635834370bfa06139258b31f8c33f9/promql/parser/parse.go#L722-L725\n                // Since Javascript is managing the number as a float64 and so on 53 bits, we cannot validate that the maxInt64 number is a valid value.\n                // So, to manage properly this issue, we would need to use the BigInt which is possible or by using ES2020.BigInt, or by using the lib: https://github.com/GoogleChromeLabs/jsbi.\n                //   * Introducing a lib just for theses checks is quite overkilled\n                //   * Using ES2020 would be the way to go. Unfortunately moving to ES2020 is breaking the build of the lib.\n                //     So far I didn't find the way to fix it. I think it's likely due to the fact we are building an ESM package which is now something stable in nodeJS/javascript but still experimental in typescript.\n                // For the above reason, we decided to drop these checks.\n                break;\n        }\n        return type_1.getType(node);\n    };\n    Parser.prototype.checkAggregationExpr = function (node) {\n        var _a;\n        // according to https://github.com/promlabs/lezer-promql/blob/master/src/promql.grammar#L26\n        // the name of the aggregator function is stored in the first child\n        var aggregateOp = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n        if (!aggregateOp) {\n            this.addDiagnostic(node, 'aggregation operator expected in aggregation expression but got nothing');\n            return;\n        }\n        var expr = path_finder_1.walkThrough(node, lezer_promql_1.FunctionCallBody, lezer_promql_1.FunctionCallArgs, lezer_promql_1.Expr);\n        if (!expr) {\n            this.addDiagnostic(node, 'unable to find the parameter for the expression');\n            return;\n        }\n        this.expectType(expr, types_1.ValueType.vector, 'aggregation expression');\n        // get the parameter of the aggregation operator\n        var params = path_finder_1.walkThrough(node, lezer_promql_1.FunctionCallBody, lezer_promql_1.FunctionCallArgs, lezer_promql_1.FunctionCallArgs, lezer_promql_1.Expr);\n        if (aggregateOp.type.id === lezer_promql_1.Topk || aggregateOp.type.id === lezer_promql_1.Bottomk || aggregateOp.type.id === lezer_promql_1.Quantile) {\n            if (!params) {\n                this.addDiagnostic(node, 'no parameter found');\n                return;\n            }\n            this.expectType(params, types_1.ValueType.scalar, 'aggregation parameter');\n        }\n        if (aggregateOp.type.id === lezer_promql_1.CountValues) {\n            if (!params) {\n                this.addDiagnostic(node, 'no parameter found');\n                return;\n            }\n            this.expectType(params, types_1.ValueType.string, 'aggregation parameter');\n        }\n    };\n    Parser.prototype.checkBinaryExpr = function (node) {\n        var e_1, _a, e_2, _b;\n        // Following the definition of the BinaryExpr, the left and the right\n        // expression are respectively the first and last child\n        // https://github.com/promlabs/lezer-promql/blob/master/src/promql.grammar#L52\n        var lExpr = node.firstChild;\n        var rExpr = node.lastChild;\n        if (!lExpr || !rExpr) {\n            this.addDiagnostic(node, 'left or right expression is missing in binary expression');\n            return;\n        }\n        var lt = this.checkAST(lExpr);\n        var rt = this.checkAST(rExpr);\n        var boolModifierUsed = path_finder_1.walkThrough(node, lezer_promql_1.BinModifiers, lezer_promql_1.Bool);\n        var isComparisonOperator = path_finder_1.containsAtLeastOneChild(node, lezer_promql_1.Eql, lezer_promql_1.Neq, lezer_promql_1.Lte, lezer_promql_1.Lss, lezer_promql_1.Gte, lezer_promql_1.Gtr);\n        var isSetOperator = path_finder_1.containsAtLeastOneChild(node, lezer_promql_1.And, lezer_promql_1.Or, lezer_promql_1.Unless);\n        // BOOL modifier check\n        if (boolModifierUsed) {\n            if (!isComparisonOperator) {\n                this.addDiagnostic(node, 'bool modifier can only be used on comparison operators');\n            }\n        }\n        else {\n            if (isComparisonOperator && lt === types_1.ValueType.scalar && rt === types_1.ValueType.scalar) {\n                this.addDiagnostic(node, 'comparisons between scalars must use BOOL modifier');\n            }\n        }\n        var vectorMatching = vector_1.buildVectorMatching(this.state, node);\n        if (vectorMatching !== null && vectorMatching.on) {\n            try {\n                for (var _c = __values(vectorMatching.matchingLabels), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var l1 = _d.value;\n                    try {\n                        for (var _e = (e_2 = void 0, __values(vectorMatching.include)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                            var l2 = _f.value;\n                            if (l1 === l2) {\n                                this.addDiagnostic(node, \"label \\\"\" + l1 + \"\\\" must not occur in ON and GROUP clause at once\");\n                            }\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        if (lt !== types_1.ValueType.scalar && lt !== types_1.ValueType.vector) {\n            this.addDiagnostic(lExpr, 'binary expression must contain only scalar and instant vector types');\n        }\n        if (rt !== types_1.ValueType.scalar && rt !== types_1.ValueType.vector) {\n            this.addDiagnostic(rExpr, 'binary expression must contain only scalar and instant vector types');\n        }\n        if ((lt !== types_1.ValueType.vector || rt !== types_1.ValueType.vector) && vectorMatching !== null) {\n            if (vectorMatching.matchingLabels.length > 0) {\n                this.addDiagnostic(node, 'vector matching only allowed between instant vectors');\n            }\n        }\n        else {\n            if (isSetOperator) {\n                if ((vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) === types_1.VectorMatchCardinality.CardOneToMany || (vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) === types_1.VectorMatchCardinality.CardManyToOne) {\n                    this.addDiagnostic(node, 'no grouping allowed for set operations');\n                }\n                if ((vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) !== types_1.VectorMatchCardinality.CardManyToMany) {\n                    this.addDiagnostic(node, 'set operations must always be many-to-many');\n                }\n            }\n        }\n        if ((lt === types_1.ValueType.scalar || rt === types_1.ValueType.scalar) && isSetOperator) {\n            this.addDiagnostic(node, 'set operator not allowed in binary scalar expression');\n        }\n    };\n    Parser.prototype.checkCallFunction = function (node) {\n        var _a;\n        var funcID = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n        if (!funcID) {\n            this.addDiagnostic(node, 'function not defined');\n            return;\n        }\n        var args = path_finder_1.retrieveAllRecursiveNodes(path_finder_1.walkThrough(node, lezer_promql_1.FunctionCallBody), lezer_promql_1.FunctionCallArgs, lezer_promql_1.Expr);\n        var funcSignature = types_1.getFunction(funcID.type.id);\n        var nargs = funcSignature.argTypes.length;\n        if (funcSignature.variadic === 0) {\n            if (args.length !== nargs) {\n                this.addDiagnostic(node, \"expected \" + nargs + \" argument(s) in call to \\\"\" + funcSignature.name + \"\\\", got \" + args.length);\n            }\n        }\n        else {\n            var na = nargs - 1;\n            if (na > args.length) {\n                this.addDiagnostic(node, \"expected at least \" + na + \" argument(s) in call to \\\"\" + funcSignature.name + \"\\\", got \" + args.length);\n            }\n            else {\n                var nargsmax = na + funcSignature.variadic;\n                if (funcSignature.variadic > 0 && nargsmax < args.length) {\n                    this.addDiagnostic(node, \"expected at most \" + nargsmax + \" argument(s) in call to \\\"\" + funcSignature.name + \"\\\", got \" + args.length);\n                }\n            }\n        }\n        var j = 0;\n        for (var i = 0; i < args.length; i++) {\n            j = i;\n            if (j >= funcSignature.argTypes.length) {\n                if (funcSignature.variadic === 0) {\n                    // This is not a vararg function so we should not check the\n                    // type of the extra arguments.\n                    break;\n                }\n                j = funcSignature.argTypes.length - 1;\n            }\n            this.expectType(args[i], funcSignature.argTypes[j], \"call to function \\\"\" + funcSignature.name + \"\\\"\");\n        }\n    };\n    Parser.prototype.checkVectorSelector = function (node) {\n        var labelMatchers = matcher_1.buildLabelMatchers(path_finder_1.retrieveAllRecursiveNodes(path_finder_1.walkThrough(node, lezer_promql_1.LabelMatchers, lezer_promql_1.LabelMatchList), lezer_promql_1.LabelMatchList, lezer_promql_1.LabelMatcher), this.state);\n        var vectorSelectorName = '';\n        // VectorSelector ( MetricIdentifier ( Identifier ) )\n        // https://github.com/promlabs/lezer-promql/blob/71e2f9fa5ae6f5c5547d5738966cd2512e6b99a8/src/promql.grammar#L200\n        var vectorSelectorNodeName = path_finder_1.walkThrough(node, lezer_promql_1.MetricIdentifier, lezer_promql_1.Identifier);\n        if (vectorSelectorNodeName) {\n            vectorSelectorName = this.state.sliceDoc(vectorSelectorNodeName.from, vectorSelectorNodeName.to);\n        }\n        if (vectorSelectorName !== '') {\n            // In this case the last LabelMatcher is checking for the metric name\n            // set outside the braces. This checks if the name has already been set\n            // previously\n            var labelMatcherMetricName = labelMatchers.find(function (lm) { return lm.name === '__name__'; });\n            if (labelMatcherMetricName) {\n                this.addDiagnostic(node, \"metric name must not be set twice: \" + vectorSelectorName + \" or \" + labelMatcherMetricName.value);\n            }\n            // adding the metric name as a Matcher to avoid a false positive for this kind of expression:\n            // foo{bare=''}\n            labelMatchers.push(new types_1.Matcher(lezer_promql_1.EqlSingle, '__name__', vectorSelectorName));\n        }\n        // A Vector selector must contain at least one non-empty matcher to prevent\n        // implicit selection of all metrics (e.g. by a typo).\n        var empty = labelMatchers.every(function (lm) { return lm.matchesEmpty(); });\n        if (empty) {\n            this.addDiagnostic(node, 'vector selector must contain at least one non-empty matcher');\n        }\n    };\n    Parser.prototype.expectType = function (node, want, context) {\n        var t = this.checkAST(node);\n        if (t !== want) {\n            this.addDiagnostic(node, \"expected type \" + want + \" in \" + context + \", got \" + t);\n        }\n    };\n    Parser.prototype.addDiagnostic = function (node, msg) {\n        this.diagnostics.push({\n            severity: 'error',\n            message: msg,\n            from: node.from,\n            to: node.to,\n        });\n    };\n    return Parser;\n}());\nexports.Parser = Parser;\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"script"}