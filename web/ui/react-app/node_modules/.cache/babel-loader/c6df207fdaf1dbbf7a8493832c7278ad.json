{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HybridComplete = exports.analyzeCompletion = exports.computeStartCompletePosition = exports.ContextKind = void 0;\n\nvar lezer_promql_1 = require(\"lezer-promql\");\n\nvar parser_1 = require(\"../parser\");\n\nvar promql_terms_1 = require(\"./promql.terms\");\n\nvar language_1 = require(\"@codemirror/language\");\n\nvar autocompleteNodes = {\n  matchOp: promql_terms_1.matchOpTerms,\n  binOp: promql_terms_1.binOpTerms,\n  duration: promql_terms_1.durationTerms,\n  binOpModifier: promql_terms_1.binOpModifierTerms,\n  atModifier: promql_terms_1.atModifierTerms,\n  functionIdentifier: promql_terms_1.functionIdentifierTerms,\n  aggregateOp: promql_terms_1.aggregateOpTerms,\n  aggregateOpModifier: promql_terms_1.aggregateOpModifierTerms\n}; // ContextKind is the different possible value determinate by the autocompletion\n\nvar ContextKind;\n\n(function (ContextKind) {\n  // dynamic autocompletion (required a distant server)\n  ContextKind[ContextKind[\"MetricName\"] = 0] = \"MetricName\";\n  ContextKind[ContextKind[\"LabelName\"] = 1] = \"LabelName\";\n  ContextKind[ContextKind[\"LabelValue\"] = 2] = \"LabelValue\"; // static autocompletion\n\n  ContextKind[ContextKind[\"Function\"] = 3] = \"Function\";\n  ContextKind[ContextKind[\"Aggregation\"] = 4] = \"Aggregation\";\n  ContextKind[ContextKind[\"BinOpModifier\"] = 5] = \"BinOpModifier\";\n  ContextKind[ContextKind[\"BinOp\"] = 6] = \"BinOp\";\n  ContextKind[ContextKind[\"MatchOp\"] = 7] = \"MatchOp\";\n  ContextKind[ContextKind[\"AggregateOpModifier\"] = 8] = \"AggregateOpModifier\";\n  ContextKind[ContextKind[\"Duration\"] = 9] = \"Duration\";\n  ContextKind[ContextKind[\"Offset\"] = 10] = \"Offset\";\n  ContextKind[ContextKind[\"Bool\"] = 11] = \"Bool\";\n  ContextKind[ContextKind[\"AtModifiers\"] = 12] = \"AtModifiers\";\n})(ContextKind = exports.ContextKind || (exports.ContextKind = {}));\n\nfunction getMetricNameInVectorSelector(tree, state) {\n  // Find if there is a defined metric name. Should be used to autocomplete a labelValue or a labelName\n  // First find the parent \"VectorSelector\" to be able to find then the subChild \"MetricIdentifier\" if it exists.\n  var currentNode = parser_1.walkBackward(tree, lezer_promql_1.VectorSelector);\n\n  if (!currentNode) {\n    // Weird case that shouldn't happen, because \"VectorSelector\" is by definition the parent of the LabelMatchers.\n    return '';\n  }\n\n  currentNode = parser_1.walkThrough(currentNode, lezer_promql_1.MetricIdentifier, lezer_promql_1.Identifier);\n\n  if (!currentNode) {\n    return '';\n  }\n\n  return state.sliceDoc(currentNode.from, currentNode.to);\n}\n\nfunction arrayToCompletionResult(data, from, to, includeSnippet, span) {\n  if (includeSnippet === void 0) {\n    includeSnippet = false;\n  }\n\n  if (span === void 0) {\n    span = true;\n  }\n\n  var options = data;\n\n  if (includeSnippet) {\n    options.push.apply(options, __spreadArray([], __read(promql_terms_1.snippets)));\n  }\n\n  return {\n    from: from,\n    to: to,\n    options: options,\n    span: span ? /^[a-zA-Z0-9_:]+$/ : undefined\n  };\n} // computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel calculates the start position only when the node is a LabelMatchers or a GroupingLabels\n\n\nfunction computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel(node, pos) {\n  // Here we can have two different situations:\n  // 1. `metric{}` or `sum by()` with the cursor between the bracket\n  // and so we have increment the starting position to avoid to consider the open bracket when filtering the autocompletion list.\n  // 2. `metric{foo=\"bar\",} or `sum by(foo,)  with the cursor after the comma.\n  // Then the start number should be the current position to avoid to consider the previous labelMatcher/groupingLabel when filtering the autocompletion list.\n  var start = node.from + 1;\n\n  if (node.firstChild !== null) {\n    // here that means the LabelMatchers / GroupingLabels has a child, which is not possible if we have the expression `metric{}`. So we are likely trying to autocomplete the label list after a comma\n    start = pos;\n  }\n\n  return start;\n} // computeStartCompletePosition calculates the start position of the autocompletion.\n// It is an important step because the start position will be used by CMN to find the string and then to use it to filter the CompletionResult.\n// A wrong `start` position will lead to have the completion not working.\n// Note: this method is exported only for testing purpose.\n\n\nfunction computeStartCompletePosition(node, pos) {\n  var _a, _b, _c, _d, _e, _f;\n\n  var start = node.from;\n\n  if (node.type.id === lezer_promql_1.LabelMatchers || node.type.id === lezer_promql_1.GroupingLabels) {\n    start = computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel(node, pos);\n  } else if (node.type.id === lezer_promql_1.FunctionCallBody || node.type.id === lezer_promql_1.StringLiteral && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type.id) === lezer_promql_1.LabelMatcher) {\n    // When the cursor is between bracket, quote, we need to increment the starting position to avoid to consider the open bracket/ first string.\n    start++;\n  } else if (node.type.id === lezer_promql_1.OffsetExpr || node.type.id === lezer_promql_1.NumberLiteral && ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type.id) === 0 && ((_c = node.parent.parent) === null || _c === void 0 ? void 0 : _c.type.id) === lezer_promql_1.SubqueryExpr || node.type.id === 0 && (((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type.id) === lezer_promql_1.OffsetExpr || ((_e = node.parent) === null || _e === void 0 ? void 0 : _e.type.id) === lezer_promql_1.MatrixSelector || ((_f = node.parent) === null || _f === void 0 ? void 0 : _f.type.id) === lezer_promql_1.SubqueryExpr && parser_1.containsAtLeastOneChild(node.parent, lezer_promql_1.Duration))) {\n    start = pos;\n  }\n\n  return start;\n}\n\nexports.computeStartCompletePosition = computeStartCompletePosition; // analyzeCompletion is going to determinate what should be autocompleted.\n// The value of the autocompletion is then calculate by the function buildCompletion.\n// Note: this method is exported for testing purpose only. Do not use it directly.\n\nfunction analyzeCompletion(state, node) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;\n\n  var result = [];\n\n  switch (node.type.id) {\n    case 0:\n      // 0 is the id of the error node\n      if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type.id) === lezer_promql_1.OffsetExpr) {\n        // we are likely in the given situation:\n        // `metric_name offset 5` that leads to this tree:\n        // `Expr(OffsetExpr(Expr(VectorSelector(MetricIdentifier(Identifier))),Offset,⚠))`\n        // Here we can just autocomplete a duration.\n        result.push({\n          kind: ContextKind.Duration\n        });\n        break;\n      }\n\n      if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type.id) === lezer_promql_1.LabelMatcher) {\n        // In this case the current token is not itself a valid match op yet:\n        //      metric_name{labelName!}\n        result.push({\n          kind: ContextKind.MatchOp\n        });\n        break;\n      }\n\n      if (((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type.id) === lezer_promql_1.MatrixSelector) {\n        // we are likely in the given situation:\n        // `metric_name{}[5]`\n        // We can also just autocomplete a duration\n        result.push({\n          kind: ContextKind.Duration\n        });\n        break;\n      }\n\n      if (((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type.id) === lezer_promql_1.StepInvariantExpr) {\n        // we are likely in the given situation:\n        //   `expr @ s`\n        // we can autocomplete start / end\n        result.push({\n          kind: ContextKind.AtModifiers\n        });\n        break;\n      }\n\n      if (((_e = node.parent) === null || _e === void 0 ? void 0 : _e.type.id) === lezer_promql_1.SubqueryExpr && parser_1.containsAtLeastOneChild(node.parent, lezer_promql_1.Duration)) {\n        // we are likely in the given situation:\n        //    `rate(foo[5d:5])`\n        // so we should autocomplete a duration\n        result.push({\n          kind: ContextKind.Duration\n        });\n        break;\n      } // when we are in the situation 'metric_name !', we have the following tree\n      // Expr(VectorSelector(MetricIdentifier(Identifier),⚠))\n      // We should try to know if the char '!' is part of a binOp.\n      // Note: as it is quite experimental, maybe it requires more condition and to check the current tree (parent, other child at the same level ..etc.).\n\n\n      var operator_1 = state.sliceDoc(node.from, node.to);\n\n      if (promql_terms_1.binOpTerms.filter(function (term) {\n        return term.label.includes(operator_1);\n      }).length > 0) {\n        result.push({\n          kind: ContextKind.BinOp\n        });\n      }\n\n      break;\n\n    case lezer_promql_1.Identifier:\n      // sometimes an Identifier has an error has parent. This should be treated in priority\n      if (((_f = node.parent) === null || _f === void 0 ? void 0 : _f.type.id) === 0) {\n        if (((_g = node.parent.parent) === null || _g === void 0 ? void 0 : _g.type.id) === lezer_promql_1.AggregateExpr) {\n          // it matches 'sum() b'. So here we can autocomplete:\n          // - the aggregate operation modifier\n          // - the binary operation (since it's not mandatory to have an aggregate operation modifier)\n          result.push({\n            kind: ContextKind.AggregateOpModifier\n          }, {\n            kind: ContextKind.BinOp\n          });\n          break;\n        }\n\n        if (((_h = node.parent.parent) === null || _h === void 0 ? void 0 : _h.type.id) === lezer_promql_1.VectorSelector) {\n          // it matches 'sum b'. So here we also have to autocomplete the aggregate operation modifier only\n          // if the associated metricIdentifier is matching an aggregation operation.\n          // Note: here is the corresponding tree in order to understand the situation:\n          // Expr(\n          // \tVectorSelector(\n          // \t\tMetricIdentifier(Identifier),\n          // \t\t⚠(Identifier)\n          // \t)\n          // )\n          var operator_2 = getMetricNameInVectorSelector(node, state);\n\n          if (promql_terms_1.aggregateOpTerms.filter(function (term) {\n            return term.label === operator_2;\n          }).length > 0) {\n            result.push({\n              kind: ContextKind.AggregateOpModifier\n            });\n          } // It's possible it also match the expr 'metric_name unle'.\n          // It's also possible that the operator is also a metric even if it matches the list of aggregation function.\n          // So we also have to autocomplete the binary operator.\n          //\n          // The expr `metric_name off` leads to the same tree. So we have to provide the offset keyword too here.\n\n\n          result.push({\n            kind: ContextKind.BinOp\n          }, {\n            kind: ContextKind.Offset\n          });\n          break;\n        }\n      } // As the leaf Identifier is coming for a lot of different case, we have to take a bit time to analyze the tree\n      // in order to know what we have to autocomplete exactly.\n      // Here is some cases:\n      // 1. metric_name / ignor --> we should autocomplete the BinOpModifier + metric/function/aggregation\n      // 2. http_requests_total{method=\"GET\"} off --> offset or binOp should be autocompleted here\n      // 3. rate(foo[5m]) un --> offset or binOp should be autocompleted\n      // 4. sum(http_requests_total{method=\"GET\"} off) --> offset or binOp should be autocompleted\n      // 5. sum(http_requests_total{method=\"GET\"} / o) --> BinOpModifier + metric/function/aggregation\n      // All examples above gives a different tree each time but ends up to be treated in this case.\n      // But they all have the following common tree pattern:\n      // Parent( Expr(...),\n      //         ... ,\n      //         Expr(VectorSelector(MetricIdentifier(Identifier)))\n      //       )\n      //\n      // So the first things to do is to get the `Parent` and to determinate if we are in this configuration.\n      // Otherwise we would just have to autocomplete the metric / function / aggregation.\n\n\n      var parent_1 = (_l = (_k = (_j = node.parent) === null || _j === void 0 ? void 0 : _j.parent) === null || _k === void 0 ? void 0 : _k.parent) === null || _l === void 0 ? void 0 : _l.parent;\n\n      if (!parent_1) {\n        // this case is normally impossible since by definition, the identifier has 3 parents,\n        // and in Lexer, there is always a default parent in top of everything.\n        result.push({\n          kind: ContextKind.MetricName,\n          metricName: state.sliceDoc(node.from, node.to)\n        }, {\n          kind: ContextKind.Function\n        }, {\n          kind: ContextKind.Aggregation\n        });\n        break;\n      } // now we have to know if we have two Expr in the direct children of the `parent`\n\n\n      var containExprTwice = parser_1.containsChild(parent_1, lezer_promql_1.Expr, lezer_promql_1.Expr);\n\n      if (containExprTwice) {\n        if (parent_1.type.id === lezer_promql_1.BinaryExpr && !parser_1.containsAtLeastOneChild(parent_1, 0)) {\n          // We are likely in the case 1 or 5\n          result.push({\n            kind: ContextKind.MetricName,\n            metricName: state.sliceDoc(node.from, node.to)\n          }, {\n            kind: ContextKind.Function\n          }, {\n            kind: ContextKind.Aggregation\n          }, {\n            kind: ContextKind.BinOpModifier\n          }); // in  case the BinaryExpr is a comparison, we should autocomplete the `bool` keyword. But only if it is not present.\n          // When the `bool` keyword is NOT present, then the expression looks like this:\n          // \t\t\tBinaryExpr( Expr(...), Gtr , BinModifiers, Expr(...) )\n          // When the `bool` keyword is present, then the expression looks like this:\n          //      BinaryExpr( Expr(...), Gtr , BinModifiers(Bool), Expr(...) )\n          // To know if it is not present, we just have to check if the Bool is not present as a child of the BinModifiers.\n\n          if (parser_1.containsAtLeastOneChild(parent_1, lezer_promql_1.Eql, lezer_promql_1.Gte, lezer_promql_1.Gtr, lezer_promql_1.Lte, lezer_promql_1.Lss, lezer_promql_1.Neq) && !parser_1.walkThrough(parent_1, lezer_promql_1.BinModifiers, lezer_promql_1.Bool)) {\n            result.push({\n              kind: ContextKind.Bool\n            });\n          }\n        } else if (parent_1.type.id !== lezer_promql_1.BinaryExpr || parent_1.type.id === lezer_promql_1.BinaryExpr && parser_1.containsAtLeastOneChild(parent_1, 0)) {\n          result.push({\n            kind: ContextKind.BinOp\n          }, {\n            kind: ContextKind.Offset\n          });\n        }\n      } else {\n        result.push({\n          kind: ContextKind.MetricName,\n          metricName: state.sliceDoc(node.from, node.to)\n        }, {\n          kind: ContextKind.Function\n        }, {\n          kind: ContextKind.Aggregation\n        });\n      }\n\n      break;\n\n    case lezer_promql_1.PromQL:\n      if (!node.firstChild) {\n        // this situation can happen when there is nothing in the text area and the user is explicitly triggering the autocompletion (with ctrl + space)\n        result.push({\n          kind: ContextKind.MetricName,\n          metricName: ''\n        }, {\n          kind: ContextKind.Function\n        }, {\n          kind: ContextKind.Aggregation\n        });\n      }\n\n      break;\n\n    case lezer_promql_1.GroupingLabels:\n      // In this case we are in the given situation:\n      //      sum by ()\n      // So we have to autocomplete any labelName\n      result.push({\n        kind: ContextKind.LabelName\n      });\n      break;\n\n    case lezer_promql_1.LabelMatchers:\n      // In that case we are in the given situation:\n      //       metric_name{} or {}\n      // so we have or to autocomplete any kind of labelName or to autocomplete only the labelName associated to the metric\n      result.push({\n        kind: ContextKind.LabelName,\n        metricName: getMetricNameInVectorSelector(node, state)\n      });\n      break;\n\n    case lezer_promql_1.LabelName:\n      if (((_m = node.parent) === null || _m === void 0 ? void 0 : _m.type.id) === lezer_promql_1.GroupingLabel) {\n        // In this case we are in the given situation:\n        //      sum by (myL)\n        // So we have to continue to autocomplete any kind of labelName\n        result.push({\n          kind: ContextKind.LabelName\n        });\n      } else if (((_o = node.parent) === null || _o === void 0 ? void 0 : _o.type.id) === lezer_promql_1.LabelMatcher) {\n        // In that case we are in the given situation:\n        //       metric_name{myL} or {myL}\n        // so we have or to continue to autocomplete any kind of labelName or\n        // to continue to autocomplete only the labelName associated to the metric\n        result.push({\n          kind: ContextKind.LabelName,\n          metricName: getMetricNameInVectorSelector(node, state)\n        });\n      }\n\n      break;\n\n    case lezer_promql_1.StringLiteral:\n      if (((_p = node.parent) === null || _p === void 0 ? void 0 : _p.type.id) === lezer_promql_1.LabelMatcher) {\n        // In this case we are in the given situation:\n        //      metric_name{labelName=\"\"}\n        // So we can autocomplete the labelValue\n        // Get the labelName.\n        // By definition it's the firstChild: https://github.com/promlabs/lezer-promql/blob/0ef65e196a8db6a989ff3877d57fd0447d70e971/src/promql.grammar#L250\n        var labelName = '';\n\n        if (((_q = node.parent.firstChild) === null || _q === void 0 ? void 0 : _q.type.id) === lezer_promql_1.LabelName) {\n          labelName = state.sliceDoc(node.parent.firstChild.from, node.parent.firstChild.to);\n        } // then find the metricName if it exists\n\n\n        var metricName = getMetricNameInVectorSelector(node, state); // finally get the full matcher available\n\n        var labelMatchers = parser_1.buildLabelMatchers(parser_1.retrieveAllRecursiveNodes(parser_1.walkBackward(node, lezer_promql_1.LabelMatchList), lezer_promql_1.LabelMatchList, lezer_promql_1.LabelMatcher), state);\n        result.push({\n          kind: ContextKind.LabelValue,\n          metricName: metricName,\n          labelName: labelName,\n          matchers: labelMatchers\n        });\n      }\n\n      break;\n\n    case lezer_promql_1.NumberLiteral:\n      if (((_r = node.parent) === null || _r === void 0 ? void 0 : _r.type.id) === 0 && ((_s = node.parent.parent) === null || _s === void 0 ? void 0 : _s.type.id) === lezer_promql_1.SubqueryExpr) {\n        // Here we are likely in this situation:\n        //     `go[5d:4]`\n        // and we have the given tree:\n        // Expr( SubqueryExpr(\n        // \t\tExpr(VectorSelector(MetricIdentifier(Identifier))),\n        // \t\tDuration, Duration, ⚠(NumberLiteral)\n        // ))\n        // So we should continue to autocomplete a duration\n        result.push({\n          kind: ContextKind.Duration\n        });\n      }\n\n      break;\n\n    case lezer_promql_1.Duration:\n    case lezer_promql_1.OffsetExpr:\n      result.push({\n        kind: ContextKind.Duration\n      });\n      break;\n\n    case lezer_promql_1.FunctionCallBody:\n      // In this case we are in the given situation:\n      //       sum() or in rate()\n      // with the cursor between the bracket. So we can autocomplete the metric, the function and the aggregation.\n      result.push({\n        kind: ContextKind.MetricName,\n        metricName: ''\n      }, {\n        kind: ContextKind.Function\n      }, {\n        kind: ContextKind.Aggregation\n      });\n      break;\n\n    case lezer_promql_1.Neq:\n      if (((_t = node.parent) === null || _t === void 0 ? void 0 : _t.type.id) === lezer_promql_1.MatchOp) {\n        result.push({\n          kind: ContextKind.MatchOp\n        });\n      } else if (((_u = node.parent) === null || _u === void 0 ? void 0 : _u.type.id) === lezer_promql_1.BinaryExpr) {\n        result.push({\n          kind: ContextKind.BinOp\n        });\n      }\n\n      break;\n\n    case lezer_promql_1.EqlSingle:\n    case lezer_promql_1.EqlRegex:\n    case lezer_promql_1.NeqRegex:\n    case lezer_promql_1.MatchOp:\n      result.push({\n        kind: ContextKind.MatchOp\n      });\n      break;\n\n    case lezer_promql_1.Pow:\n    case lezer_promql_1.Mul:\n    case lezer_promql_1.Div:\n    case lezer_promql_1.Mod:\n    case lezer_promql_1.Add:\n    case lezer_promql_1.Sub:\n    case lezer_promql_1.Eql:\n    case lezer_promql_1.Gte:\n    case lezer_promql_1.Gtr:\n    case lezer_promql_1.Lte:\n    case lezer_promql_1.Lss:\n    case lezer_promql_1.And:\n    case lezer_promql_1.Unless:\n    case lezer_promql_1.Or:\n    case lezer_promql_1.BinaryExpr:\n      result.push({\n        kind: ContextKind.BinOp\n      });\n      break;\n  }\n\n  return result;\n}\n\nexports.analyzeCompletion = analyzeCompletion; // HybridComplete provides a full completion result with or without a remote prometheus.\n\nvar HybridComplete =\n/** @class */\nfunction () {\n  function HybridComplete(prometheusClient, maxMetricsMetadata) {\n    if (maxMetricsMetadata === void 0) {\n      maxMetricsMetadata = 10000;\n    }\n\n    this.prometheusClient = prometheusClient;\n    this.maxMetricsMetadata = maxMetricsMetadata;\n  }\n\n  HybridComplete.prototype.getPrometheusClient = function () {\n    return this.prometheusClient;\n  };\n\n  HybridComplete.prototype.promQL = function (context) {\n    var e_1, _a;\n\n    var _this = this;\n\n    var state = context.state,\n        pos = context.pos;\n    var tree = language_1.syntaxTree(state).resolve(pos, -1);\n    var contexts = analyzeCompletion(state, tree);\n    var asyncResult = Promise.resolve([]);\n    var completeSnippet = false;\n    var span = true;\n\n    var _loop_1 = function _loop_1(context_1) {\n      switch (context_1.kind) {\n        case ContextKind.Aggregation:\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat(autocompleteNodes.aggregateOp);\n          });\n          break;\n\n        case ContextKind.Function:\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat(autocompleteNodes.functionIdentifier);\n          });\n          break;\n\n        case ContextKind.BinOpModifier:\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat(autocompleteNodes.binOpModifier);\n          });\n          break;\n\n        case ContextKind.BinOp:\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat(autocompleteNodes.binOp);\n          });\n          break;\n\n        case ContextKind.MatchOp:\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat(autocompleteNodes.matchOp);\n          });\n          break;\n\n        case ContextKind.AggregateOpModifier:\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat(autocompleteNodes.aggregateOpModifier);\n          });\n          break;\n\n        case ContextKind.Duration:\n          span = false;\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat(autocompleteNodes.duration);\n          });\n          break;\n\n        case ContextKind.Offset:\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat([{\n              label: 'offset'\n            }]);\n          });\n          break;\n\n        case ContextKind.Bool:\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat([{\n              label: 'bool'\n            }]);\n          });\n          break;\n\n        case ContextKind.AtModifiers:\n          asyncResult = asyncResult.then(function (result) {\n            return result.concat(autocompleteNodes.atModifier);\n          });\n          break;\n\n        case ContextKind.MetricName:\n          asyncResult = asyncResult.then(function (result) {\n            completeSnippet = true;\n            return _this.autocompleteMetricName(result, context_1);\n          });\n          break;\n\n        case ContextKind.LabelName:\n          asyncResult = asyncResult.then(function (result) {\n            return _this.autocompleteLabelName(result, context_1);\n          });\n          break;\n\n        case ContextKind.LabelValue:\n          asyncResult = asyncResult.then(function (result) {\n            return _this.autocompleteLabelValue(result, context_1);\n          });\n      }\n    };\n\n    try {\n      for (var contexts_1 = __values(contexts), contexts_1_1 = contexts_1.next(); !contexts_1_1.done; contexts_1_1 = contexts_1.next()) {\n        var context_1 = contexts_1_1.value;\n\n        _loop_1(context_1);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (contexts_1_1 && !contexts_1_1.done && (_a = contexts_1.return)) _a.call(contexts_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return asyncResult.then(function (result) {\n      return arrayToCompletionResult(result, computeStartCompletePosition(tree, pos), pos, completeSnippet, span);\n    });\n  };\n\n  HybridComplete.prototype.autocompleteMetricName = function (result, context) {\n    var _this = this;\n\n    if (!this.prometheusClient) {\n      return result;\n    }\n\n    var metricCompletion = new Map();\n    return this.prometheusClient.metricNames(context.metricName).then(function (metricNames) {\n      var e_2, _a;\n\n      var _b;\n\n      try {\n        for (var metricNames_1 = __values(metricNames), metricNames_1_1 = metricNames_1.next(); !metricNames_1_1.done; metricNames_1_1 = metricNames_1.next()) {\n          var metricName = metricNames_1_1.value;\n          metricCompletion.set(metricName, {\n            label: metricName,\n            type: 'constant'\n          });\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (metricNames_1_1 && !metricNames_1_1.done && (_a = metricNames_1.return)) _a.call(metricNames_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      } // avoid to get all metric metadata if the prometheus server is too big\n\n\n      if (metricNames.length <= _this.maxMetricsMetadata) {\n        // in order to enrich the completion list of the metric,\n        // we are trying to find the associated metadata\n        return (_b = _this.prometheusClient) === null || _b === void 0 ? void 0 : _b.metricMetadata();\n      }\n    }).then(function (metricMetadata) {\n      var e_3, _a, e_4, _b;\n\n      if (metricMetadata) {\n        try {\n          for (var metricCompletion_1 = __values(metricCompletion), metricCompletion_1_1 = metricCompletion_1.next(); !metricCompletion_1_1.done; metricCompletion_1_1 = metricCompletion_1.next()) {\n            var _c = __read(metricCompletion_1_1.value, 2),\n                metricName = _c[0],\n                node = _c[1]; // For histograms and summaries, the metadata is only exposed for the base metric name,\n            // not separately for the _count, _sum, and _bucket time series.\n\n\n            var metadata = metricMetadata[metricName.replace(/(_count|_sum|_bucket)$/, '')];\n\n            if (metadata) {\n              if (metadata.length > 1) {\n                try {\n                  // it means the metricName has different possible helper and type\n                  for (var metadata_1 = (e_4 = void 0, __values(metadata)), metadata_1_1 = metadata_1.next(); !metadata_1_1.done; metadata_1_1 = metadata_1.next()) {\n                    var m = metadata_1_1.value;\n\n                    if (node.detail === '') {\n                      node.detail = m.type;\n                    } else if (node.detail !== m.type) {\n                      node.detail = 'unknown';\n                      node.info = 'multiple different definitions for this metric';\n                    }\n\n                    if (node.info === '') {\n                      node.info = m.help;\n                    } else if (node.info !== m.help) {\n                      node.info = 'multiple different definitions for this metric';\n                    }\n                  }\n                } catch (e_4_1) {\n                  e_4 = {\n                    error: e_4_1\n                  };\n                } finally {\n                  try {\n                    if (metadata_1_1 && !metadata_1_1.done && (_b = metadata_1.return)) _b.call(metadata_1);\n                  } finally {\n                    if (e_4) throw e_4.error;\n                  }\n                }\n              } else if (metadata.length === 1) {\n                var _d = metadata[0],\n                    type = _d.type,\n                    help = _d.help;\n\n                if (type === 'histogram' || type === 'summary') {\n                  if (metricName.endsWith('_count')) {\n                    type = 'counter';\n                    help = \"The total number of observations for: \" + help;\n                  }\n\n                  if (metricName.endsWith('_sum')) {\n                    type = 'counter';\n                    help = \"The total sum of observations for: \" + help;\n                  }\n\n                  if (metricName.endsWith('_bucket')) {\n                    type = 'counter';\n                    help = \"The total count of observations for a bucket in the histogram: \" + help;\n                  }\n                }\n\n                node.detail = type;\n                node.info = help;\n              }\n            }\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (metricCompletion_1_1 && !metricCompletion_1_1.done && (_a = metricCompletion_1.return)) _a.call(metricCompletion_1);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      }\n\n      return result.concat(Array.from(metricCompletion.values()));\n    });\n  };\n\n  HybridComplete.prototype.autocompleteLabelName = function (result, context) {\n    if (!this.prometheusClient) {\n      return result;\n    }\n\n    return this.prometheusClient.labelNames(context.metricName).then(function (labelNames) {\n      return result.concat(labelNames.map(function (value) {\n        return {\n          label: value,\n          type: 'constant'\n        };\n      }));\n    });\n  };\n\n  HybridComplete.prototype.autocompleteLabelValue = function (result, context) {\n    if (!this.prometheusClient || !context.labelName) {\n      return result;\n    }\n\n    return this.prometheusClient.labelValues(context.labelName, context.metricName, context.matchers).then(function (labelValues) {\n      return result.concat(labelValues.map(function (value) {\n        return {\n          label: value,\n          type: 'text'\n        };\n      }));\n    });\n  };\n\n  return HybridComplete;\n}();\n\nexports.HybridComplete = HybridComplete;","map":{"version":3,"sources":["../../../src/lang-promql/complete/hybrid.ts"],"names":[],"mappings":"cAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,IAAA,cAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AA8CA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAYA,IAAA,UAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AAEA,IAAM,iBAAiB,GAAoC;AACzD,EAAA,OAAO,EAAE,cAAA,CAAA,YADgD;AAEzD,EAAA,KAAK,EAAE,cAAA,CAAA,UAFkD;AAGzD,EAAA,QAAQ,EAAE,cAAA,CAAA,aAH+C;AAIzD,EAAA,aAAa,EAAE,cAAA,CAAA,kBAJ0C;AAKzD,EAAA,UAAU,EAAE,cAAA,CAAA,eAL6C;AAMzD,EAAA,kBAAkB,EAAE,cAAA,CAAA,uBANqC;AAOzD,EAAA,WAAW,EAAE,cAAA,CAAA,gBAP4C;AAQzD,EAAA,mBAAmB,EAAE,cAAA,CAAA;AARoC,CAA3D,C,CAWA;;AACA,IAAY,WAAZ;;AAAA,CAAA,UAAY,WAAZ,EAAuB;AACrB;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA,CAJqB,CAKrB;;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,eAAA,CAAA,GAAA,CAAA,CAAA,GAAA,eAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,qBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,qBAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,aAAA,CAAA,GAAA,EAAA,CAAA,GAAA,aAAA;AACD,CAhBD,EAAY,WAAW,GAAX,OAAA,CAAA,WAAA,KAAA,OAAA,CAAA,WAAA,GAAW,EAAX,CAAZ;;AAyBA,SAAS,6BAAT,CAAuC,IAAvC,EAAyD,KAAzD,EAA2E;AACzE;AACA;AACA,MAAI,WAAW,GAAsB,QAAA,CAAA,YAAA,CAAa,IAAb,EAAmB,cAAA,CAAA,cAAnB,CAArC;;AACA,MAAI,CAAC,WAAL,EAAkB;AAChB;AACA,WAAO,EAAP;AACD;;AACD,EAAA,WAAW,GAAG,QAAA,CAAA,WAAA,CAAY,WAAZ,EAAyB,cAAA,CAAA,gBAAzB,EAA2C,cAAA,CAAA,UAA3C,CAAd;;AACA,MAAI,CAAC,WAAL,EAAkB;AAChB,WAAO,EAAP;AACD;;AACD,SAAO,KAAK,CAAC,QAAN,CAAe,WAAW,CAAC,IAA3B,EAAiC,WAAW,CAAC,EAA7C,CAAP;AACD;;AAED,SAAS,uBAAT,CAAiC,IAAjC,EAAqD,IAArD,EAAmE,EAAnE,EAA+E,cAA/E,EAAuG,IAAvG,EAAkH;AAAnC,MAAA,cAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,cAAA,GAAA,KAAA;AAAsB;;AAAE,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,IAAA,GAAA,IAAA;AAAW;;AAChH,MAAM,OAAO,GAAG,IAAhB;;AACA,MAAI,cAAJ,EAAoB;AAClB,IAAA,OAAO,CAAC,IAAR,CAAY,KAAZ,CAAA,OAAA,EAAO,aAAA,CAAA,EAAA,EAAA,MAAA,CAAS,cAAA,CAAA,QAAT,CAAA,CAAP;AACD;;AACD,SAAO;AACL,IAAA,IAAI,EAAE,IADD;AAEL,IAAA,EAAE,EAAE,EAFC;AAGL,IAAA,OAAO,EAAE,OAHJ;AAIL,IAAA,IAAI,EAAE,IAAI,GAAG,kBAAH,GAAwB;AAJ7B,GAAP;AAMD,C,CAED;;;AACA,SAAS,gEAAT,CAA0E,IAA1E,EAA4F,GAA5F,EAAuG;AACrG;AACA;AACA;AACA;AACA;AACA,MAAI,KAAK,GAAG,IAAI,CAAC,IAAL,GAAY,CAAxB;;AACA,MAAI,IAAI,CAAC,UAAL,KAAoB,IAAxB,EAA8B;AAC5B;AACA,IAAA,KAAK,GAAG,GAAR;AACD;;AACD,SAAO,KAAP;AACD,C,CAED;AACA;AACA;AACA;;;AACA,SAAgB,4BAAhB,CAA6C,IAA7C,EAA+D,GAA/D,EAA0E;;;AACxE,MAAI,KAAK,GAAG,IAAI,CAAC,IAAjB;;AACA,MAAI,IAAI,CAAC,IAAL,CAAU,EAAV,KAAiB,cAAA,CAAA,aAAjB,IAAkC,IAAI,CAAC,IAAL,CAAU,EAAV,KAAiB,cAAA,CAAA,cAAvD,EAAuE;AACrE,IAAA,KAAK,GAAG,gEAAgE,CAAC,IAAD,EAAO,GAAP,CAAxE;AACD,GAFD,MAEO,IAAI,IAAI,CAAC,IAAL,CAAU,EAAV,KAAiB,cAAA,CAAA,gBAAjB,IAAsC,IAAI,CAAC,IAAL,CAAU,EAAV,KAAiB,cAAA,CAAA,aAAjB,IAAkC,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,YAArG,EAAoH;AACzH;AACA,IAAA,KAAK;AACN,GAHM,MAGA,IACL,IAAI,CAAC,IAAL,CAAU,EAAV,KAAiB,cAAA,CAAA,UAAjB,IACC,IAAI,CAAC,IAAL,CAAU,EAAV,KAAiB,cAAA,CAAA,aAAjB,IAAkC,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,CAA3D,IAAgE,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,CAAY,MAAZ,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAE,IAAF,CAAO,EAAzB,MAAgC,cAAA,CAAA,YADjG,IAEC,IAAI,CAAC,IAAL,CAAU,EAAV,KAAiB,CAAjB,KACE,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,UAAzB,IACC,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,cAD1B,IAEE,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,YAAzB,IAAyC,QAAA,CAAA,uBAAA,CAAwB,IAAI,CAAC,MAA7B,EAAqC,cAAA,CAAA,QAArC,CAH7C,CAHI,EAOL;AACA,IAAA,KAAK,GAAG,GAAR;AACD;;AACD,SAAO,KAAP;AACD;;AAlBD,OAAA,CAAA,4BAAA,GAAA,4BAAA,C,CAoBA;AACA;AACA;;AACA,SAAgB,iBAAhB,CAAkC,KAAlC,EAAsD,IAAtD,EAAsE;;;AACpE,MAAM,MAAM,GAAc,EAA1B;;AACA,UAAQ,IAAI,CAAC,IAAL,CAAU,EAAlB;AACE,SAAK,CAAL;AAAQ;AACN,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,UAA7B,EAAyC;AACvC;AACA;AACA;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACA;AACD;;AACD,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,YAA7B,EAA2C;AACzC;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACA;AACD;;AACD,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,cAA7B,EAA6C;AAC3C;AACA;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACA;AACD;;AACD,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,iBAA7B,EAAgD;AAC9C;AACA;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACA;AACD;;AACD,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,YAAzB,IAAyC,QAAA,CAAA,uBAAA,CAAwB,IAAI,CAAC,MAA7B,EAAqC,cAAA,CAAA,QAArC,CAA7C,EAA6F;AAC3F;AACA;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACA;AACD,OAnCH,CAoCE;AACA;AACA;AACA;;;AACA,UAAM,UAAQ,GAAG,KAAK,CAAC,QAAN,CAAe,IAAI,CAAC,IAApB,EAA0B,IAAI,CAAC,EAA/B,CAAjB;;AACA,UAAI,cAAA,CAAA,UAAA,CAAW,MAAX,CAAkB,UAAC,IAAD,EAAK;AAAK,eAAA,IAAI,CAAC,KAAL,CAAW,QAAX,CAAA,UAAA,CAAA;AAA6B,OAAzD,EAA2D,MAA3D,GAAoE,CAAxE,EAA2E;AACzE,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACD;;AACD;;AACF,SAAK,cAAA,CAAA,UAAL;AACE;AACA,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,CAA7B,EAAgC;AAC9B,YAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,CAAY,MAAZ,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAE,IAAF,CAAO,EAAzB,MAAgC,cAAA,CAAA,aAApC,EAAmD;AACjD;AACA;AACA;AACA,UAAA,MAAM,CAAC,IAAP,CAAY;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC;AAApB,WAAZ,EAAuD;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC;AAApB,WAAvD;AACA;AACD;;AACD,YAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,CAAY,MAAZ,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAE,IAAF,CAAO,EAAzB,MAAgC,cAAA,CAAA,cAApC,EAAoD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM,UAAQ,GAAG,6BAA6B,CAAC,IAAD,EAAO,KAAP,CAA9C;;AACA,cAAI,cAAA,CAAA,gBAAA,CAAiB,MAAjB,CAAwB,UAAC,IAAD,EAAK;AAAK,mBAAA,IAAI,CAAC,KAAL,KAAA,UAAA;AAAuB,WAAzD,EAA2D,MAA3D,GAAoE,CAAxE,EAA2E;AACzE,YAAA,MAAM,CAAC,IAAP,CAAY;AAAE,cAAA,IAAI,EAAE,WAAW,CAAC;AAApB,aAAZ;AACD,WAbiD,CAclD;AACA;AACA;AACA;AACA;;;AACA,UAAA,MAAM,CAAC,IAAP,CAAY;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC;AAApB,WAAZ,EAAyC;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC;AAApB,WAAzC;AACA;AACD;AACF,OAhCH,CAiCE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,UAAM,QAAM,GAAG,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,MAAb,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,KAAA,CAAnB,GAAmB,EAAA,CAAE,MAArB,MAA2B,IAA3B,IAA2B,EAAA,KAAA,KAAA,CAA3B,GAA2B,KAAA,CAA3B,GAA2B,EAAA,CAAE,MAA5C;;AACA,UAAI,CAAC,QAAL,EAAa;AACX;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CACE;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC,UAApB;AAAgC,UAAA,UAAU,EAAE,KAAK,CAAC,QAAN,CAAe,IAAI,CAAC,IAApB,EAA0B,IAAI,CAAC,EAA/B;AAA5C,SADF,EAEE;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAFF,EAGE;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAHF;AAKA;AACD,OA7DH,CA8DE;;;AACA,UAAM,gBAAgB,GAAG,QAAA,CAAA,aAAA,CAAc,QAAd,EAAsB,cAAA,CAAA,IAAtB,EAA4B,cAAA,CAAA,IAA5B,CAAzB;;AACA,UAAI,gBAAJ,EAAsB;AACpB,YAAI,QAAM,CAAC,IAAP,CAAY,EAAZ,KAAmB,cAAA,CAAA,UAAnB,IAAiC,CAAC,QAAA,CAAA,uBAAA,CAAwB,QAAxB,EAAgC,CAAhC,CAAtC,EAA0E;AACxE;AACA,UAAA,MAAM,CAAC,IAAP,CACE;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC,UAApB;AAAgC,YAAA,UAAU,EAAE,KAAK,CAAC,QAAN,CAAe,IAAI,CAAC,IAApB,EAA0B,IAAI,CAAC,EAA/B;AAA5C,WADF,EAEE;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC;AAApB,WAFF,EAGE;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC;AAApB,WAHF,EAIE;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC;AAApB,WAJF,EAFwE,CAQxE;AACA;AACA;AACA;AACA;AACA;;AACA,cAAI,QAAA,CAAA,uBAAA,CAAwB,QAAxB,EAAgC,cAAA,CAAA,GAAhC,EAAqC,cAAA,CAAA,GAArC,EAA0C,cAAA,CAAA,GAA1C,EAA+C,cAAA,CAAA,GAA/C,EAAoD,cAAA,CAAA,GAApD,EAAyD,cAAA,CAAA,GAAzD,KAAiE,CAAC,QAAA,CAAA,WAAA,CAAY,QAAZ,EAAoB,cAAA,CAAA,YAApB,EAAkC,cAAA,CAAA,IAAlC,CAAtE,EAA+G;AAC7G,YAAA,MAAM,CAAC,IAAP,CAAY;AAAE,cAAA,IAAI,EAAE,WAAW,CAAC;AAApB,aAAZ;AACD;AACF,SAjBD,MAiBO,IAAI,QAAM,CAAC,IAAP,CAAY,EAAZ,KAAmB,cAAA,CAAA,UAAnB,IAAkC,QAAM,CAAC,IAAP,CAAY,EAAZ,KAAmB,cAAA,CAAA,UAAnB,IAAiC,QAAA,CAAA,uBAAA,CAAwB,QAAxB,EAAgC,CAAhC,CAAvE,EAA4G;AACjH,UAAA,MAAM,CAAC,IAAP,CAAY;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC;AAApB,WAAZ,EAAyC;AAAE,YAAA,IAAI,EAAE,WAAW,CAAC;AAApB,WAAzC;AACD;AACF,OArBD,MAqBO;AACL,QAAA,MAAM,CAAC,IAAP,CACE;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC,UAApB;AAAgC,UAAA,UAAU,EAAE,KAAK,CAAC,QAAN,CAAe,IAAI,CAAC,IAApB,EAA0B,IAAI,CAAC,EAA/B;AAA5C,SADF,EAEE;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAFF,EAGE;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAHF;AAKD;;AACD;;AACF,SAAK,cAAA,CAAA,MAAL;AACE,UAAI,CAAC,IAAI,CAAC,UAAV,EAAsB;AACpB;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC,UAApB;AAAgC,UAAA,UAAU,EAAE;AAA5C,SAAZ,EAA8D;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAA9D,EAA8F;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAA9F;AACD;;AACD;;AACF,SAAK,cAAA,CAAA,cAAL;AACE;AACA;AACA;AACA,MAAA,MAAM,CAAC,IAAP,CAAY;AAAE,QAAA,IAAI,EAAE,WAAW,CAAC;AAApB,OAAZ;AACA;;AACF,SAAK,cAAA,CAAA,aAAL;AACE;AACA;AACA;AACA,MAAA,MAAM,CAAC,IAAP,CAAY;AAAE,QAAA,IAAI,EAAE,WAAW,CAAC,SAApB;AAA+B,QAAA,UAAU,EAAE,6BAA6B,CAAC,IAAD,EAAO,KAAP;AAAxE,OAAZ;AACA;;AACF,SAAK,cAAA,CAAA,SAAL;AACE,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,aAA7B,EAA4C;AAC1C;AACA;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACD,OALD,MAKO,IAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,YAA7B,EAA2C;AAChD;AACA;AACA;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC,SAApB;AAA+B,UAAA,UAAU,EAAE,6BAA6B,CAAC,IAAD,EAAO,KAAP;AAAxE,SAAZ;AACD;;AACD;;AACF,SAAK,cAAA,CAAA,aAAL;AACE,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,YAA7B,EAA2C;AACzC;AACA;AACA;AAEA;AACA;AACA,YAAI,SAAS,GAAG,EAAhB;;AACA,YAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,CAAY,UAAZ,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAE,IAAF,CAAO,EAA7B,MAAoC,cAAA,CAAA,SAAxC,EAAmD;AACjD,UAAA,SAAS,GAAG,KAAK,CAAC,QAAN,CAAe,IAAI,CAAC,MAAL,CAAY,UAAZ,CAAuB,IAAtC,EAA4C,IAAI,CAAC,MAAL,CAAY,UAAZ,CAAuB,EAAnE,CAAZ;AACD,SAVwC,CAWzC;;;AACA,YAAM,UAAU,GAAG,6BAA6B,CAAC,IAAD,EAAO,KAAP,CAAhD,CAZyC,CAazC;;AACA,YAAM,aAAa,GAAG,QAAA,CAAA,kBAAA,CAAmB,QAAA,CAAA,yBAAA,CAA0B,QAAA,CAAA,YAAA,CAAa,IAAb,EAAmB,cAAA,CAAA,cAAnB,CAA1B,EAA8D,cAAA,CAAA,cAA9D,EAA8E,cAAA,CAAA,YAA9E,CAAnB,EAAgH,KAAhH,CAAtB;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC,UAApB;AAAgC,UAAA,UAAU,EAAE,UAA5C;AAAwD,UAAA,SAAS,EAAE,SAAnE;AAA8E,UAAA,QAAQ,EAAE;AAAxF,SAAZ;AACD;;AACD;;AACF,SAAK,cAAA,CAAA,aAAL;AACE,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,CAAzB,IAA8B,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,CAAY,MAAZ,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAE,IAAF,CAAO,EAAzB,MAAgC,cAAA,CAAA,YAAlE,EAAgF;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACD;;AACD;;AACF,SAAK,cAAA,CAAA,QAAL;AACA,SAAK,cAAA,CAAA,UAAL;AACE,MAAA,MAAM,CAAC,IAAP,CAAY;AAAE,QAAA,IAAI,EAAE,WAAW,CAAC;AAApB,OAAZ;AACA;;AACF,SAAK,cAAA,CAAA,gBAAL;AACE;AACA;AACA;AACA,MAAA,MAAM,CAAC,IAAP,CAAY;AAAE,QAAA,IAAI,EAAE,WAAW,CAAC,UAApB;AAAgC,QAAA,UAAU,EAAE;AAA5C,OAAZ,EAA8D;AAAE,QAAA,IAAI,EAAE,WAAW,CAAC;AAApB,OAA9D,EAA8F;AAAE,QAAA,IAAI,EAAE,WAAW,CAAC;AAApB,OAA9F;AACA;;AACF,SAAK,cAAA,CAAA,GAAL;AACE,UAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,OAA7B,EAAsC;AACpC,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACD,OAFD,MAEO,IAAI,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,MAAL,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,IAAF,CAAO,EAAlB,MAAyB,cAAA,CAAA,UAA7B,EAAyC;AAC9C,QAAA,MAAM,CAAC,IAAP,CAAY;AAAE,UAAA,IAAI,EAAE,WAAW,CAAC;AAApB,SAAZ;AACD;;AACD;;AACF,SAAK,cAAA,CAAA,SAAL;AACA,SAAK,cAAA,CAAA,QAAL;AACA,SAAK,cAAA,CAAA,QAAL;AACA,SAAK,cAAA,CAAA,OAAL;AACE,MAAA,MAAM,CAAC,IAAP,CAAY;AAAE,QAAA,IAAI,EAAE,WAAW,CAAC;AAApB,OAAZ;AACA;;AACF,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,GAAL;AACA,SAAK,cAAA,CAAA,MAAL;AACA,SAAK,cAAA,CAAA,EAAL;AACA,SAAK,cAAA,CAAA,UAAL;AACE,MAAA,MAAM,CAAC,IAAP,CAAY;AAAE,QAAA,IAAI,EAAE,WAAW,CAAC;AAApB,OAAZ;AACA;AAlPJ;;AAoPA,SAAO,MAAP;AACD;;AAvPD,OAAA,CAAA,iBAAA,GAAA,iBAAA,C,CAyPA;;AACA,IAAA,cAAA;AAAA;AAAA,YAAA;AAIE,WAAA,cAAA,CAAY,gBAAZ,EAAiD,kBAAjD,EAA2E;AAA1B,QAAA,kBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,kBAAA,GAAA,KAAA;AAA0B;;AACzE,SAAK,gBAAL,GAAwB,gBAAxB;AACA,SAAK,kBAAL,GAA0B,kBAA1B;AACD;;AAED,EAAA,cAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,YAAA;AACE,WAAO,KAAK,gBAAZ;AACD,GAFD;;AAIA,EAAA,cAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,OAAP,EAAiC;;;AAAjC,QAAA,KAAA,GAAA,IAAA;;AACU,QAAA,KAAK,GAAU,OAAO,CAAjB,KAAL;AAAA,QAAO,GAAG,GAAK,OAAO,CAAZ,GAAV;AACR,QAAM,IAAI,GAAG,UAAA,CAAA,UAAA,CAAW,KAAX,EAAkB,OAAlB,CAA0B,GAA1B,EAA+B,CAAC,CAAhC,CAAb;AACA,QAAM,QAAQ,GAAG,iBAAiB,CAAC,KAAD,EAAQ,IAAR,CAAlC;AACA,QAAI,WAAW,GAA0B,OAAO,CAAC,OAAR,CAAgB,EAAhB,CAAzC;AACA,QAAI,eAAe,GAAG,KAAtB;AACA,QAAI,IAAI,GAAG,IAAX;;mCACW,S,EAAO;AAChB,cAAQ,SAAO,CAAC,IAAhB;AACE,aAAK,WAAW,CAAC,WAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,iBAAiB,CAAC,WAAhC,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,QAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,iBAAiB,CAAC,kBAAhC,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,aAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,iBAAiB,CAAC,aAAhC,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,KAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,iBAAiB,CAAC,KAAhC,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,OAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,iBAAiB,CAAC,OAAhC,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,mBAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,iBAAiB,CAAC,mBAAhC,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,QAAjB;AACE,UAAA,IAAI,GAAG,KAAP;AACA,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,iBAAiB,CAAC,QAAhC,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,MAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,CAAC;AAAE,cAAA,KAAK,EAAE;AAAT,aAAD,CAAd,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,IAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,CAAC;AAAE,cAAA,KAAK,EAAE;AAAT,aAAD,CAAd,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,WAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,MAAM,CAAC,MAAP,CAAc,iBAAiB,CAAC,UAAhC,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,UAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,YAAA,eAAe,GAAG,IAAlB;AACA,mBAAO,KAAI,CAAC,sBAAL,CAA4B,MAA5B,EAAoC,SAApC,CAAP;AACD,WAHa,CAAd;AAIA;;AACF,aAAK,WAAW,CAAC,SAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,KAAI,CAAC,qBAAL,CAA2B,MAA3B,EAAmC,SAAnC,CAAP;AACD,WAFa,CAAd;AAGA;;AACF,aAAK,WAAW,CAAC,UAAjB;AACE,UAAA,WAAW,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AACpC,mBAAO,KAAI,CAAC,sBAAL,CAA4B,MAA5B,EAAoC,SAApC,CAAP;AACD,WAFa,CAAd;AAhEJ;;;;AADF,WAAsB,IAAA,UAAA,GAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAA8B,CAAA,YAAA,CAAA,IAA9B,EAA8B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAA8B;AAAzB,YAAM,SAAO,GAAA,YAAA,CAAA,KAAb;;gBAAM,S;AAqEV;;;;;;;;;;;;;AACD,WAAO,WAAW,CAAC,IAAZ,CAAiB,UAAC,MAAD,EAAO;AAC7B,aAAO,uBAAuB,CAAC,MAAD,EAAS,4BAA4B,CAAC,IAAD,EAAO,GAAP,CAArC,EAAkD,GAAlD,EAAuD,eAAvD,EAAwE,IAAxE,CAA9B;AACD,KAFM,CAAP;AAGD,GAhFD;;AAkFQ,EAAA,cAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UAA+B,MAA/B,EAAqD,OAArD,EAAqE;AAArE,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,CAAC,KAAK,gBAAV,EAA4B;AAC1B,aAAO,MAAP;AACD;;AACD,QAAM,gBAAgB,GAAG,IAAI,GAAJ,EAAzB;AACA,WAAO,KAAK,gBAAL,CACJ,WADI,CACQ,OAAO,CAAC,UADhB,EAEJ,IAFI,CAEC,UAAC,WAAD,EAAsB;;;;;;AAC1B,aAAyB,IAAA,aAAA,GAAA,QAAA,CAAA,WAAA,CAAA,EAAW,eAAA,GAAA,aAAA,CAAA,IAAA,EAApC,EAAoC,CAAA,eAAA,CAAA,IAApC,EAAoC,eAAA,GAAA,aAAA,CAAA,IAAA,EAApC,EAAsC;AAAjC,cAAM,UAAU,GAAA,eAAA,CAAA,KAAhB;AACH,UAAA,gBAAgB,CAAC,GAAjB,CAAqB,UAArB,EAAiC;AAAE,YAAA,KAAK,EAAE,UAAT;AAAqB,YAAA,IAAI,EAAE;AAA3B,WAAjC;AACD;;;;;;;;;;;OAHyB,CAK1B;;;AACA,UAAI,WAAW,CAAC,MAAZ,IAAsB,KAAI,CAAC,kBAA/B,EAAmD;AACjD;AACA;AACA,eAAO,CAAA,EAAA,GAAA,KAAI,CAAC,gBAAL,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,KAAA,CAArB,GAAqB,EAAA,CAAE,cAAF,EAA5B;AACD;AACF,KAbI,EAcJ,IAdI,CAcC,UAAC,cAAD,EAAe;;;AACnB,UAAI,cAAJ,EAAoB;;AAClB,eAAiC,IAAA,kBAAA,GAAA,QAAA,CAAA,gBAAA,CAAA,EAAgB,oBAAA,GAAA,kBAAA,CAAA,IAAA,EAAjD,EAAiD,CAAA,oBAAA,CAAA,IAAjD,EAAiD,oBAAA,GAAA,kBAAA,CAAA,IAAA,EAAjD,EAAmD;AAAxC,gBAAA,EAAA,GAAA,MAAA,CAAA,oBAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,gBAAC,UAAU,GAAA,EAAA,CAAA,CAAA,CAAX;AAAA,gBAAa,IAAI,GAAA,EAAA,CAAA,CAAA,CAAjB,CAAwC,CACjD;AACA;;;AACA,gBAAM,QAAQ,GAAG,cAAc,CAAC,UAAU,CAAC,OAAX,CAAmB,wBAAnB,EAA6C,EAA7C,CAAD,CAA/B;;AACA,gBAAI,QAAJ,EAAc;AACZ,kBAAI,QAAQ,CAAC,MAAT,GAAkB,CAAtB,EAAyB;;AACvB;AACA,uBAAgB,IAAA,UAAA,IAAA,GAAA,GAAA,KAAA,CAAA,EAAA,QAAA,CAAA,QAAA,CAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAAxB,EAAwB,CAAA,YAAA,CAAA,IAAxB,EAAwB,YAAA,GAAA,UAAA,CAAA,IAAA,EAAxB,EAA0B;AAArB,wBAAM,CAAC,GAAA,YAAA,CAAA,KAAP;;AACH,wBAAI,IAAI,CAAC,MAAL,KAAgB,EAApB,EAAwB;AACtB,sBAAA,IAAI,CAAC,MAAL,GAAc,CAAC,CAAC,IAAhB;AACD,qBAFD,MAEO,IAAI,IAAI,CAAC,MAAL,KAAgB,CAAC,CAAC,IAAtB,EAA4B;AACjC,sBAAA,IAAI,CAAC,MAAL,GAAc,SAAd;AACA,sBAAA,IAAI,CAAC,IAAL,GAAY,gDAAZ;AACD;;AAED,wBAAI,IAAI,CAAC,IAAL,KAAc,EAAlB,EAAsB;AACpB,sBAAA,IAAI,CAAC,IAAL,GAAY,CAAC,CAAC,IAAd;AACD,qBAFD,MAEO,IAAI,IAAI,CAAC,IAAL,KAAc,CAAC,CAAC,IAApB,EAA0B;AAC/B,sBAAA,IAAI,CAAC,IAAL,GAAY,gDAAZ;AACD;AACF;;;;;;;;;;;;AACF,eAhBD,MAgBO,IAAI,QAAQ,CAAC,MAAT,KAAoB,CAAxB,EAA2B;AAC5B,oBAAA,EAAA,GAAiB,QAAQ,CAAC,CAAD,CAAzB;AAAA,oBAAE,IAAI,GAAA,EAAA,CAAA,IAAN;AAAA,oBAAQ,IAAI,GAAA,EAAA,CAAA,IAAZ;;AACJ,oBAAI,IAAI,KAAK,WAAT,IAAwB,IAAI,KAAK,SAArC,EAAgD;AAC9C,sBAAI,UAAU,CAAC,QAAX,CAAoB,QAApB,CAAJ,EAAmC;AACjC,oBAAA,IAAI,GAAG,SAAP;AACA,oBAAA,IAAI,GAAG,2CAAyC,IAAhD;AACD;;AACD,sBAAI,UAAU,CAAC,QAAX,CAAoB,MAApB,CAAJ,EAAiC;AAC/B,oBAAA,IAAI,GAAG,SAAP;AACA,oBAAA,IAAI,GAAG,wCAAsC,IAA7C;AACD;;AACD,sBAAI,UAAU,CAAC,QAAX,CAAoB,SAApB,CAAJ,EAAoC;AAClC,oBAAA,IAAI,GAAG,SAAP;AACA,oBAAA,IAAI,GAAG,oEAAkE,IAAzE;AACD;AACF;;AACD,gBAAA,IAAI,CAAC,MAAL,GAAc,IAAd;AACA,gBAAA,IAAI,CAAC,IAAL,GAAY,IAAZ;AACD;AACF;AACF;;;;;;;;;;;;AACF;;AACD,aAAO,MAAM,CAAC,MAAP,CAAc,KAAK,CAAC,IAAN,CAAW,gBAAgB,CAAC,MAAjB,EAAX,CAAd,CAAP;AACD,KA5DI,CAAP;AA6DD,GAlEO;;AAoEA,EAAA,cAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,UAA8B,MAA9B,EAAoD,OAApD,EAAoE;AAClE,QAAI,CAAC,KAAK,gBAAV,EAA4B;AAC1B,aAAO,MAAP;AACD;;AACD,WAAO,KAAK,gBAAL,CAAsB,UAAtB,CAAiC,OAAO,CAAC,UAAzC,EAAqD,IAArD,CAA0D,UAAC,UAAD,EAAqB;AACpF,aAAO,MAAM,CAAC,MAAP,CAAc,UAAU,CAAC,GAAX,CAAe,UAAC,KAAD,EAAM;AAAK,eAAC;AAAE,UAAA,KAAK,EAAE,KAAT;AAAgB,UAAA,IAAI,EAArB;AAAC,SAAD;AAAoC,OAA9D,CAAd,CAAP;AACD,KAFM,CAAP;AAGD,GAPO;;AASA,EAAA,cAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UAA+B,MAA/B,EAAqD,OAArD,EAAqE;AACnE,QAAI,CAAC,KAAK,gBAAN,IAA0B,CAAC,OAAO,CAAC,SAAvC,EAAkD;AAChD,aAAO,MAAP;AACD;;AACD,WAAO,KAAK,gBAAL,CAAsB,WAAtB,CAAkC,OAAO,CAAC,SAA1C,EAAqD,OAAO,CAAC,UAA7D,EAAyE,OAAO,CAAC,QAAjF,EAA2F,IAA3F,CAAgG,UAAC,WAAD,EAAsB;AAC3H,aAAO,MAAM,CAAC,MAAP,CAAc,WAAW,CAAC,GAAZ,CAAgB,UAAC,KAAD,EAAM;AAAK,eAAC;AAAE,UAAA,KAAK,EAAE,KAAT;AAAgB,UAAA,IAAI,EAArB;AAAC,SAAD;AAAgC,OAA3D,CAAd,CAAP;AACD,KAFM,CAAP;AAGD,GAPO;;AAQV,SAAA,cAAA;AAAC,CApLD,EAAA;;AAAa,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HybridComplete = exports.analyzeCompletion = exports.computeStartCompletePosition = exports.ContextKind = void 0;\nvar lezer_promql_1 = require(\"lezer-promql\");\nvar parser_1 = require(\"../parser\");\nvar promql_terms_1 = require(\"./promql.terms\");\nvar language_1 = require(\"@codemirror/language\");\nvar autocompleteNodes = {\n    matchOp: promql_terms_1.matchOpTerms,\n    binOp: promql_terms_1.binOpTerms,\n    duration: promql_terms_1.durationTerms,\n    binOpModifier: promql_terms_1.binOpModifierTerms,\n    atModifier: promql_terms_1.atModifierTerms,\n    functionIdentifier: promql_terms_1.functionIdentifierTerms,\n    aggregateOp: promql_terms_1.aggregateOpTerms,\n    aggregateOpModifier: promql_terms_1.aggregateOpModifierTerms,\n};\n// ContextKind is the different possible value determinate by the autocompletion\nvar ContextKind;\n(function (ContextKind) {\n    // dynamic autocompletion (required a distant server)\n    ContextKind[ContextKind[\"MetricName\"] = 0] = \"MetricName\";\n    ContextKind[ContextKind[\"LabelName\"] = 1] = \"LabelName\";\n    ContextKind[ContextKind[\"LabelValue\"] = 2] = \"LabelValue\";\n    // static autocompletion\n    ContextKind[ContextKind[\"Function\"] = 3] = \"Function\";\n    ContextKind[ContextKind[\"Aggregation\"] = 4] = \"Aggregation\";\n    ContextKind[ContextKind[\"BinOpModifier\"] = 5] = \"BinOpModifier\";\n    ContextKind[ContextKind[\"BinOp\"] = 6] = \"BinOp\";\n    ContextKind[ContextKind[\"MatchOp\"] = 7] = \"MatchOp\";\n    ContextKind[ContextKind[\"AggregateOpModifier\"] = 8] = \"AggregateOpModifier\";\n    ContextKind[ContextKind[\"Duration\"] = 9] = \"Duration\";\n    ContextKind[ContextKind[\"Offset\"] = 10] = \"Offset\";\n    ContextKind[ContextKind[\"Bool\"] = 11] = \"Bool\";\n    ContextKind[ContextKind[\"AtModifiers\"] = 12] = \"AtModifiers\";\n})(ContextKind = exports.ContextKind || (exports.ContextKind = {}));\nfunction getMetricNameInVectorSelector(tree, state) {\n    // Find if there is a defined metric name. Should be used to autocomplete a labelValue or a labelName\n    // First find the parent \"VectorSelector\" to be able to find then the subChild \"MetricIdentifier\" if it exists.\n    var currentNode = parser_1.walkBackward(tree, lezer_promql_1.VectorSelector);\n    if (!currentNode) {\n        // Weird case that shouldn't happen, because \"VectorSelector\" is by definition the parent of the LabelMatchers.\n        return '';\n    }\n    currentNode = parser_1.walkThrough(currentNode, lezer_promql_1.MetricIdentifier, lezer_promql_1.Identifier);\n    if (!currentNode) {\n        return '';\n    }\n    return state.sliceDoc(currentNode.from, currentNode.to);\n}\nfunction arrayToCompletionResult(data, from, to, includeSnippet, span) {\n    if (includeSnippet === void 0) { includeSnippet = false; }\n    if (span === void 0) { span = true; }\n    var options = data;\n    if (includeSnippet) {\n        options.push.apply(options, __spreadArray([], __read(promql_terms_1.snippets)));\n    }\n    return {\n        from: from,\n        to: to,\n        options: options,\n        span: span ? /^[a-zA-Z0-9_:]+$/ : undefined,\n    };\n}\n// computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel calculates the start position only when the node is a LabelMatchers or a GroupingLabels\nfunction computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel(node, pos) {\n    // Here we can have two different situations:\n    // 1. `metric{}` or `sum by()` with the cursor between the bracket\n    // and so we have increment the starting position to avoid to consider the open bracket when filtering the autocompletion list.\n    // 2. `metric{foo=\"bar\",} or `sum by(foo,)  with the cursor after the comma.\n    // Then the start number should be the current position to avoid to consider the previous labelMatcher/groupingLabel when filtering the autocompletion list.\n    var start = node.from + 1;\n    if (node.firstChild !== null) {\n        // here that means the LabelMatchers / GroupingLabels has a child, which is not possible if we have the expression `metric{}`. So we are likely trying to autocomplete the label list after a comma\n        start = pos;\n    }\n    return start;\n}\n// computeStartCompletePosition calculates the start position of the autocompletion.\n// It is an important step because the start position will be used by CMN to find the string and then to use it to filter the CompletionResult.\n// A wrong `start` position will lead to have the completion not working.\n// Note: this method is exported only for testing purpose.\nfunction computeStartCompletePosition(node, pos) {\n    var _a, _b, _c, _d, _e, _f;\n    var start = node.from;\n    if (node.type.id === lezer_promql_1.LabelMatchers || node.type.id === lezer_promql_1.GroupingLabels) {\n        start = computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel(node, pos);\n    }\n    else if (node.type.id === lezer_promql_1.FunctionCallBody || (node.type.id === lezer_promql_1.StringLiteral && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type.id) === lezer_promql_1.LabelMatcher)) {\n        // When the cursor is between bracket, quote, we need to increment the starting position to avoid to consider the open bracket/ first string.\n        start++;\n    }\n    else if (node.type.id === lezer_promql_1.OffsetExpr ||\n        (node.type.id === lezer_promql_1.NumberLiteral && ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type.id) === 0 && ((_c = node.parent.parent) === null || _c === void 0 ? void 0 : _c.type.id) === lezer_promql_1.SubqueryExpr) ||\n        (node.type.id === 0 &&\n            (((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type.id) === lezer_promql_1.OffsetExpr ||\n                ((_e = node.parent) === null || _e === void 0 ? void 0 : _e.type.id) === lezer_promql_1.MatrixSelector ||\n                (((_f = node.parent) === null || _f === void 0 ? void 0 : _f.type.id) === lezer_promql_1.SubqueryExpr && parser_1.containsAtLeastOneChild(node.parent, lezer_promql_1.Duration))))) {\n        start = pos;\n    }\n    return start;\n}\nexports.computeStartCompletePosition = computeStartCompletePosition;\n// analyzeCompletion is going to determinate what should be autocompleted.\n// The value of the autocompletion is then calculate by the function buildCompletion.\n// Note: this method is exported for testing purpose only. Do not use it directly.\nfunction analyzeCompletion(state, node) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;\n    var result = [];\n    switch (node.type.id) {\n        case 0: // 0 is the id of the error node\n            if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type.id) === lezer_promql_1.OffsetExpr) {\n                // we are likely in the given situation:\n                // `metric_name offset 5` that leads to this tree:\n                // `Expr(OffsetExpr(Expr(VectorSelector(MetricIdentifier(Identifier))),Offset,⚠))`\n                // Here we can just autocomplete a duration.\n                result.push({ kind: ContextKind.Duration });\n                break;\n            }\n            if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type.id) === lezer_promql_1.LabelMatcher) {\n                // In this case the current token is not itself a valid match op yet:\n                //      metric_name{labelName!}\n                result.push({ kind: ContextKind.MatchOp });\n                break;\n            }\n            if (((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type.id) === lezer_promql_1.MatrixSelector) {\n                // we are likely in the given situation:\n                // `metric_name{}[5]`\n                // We can also just autocomplete a duration\n                result.push({ kind: ContextKind.Duration });\n                break;\n            }\n            if (((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type.id) === lezer_promql_1.StepInvariantExpr) {\n                // we are likely in the given situation:\n                //   `expr @ s`\n                // we can autocomplete start / end\n                result.push({ kind: ContextKind.AtModifiers });\n                break;\n            }\n            if (((_e = node.parent) === null || _e === void 0 ? void 0 : _e.type.id) === lezer_promql_1.SubqueryExpr && parser_1.containsAtLeastOneChild(node.parent, lezer_promql_1.Duration)) {\n                // we are likely in the given situation:\n                //    `rate(foo[5d:5])`\n                // so we should autocomplete a duration\n                result.push({ kind: ContextKind.Duration });\n                break;\n            }\n            // when we are in the situation 'metric_name !', we have the following tree\n            // Expr(VectorSelector(MetricIdentifier(Identifier),⚠))\n            // We should try to know if the char '!' is part of a binOp.\n            // Note: as it is quite experimental, maybe it requires more condition and to check the current tree (parent, other child at the same level ..etc.).\n            var operator_1 = state.sliceDoc(node.from, node.to);\n            if (promql_terms_1.binOpTerms.filter(function (term) { return term.label.includes(operator_1); }).length > 0) {\n                result.push({ kind: ContextKind.BinOp });\n            }\n            break;\n        case lezer_promql_1.Identifier:\n            // sometimes an Identifier has an error has parent. This should be treated in priority\n            if (((_f = node.parent) === null || _f === void 0 ? void 0 : _f.type.id) === 0) {\n                if (((_g = node.parent.parent) === null || _g === void 0 ? void 0 : _g.type.id) === lezer_promql_1.AggregateExpr) {\n                    // it matches 'sum() b'. So here we can autocomplete:\n                    // - the aggregate operation modifier\n                    // - the binary operation (since it's not mandatory to have an aggregate operation modifier)\n                    result.push({ kind: ContextKind.AggregateOpModifier }, { kind: ContextKind.BinOp });\n                    break;\n                }\n                if (((_h = node.parent.parent) === null || _h === void 0 ? void 0 : _h.type.id) === lezer_promql_1.VectorSelector) {\n                    // it matches 'sum b'. So here we also have to autocomplete the aggregate operation modifier only\n                    // if the associated metricIdentifier is matching an aggregation operation.\n                    // Note: here is the corresponding tree in order to understand the situation:\n                    // Expr(\n                    // \tVectorSelector(\n                    // \t\tMetricIdentifier(Identifier),\n                    // \t\t⚠(Identifier)\n                    // \t)\n                    // )\n                    var operator_2 = getMetricNameInVectorSelector(node, state);\n                    if (promql_terms_1.aggregateOpTerms.filter(function (term) { return term.label === operator_2; }).length > 0) {\n                        result.push({ kind: ContextKind.AggregateOpModifier });\n                    }\n                    // It's possible it also match the expr 'metric_name unle'.\n                    // It's also possible that the operator is also a metric even if it matches the list of aggregation function.\n                    // So we also have to autocomplete the binary operator.\n                    //\n                    // The expr `metric_name off` leads to the same tree. So we have to provide the offset keyword too here.\n                    result.push({ kind: ContextKind.BinOp }, { kind: ContextKind.Offset });\n                    break;\n                }\n            }\n            // As the leaf Identifier is coming for a lot of different case, we have to take a bit time to analyze the tree\n            // in order to know what we have to autocomplete exactly.\n            // Here is some cases:\n            // 1. metric_name / ignor --> we should autocomplete the BinOpModifier + metric/function/aggregation\n            // 2. http_requests_total{method=\"GET\"} off --> offset or binOp should be autocompleted here\n            // 3. rate(foo[5m]) un --> offset or binOp should be autocompleted\n            // 4. sum(http_requests_total{method=\"GET\"} off) --> offset or binOp should be autocompleted\n            // 5. sum(http_requests_total{method=\"GET\"} / o) --> BinOpModifier + metric/function/aggregation\n            // All examples above gives a different tree each time but ends up to be treated in this case.\n            // But they all have the following common tree pattern:\n            // Parent( Expr(...),\n            //         ... ,\n            //         Expr(VectorSelector(MetricIdentifier(Identifier)))\n            //       )\n            //\n            // So the first things to do is to get the `Parent` and to determinate if we are in this configuration.\n            // Otherwise we would just have to autocomplete the metric / function / aggregation.\n            var parent_1 = (_l = (_k = (_j = node.parent) === null || _j === void 0 ? void 0 : _j.parent) === null || _k === void 0 ? void 0 : _k.parent) === null || _l === void 0 ? void 0 : _l.parent;\n            if (!parent_1) {\n                // this case is normally impossible since by definition, the identifier has 3 parents,\n                // and in Lexer, there is always a default parent in top of everything.\n                result.push({ kind: ContextKind.MetricName, metricName: state.sliceDoc(node.from, node.to) }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation });\n                break;\n            }\n            // now we have to know if we have two Expr in the direct children of the `parent`\n            var containExprTwice = parser_1.containsChild(parent_1, lezer_promql_1.Expr, lezer_promql_1.Expr);\n            if (containExprTwice) {\n                if (parent_1.type.id === lezer_promql_1.BinaryExpr && !parser_1.containsAtLeastOneChild(parent_1, 0)) {\n                    // We are likely in the case 1 or 5\n                    result.push({ kind: ContextKind.MetricName, metricName: state.sliceDoc(node.from, node.to) }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation }, { kind: ContextKind.BinOpModifier });\n                    // in  case the BinaryExpr is a comparison, we should autocomplete the `bool` keyword. But only if it is not present.\n                    // When the `bool` keyword is NOT present, then the expression looks like this:\n                    // \t\t\tBinaryExpr( Expr(...), Gtr , BinModifiers, Expr(...) )\n                    // When the `bool` keyword is present, then the expression looks like this:\n                    //      BinaryExpr( Expr(...), Gtr , BinModifiers(Bool), Expr(...) )\n                    // To know if it is not present, we just have to check if the Bool is not present as a child of the BinModifiers.\n                    if (parser_1.containsAtLeastOneChild(parent_1, lezer_promql_1.Eql, lezer_promql_1.Gte, lezer_promql_1.Gtr, lezer_promql_1.Lte, lezer_promql_1.Lss, lezer_promql_1.Neq) && !parser_1.walkThrough(parent_1, lezer_promql_1.BinModifiers, lezer_promql_1.Bool)) {\n                        result.push({ kind: ContextKind.Bool });\n                    }\n                }\n                else if (parent_1.type.id !== lezer_promql_1.BinaryExpr || (parent_1.type.id === lezer_promql_1.BinaryExpr && parser_1.containsAtLeastOneChild(parent_1, 0))) {\n                    result.push({ kind: ContextKind.BinOp }, { kind: ContextKind.Offset });\n                }\n            }\n            else {\n                result.push({ kind: ContextKind.MetricName, metricName: state.sliceDoc(node.from, node.to) }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation });\n            }\n            break;\n        case lezer_promql_1.PromQL:\n            if (!node.firstChild) {\n                // this situation can happen when there is nothing in the text area and the user is explicitly triggering the autocompletion (with ctrl + space)\n                result.push({ kind: ContextKind.MetricName, metricName: '' }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation });\n            }\n            break;\n        case lezer_promql_1.GroupingLabels:\n            // In this case we are in the given situation:\n            //      sum by ()\n            // So we have to autocomplete any labelName\n            result.push({ kind: ContextKind.LabelName });\n            break;\n        case lezer_promql_1.LabelMatchers:\n            // In that case we are in the given situation:\n            //       metric_name{} or {}\n            // so we have or to autocomplete any kind of labelName or to autocomplete only the labelName associated to the metric\n            result.push({ kind: ContextKind.LabelName, metricName: getMetricNameInVectorSelector(node, state) });\n            break;\n        case lezer_promql_1.LabelName:\n            if (((_m = node.parent) === null || _m === void 0 ? void 0 : _m.type.id) === lezer_promql_1.GroupingLabel) {\n                // In this case we are in the given situation:\n                //      sum by (myL)\n                // So we have to continue to autocomplete any kind of labelName\n                result.push({ kind: ContextKind.LabelName });\n            }\n            else if (((_o = node.parent) === null || _o === void 0 ? void 0 : _o.type.id) === lezer_promql_1.LabelMatcher) {\n                // In that case we are in the given situation:\n                //       metric_name{myL} or {myL}\n                // so we have or to continue to autocomplete any kind of labelName or\n                // to continue to autocomplete only the labelName associated to the metric\n                result.push({ kind: ContextKind.LabelName, metricName: getMetricNameInVectorSelector(node, state) });\n            }\n            break;\n        case lezer_promql_1.StringLiteral:\n            if (((_p = node.parent) === null || _p === void 0 ? void 0 : _p.type.id) === lezer_promql_1.LabelMatcher) {\n                // In this case we are in the given situation:\n                //      metric_name{labelName=\"\"}\n                // So we can autocomplete the labelValue\n                // Get the labelName.\n                // By definition it's the firstChild: https://github.com/promlabs/lezer-promql/blob/0ef65e196a8db6a989ff3877d57fd0447d70e971/src/promql.grammar#L250\n                var labelName = '';\n                if (((_q = node.parent.firstChild) === null || _q === void 0 ? void 0 : _q.type.id) === lezer_promql_1.LabelName) {\n                    labelName = state.sliceDoc(node.parent.firstChild.from, node.parent.firstChild.to);\n                }\n                // then find the metricName if it exists\n                var metricName = getMetricNameInVectorSelector(node, state);\n                // finally get the full matcher available\n                var labelMatchers = parser_1.buildLabelMatchers(parser_1.retrieveAllRecursiveNodes(parser_1.walkBackward(node, lezer_promql_1.LabelMatchList), lezer_promql_1.LabelMatchList, lezer_promql_1.LabelMatcher), state);\n                result.push({ kind: ContextKind.LabelValue, metricName: metricName, labelName: labelName, matchers: labelMatchers });\n            }\n            break;\n        case lezer_promql_1.NumberLiteral:\n            if (((_r = node.parent) === null || _r === void 0 ? void 0 : _r.type.id) === 0 && ((_s = node.parent.parent) === null || _s === void 0 ? void 0 : _s.type.id) === lezer_promql_1.SubqueryExpr) {\n                // Here we are likely in this situation:\n                //     `go[5d:4]`\n                // and we have the given tree:\n                // Expr( SubqueryExpr(\n                // \t\tExpr(VectorSelector(MetricIdentifier(Identifier))),\n                // \t\tDuration, Duration, ⚠(NumberLiteral)\n                // ))\n                // So we should continue to autocomplete a duration\n                result.push({ kind: ContextKind.Duration });\n            }\n            break;\n        case lezer_promql_1.Duration:\n        case lezer_promql_1.OffsetExpr:\n            result.push({ kind: ContextKind.Duration });\n            break;\n        case lezer_promql_1.FunctionCallBody:\n            // In this case we are in the given situation:\n            //       sum() or in rate()\n            // with the cursor between the bracket. So we can autocomplete the metric, the function and the aggregation.\n            result.push({ kind: ContextKind.MetricName, metricName: '' }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation });\n            break;\n        case lezer_promql_1.Neq:\n            if (((_t = node.parent) === null || _t === void 0 ? void 0 : _t.type.id) === lezer_promql_1.MatchOp) {\n                result.push({ kind: ContextKind.MatchOp });\n            }\n            else if (((_u = node.parent) === null || _u === void 0 ? void 0 : _u.type.id) === lezer_promql_1.BinaryExpr) {\n                result.push({ kind: ContextKind.BinOp });\n            }\n            break;\n        case lezer_promql_1.EqlSingle:\n        case lezer_promql_1.EqlRegex:\n        case lezer_promql_1.NeqRegex:\n        case lezer_promql_1.MatchOp:\n            result.push({ kind: ContextKind.MatchOp });\n            break;\n        case lezer_promql_1.Pow:\n        case lezer_promql_1.Mul:\n        case lezer_promql_1.Div:\n        case lezer_promql_1.Mod:\n        case lezer_promql_1.Add:\n        case lezer_promql_1.Sub:\n        case lezer_promql_1.Eql:\n        case lezer_promql_1.Gte:\n        case lezer_promql_1.Gtr:\n        case lezer_promql_1.Lte:\n        case lezer_promql_1.Lss:\n        case lezer_promql_1.And:\n        case lezer_promql_1.Unless:\n        case lezer_promql_1.Or:\n        case lezer_promql_1.BinaryExpr:\n            result.push({ kind: ContextKind.BinOp });\n            break;\n    }\n    return result;\n}\nexports.analyzeCompletion = analyzeCompletion;\n// HybridComplete provides a full completion result with or without a remote prometheus.\nvar HybridComplete = /** @class */ (function () {\n    function HybridComplete(prometheusClient, maxMetricsMetadata) {\n        if (maxMetricsMetadata === void 0) { maxMetricsMetadata = 10000; }\n        this.prometheusClient = prometheusClient;\n        this.maxMetricsMetadata = maxMetricsMetadata;\n    }\n    HybridComplete.prototype.getPrometheusClient = function () {\n        return this.prometheusClient;\n    };\n    HybridComplete.prototype.promQL = function (context) {\n        var e_1, _a;\n        var _this = this;\n        var state = context.state, pos = context.pos;\n        var tree = language_1.syntaxTree(state).resolve(pos, -1);\n        var contexts = analyzeCompletion(state, tree);\n        var asyncResult = Promise.resolve([]);\n        var completeSnippet = false;\n        var span = true;\n        var _loop_1 = function (context_1) {\n            switch (context_1.kind) {\n                case ContextKind.Aggregation:\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat(autocompleteNodes.aggregateOp);\n                    });\n                    break;\n                case ContextKind.Function:\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat(autocompleteNodes.functionIdentifier);\n                    });\n                    break;\n                case ContextKind.BinOpModifier:\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat(autocompleteNodes.binOpModifier);\n                    });\n                    break;\n                case ContextKind.BinOp:\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat(autocompleteNodes.binOp);\n                    });\n                    break;\n                case ContextKind.MatchOp:\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat(autocompleteNodes.matchOp);\n                    });\n                    break;\n                case ContextKind.AggregateOpModifier:\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat(autocompleteNodes.aggregateOpModifier);\n                    });\n                    break;\n                case ContextKind.Duration:\n                    span = false;\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat(autocompleteNodes.duration);\n                    });\n                    break;\n                case ContextKind.Offset:\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat([{ label: 'offset' }]);\n                    });\n                    break;\n                case ContextKind.Bool:\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat([{ label: 'bool' }]);\n                    });\n                    break;\n                case ContextKind.AtModifiers:\n                    asyncResult = asyncResult.then(function (result) {\n                        return result.concat(autocompleteNodes.atModifier);\n                    });\n                    break;\n                case ContextKind.MetricName:\n                    asyncResult = asyncResult.then(function (result) {\n                        completeSnippet = true;\n                        return _this.autocompleteMetricName(result, context_1);\n                    });\n                    break;\n                case ContextKind.LabelName:\n                    asyncResult = asyncResult.then(function (result) {\n                        return _this.autocompleteLabelName(result, context_1);\n                    });\n                    break;\n                case ContextKind.LabelValue:\n                    asyncResult = asyncResult.then(function (result) {\n                        return _this.autocompleteLabelValue(result, context_1);\n                    });\n            }\n        };\n        try {\n            for (var contexts_1 = __values(contexts), contexts_1_1 = contexts_1.next(); !contexts_1_1.done; contexts_1_1 = contexts_1.next()) {\n                var context_1 = contexts_1_1.value;\n                _loop_1(context_1);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (contexts_1_1 && !contexts_1_1.done && (_a = contexts_1.return)) _a.call(contexts_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return asyncResult.then(function (result) {\n            return arrayToCompletionResult(result, computeStartCompletePosition(tree, pos), pos, completeSnippet, span);\n        });\n    };\n    HybridComplete.prototype.autocompleteMetricName = function (result, context) {\n        var _this = this;\n        if (!this.prometheusClient) {\n            return result;\n        }\n        var metricCompletion = new Map();\n        return this.prometheusClient\n            .metricNames(context.metricName)\n            .then(function (metricNames) {\n            var e_2, _a;\n            var _b;\n            try {\n                for (var metricNames_1 = __values(metricNames), metricNames_1_1 = metricNames_1.next(); !metricNames_1_1.done; metricNames_1_1 = metricNames_1.next()) {\n                    var metricName = metricNames_1_1.value;\n                    metricCompletion.set(metricName, { label: metricName, type: 'constant' });\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (metricNames_1_1 && !metricNames_1_1.done && (_a = metricNames_1.return)) _a.call(metricNames_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            // avoid to get all metric metadata if the prometheus server is too big\n            if (metricNames.length <= _this.maxMetricsMetadata) {\n                // in order to enrich the completion list of the metric,\n                // we are trying to find the associated metadata\n                return (_b = _this.prometheusClient) === null || _b === void 0 ? void 0 : _b.metricMetadata();\n            }\n        })\n            .then(function (metricMetadata) {\n            var e_3, _a, e_4, _b;\n            if (metricMetadata) {\n                try {\n                    for (var metricCompletion_1 = __values(metricCompletion), metricCompletion_1_1 = metricCompletion_1.next(); !metricCompletion_1_1.done; metricCompletion_1_1 = metricCompletion_1.next()) {\n                        var _c = __read(metricCompletion_1_1.value, 2), metricName = _c[0], node = _c[1];\n                        // For histograms and summaries, the metadata is only exposed for the base metric name,\n                        // not separately for the _count, _sum, and _bucket time series.\n                        var metadata = metricMetadata[metricName.replace(/(_count|_sum|_bucket)$/, '')];\n                        if (metadata) {\n                            if (metadata.length > 1) {\n                                try {\n                                    // it means the metricName has different possible helper and type\n                                    for (var metadata_1 = (e_4 = void 0, __values(metadata)), metadata_1_1 = metadata_1.next(); !metadata_1_1.done; metadata_1_1 = metadata_1.next()) {\n                                        var m = metadata_1_1.value;\n                                        if (node.detail === '') {\n                                            node.detail = m.type;\n                                        }\n                                        else if (node.detail !== m.type) {\n                                            node.detail = 'unknown';\n                                            node.info = 'multiple different definitions for this metric';\n                                        }\n                                        if (node.info === '') {\n                                            node.info = m.help;\n                                        }\n                                        else if (node.info !== m.help) {\n                                            node.info = 'multiple different definitions for this metric';\n                                        }\n                                    }\n                                }\n                                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                                finally {\n                                    try {\n                                        if (metadata_1_1 && !metadata_1_1.done && (_b = metadata_1.return)) _b.call(metadata_1);\n                                    }\n                                    finally { if (e_4) throw e_4.error; }\n                                }\n                            }\n                            else if (metadata.length === 1) {\n                                var _d = metadata[0], type = _d.type, help = _d.help;\n                                if (type === 'histogram' || type === 'summary') {\n                                    if (metricName.endsWith('_count')) {\n                                        type = 'counter';\n                                        help = \"The total number of observations for: \" + help;\n                                    }\n                                    if (metricName.endsWith('_sum')) {\n                                        type = 'counter';\n                                        help = \"The total sum of observations for: \" + help;\n                                    }\n                                    if (metricName.endsWith('_bucket')) {\n                                        type = 'counter';\n                                        help = \"The total count of observations for a bucket in the histogram: \" + help;\n                                    }\n                                }\n                                node.detail = type;\n                                node.info = help;\n                            }\n                        }\n                    }\n                }\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                finally {\n                    try {\n                        if (metricCompletion_1_1 && !metricCompletion_1_1.done && (_a = metricCompletion_1.return)) _a.call(metricCompletion_1);\n                    }\n                    finally { if (e_3) throw e_3.error; }\n                }\n            }\n            return result.concat(Array.from(metricCompletion.values()));\n        });\n    };\n    HybridComplete.prototype.autocompleteLabelName = function (result, context) {\n        if (!this.prometheusClient) {\n            return result;\n        }\n        return this.prometheusClient.labelNames(context.metricName).then(function (labelNames) {\n            return result.concat(labelNames.map(function (value) { return ({ label: value, type: 'constant' }); }));\n        });\n    };\n    HybridComplete.prototype.autocompleteLabelValue = function (result, context) {\n        if (!this.prometheusClient || !context.labelName) {\n            return result;\n        }\n        return this.prometheusClient.labelValues(context.labelName, context.metricName, context.matchers).then(function (labelValues) {\n            return result.concat(labelValues.map(function (value) { return ({ label: value, type: 'text' }); }));\n        });\n    };\n    return HybridComplete;\n}());\nexports.HybridComplete = HybridComplete;\n//# sourceMappingURL=hybrid.js.map"]},"metadata":{},"sourceType":"script"}