{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildVectorMatching = void 0;\n\nvar lezer_promql_1 = require(\"lezer-promql\");\n\nvar types_1 = require(\"../types\");\n\nvar path_finder_1 = require(\"./path-finder\");\n\nfunction buildVectorMatching(state, binaryNode) {\n  var e_1, _a, e_2, _b;\n\n  if (!binaryNode || binaryNode.type.id !== lezer_promql_1.BinaryExpr) {\n    return null;\n  }\n\n  var result = {\n    card: types_1.VectorMatchCardinality.CardOneToOne,\n    matchingLabels: [],\n    on: false,\n    include: []\n  };\n  var binModifiers = binaryNode.getChild(lezer_promql_1.BinModifiers);\n\n  if (binModifiers) {\n    var onOrIgnoring = binModifiers.getChild(lezer_promql_1.OnOrIgnoring);\n\n    if (onOrIgnoring) {\n      result.on = onOrIgnoring.getChild(lezer_promql_1.On) !== null;\n      var labels = path_finder_1.retrieveAllRecursiveNodes(onOrIgnoring.getChild(lezer_promql_1.GroupingLabels), lezer_promql_1.GroupingLabelList, lezer_promql_1.GroupingLabel);\n\n      if (labels.length > 0) {\n        try {\n          for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {\n            var label = labels_1_1.value;\n            result.matchingLabels.push(state.sliceDoc(label.from, label.to));\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n    }\n\n    var groupLeft = binModifiers.getChild(lezer_promql_1.GroupLeft);\n    var groupRight = binModifiers.getChild(lezer_promql_1.GroupRight);\n\n    if (groupLeft || groupRight) {\n      result.card = groupLeft ? types_1.VectorMatchCardinality.CardManyToOne : types_1.VectorMatchCardinality.CardOneToMany;\n      var includeLabels = path_finder_1.retrieveAllRecursiveNodes(binModifiers.getChild(lezer_promql_1.GroupingLabels), lezer_promql_1.GroupingLabelList, lezer_promql_1.GroupingLabel);\n\n      if (includeLabels.length > 0) {\n        try {\n          for (var includeLabels_1 = __values(includeLabels), includeLabels_1_1 = includeLabels_1.next(); !includeLabels_1_1.done; includeLabels_1_1 = includeLabels_1.next()) {\n            var label = includeLabels_1_1.value;\n            result.include.push(state.sliceDoc(label.from, label.to));\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (includeLabels_1_1 && !includeLabels_1_1.done && (_b = includeLabels_1.return)) _b.call(includeLabels_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    }\n  }\n\n  var isSetOperator = path_finder_1.containsAtLeastOneChild(binaryNode, lezer_promql_1.And, lezer_promql_1.Or, lezer_promql_1.Unless);\n\n  if (isSetOperator && result.card === types_1.VectorMatchCardinality.CardOneToOne) {\n    result.card = types_1.VectorMatchCardinality.CardManyToMany;\n  }\n\n  return result;\n}\n\nexports.buildVectorMatching = buildVectorMatching;","map":{"version":3,"sources":["../../../src/lang-promql/parser/vector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildVectorMatching = void 0;\nvar lezer_promql_1 = require(\"lezer-promql\");\nvar types_1 = require(\"../types\");\nvar path_finder_1 = require(\"./path-finder\");\nfunction buildVectorMatching(state, binaryNode) {\n    var e_1, _a, e_2, _b;\n    if (!binaryNode || binaryNode.type.id !== lezer_promql_1.BinaryExpr) {\n        return null;\n    }\n    var result = {\n        card: types_1.VectorMatchCardinality.CardOneToOne,\n        matchingLabels: [],\n        on: false,\n        include: [],\n    };\n    var binModifiers = binaryNode.getChild(lezer_promql_1.BinModifiers);\n    if (binModifiers) {\n        var onOrIgnoring = binModifiers.getChild(lezer_promql_1.OnOrIgnoring);\n        if (onOrIgnoring) {\n            result.on = onOrIgnoring.getChild(lezer_promql_1.On) !== null;\n            var labels = path_finder_1.retrieveAllRecursiveNodes(onOrIgnoring.getChild(lezer_promql_1.GroupingLabels), lezer_promql_1.GroupingLabelList, lezer_promql_1.GroupingLabel);\n            if (labels.length > 0) {\n                try {\n                    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {\n                        var label = labels_1_1.value;\n                        result.matchingLabels.push(state.sliceDoc(label.from, label.to));\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        }\n        var groupLeft = binModifiers.getChild(lezer_promql_1.GroupLeft);\n        var groupRight = binModifiers.getChild(lezer_promql_1.GroupRight);\n        if (groupLeft || groupRight) {\n            result.card = groupLeft ? types_1.VectorMatchCardinality.CardManyToOne : types_1.VectorMatchCardinality.CardOneToMany;\n            var includeLabels = path_finder_1.retrieveAllRecursiveNodes(binModifiers.getChild(lezer_promql_1.GroupingLabels), lezer_promql_1.GroupingLabelList, lezer_promql_1.GroupingLabel);\n            if (includeLabels.length > 0) {\n                try {\n                    for (var includeLabels_1 = __values(includeLabels), includeLabels_1_1 = includeLabels_1.next(); !includeLabels_1_1.done; includeLabels_1_1 = includeLabels_1.next()) {\n                        var label = includeLabels_1_1.value;\n                        result.include.push(state.sliceDoc(label.from, label.to));\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (includeLabels_1_1 && !includeLabels_1_1.done && (_b = includeLabels_1.return)) _b.call(includeLabels_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n    }\n    var isSetOperator = path_finder_1.containsAtLeastOneChild(binaryNode, lezer_promql_1.And, lezer_promql_1.Or, lezer_promql_1.Unless);\n    if (isSetOperator && result.card === types_1.VectorMatchCardinality.CardOneToOne) {\n        result.card = types_1.VectorMatchCardinality.CardManyToMany;\n    }\n    return result;\n}\nexports.buildVectorMatching = buildVectorMatching;\n//# sourceMappingURL=vector.js.map"]},"metadata":{},"sourceType":"script"}