{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getType = void 0;\n\nvar lezer_promql_1 = require(\"lezer-promql\");\n\nvar path_finder_1 = require(\"./path-finder\");\n\nvar types_1 = require(\"../types\"); // Based on https://github.com/prometheus/prometheus/blob/d668a7efe3107dbdcc67bf4e9f12430ed8e2b396/promql/parser/ast.go#L191\n\n\nfunction getType(node) {\n  var _a;\n\n  if (!node) {\n    return types_1.ValueType.none;\n  }\n\n  switch (node.type.id) {\n    case lezer_promql_1.Expr:\n      return getType(node.firstChild);\n\n    case lezer_promql_1.AggregateExpr:\n      return types_1.ValueType.vector;\n\n    case lezer_promql_1.VectorSelector:\n      return types_1.ValueType.vector;\n\n    case lezer_promql_1.OffsetExpr:\n      return getType(node.firstChild);\n\n    case lezer_promql_1.StringLiteral:\n      return types_1.ValueType.string;\n\n    case lezer_promql_1.NumberLiteral:\n      return types_1.ValueType.scalar;\n\n    case lezer_promql_1.MatrixSelector:\n      return types_1.ValueType.matrix;\n\n    case lezer_promql_1.SubqueryExpr:\n      return types_1.ValueType.matrix;\n\n    case lezer_promql_1.ParenExpr:\n      return getType(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n\n    case lezer_promql_1.UnaryExpr:\n      return getType(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n\n    case lezer_promql_1.BinaryExpr:\n      var lt = getType(node.firstChild);\n      var rt = getType(node.lastChild);\n\n      if (lt === types_1.ValueType.scalar && rt === types_1.ValueType.scalar) {\n        return types_1.ValueType.scalar;\n      }\n\n      return types_1.ValueType.vector;\n\n    case lezer_promql_1.FunctionCall:\n      var funcNode = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n\n      if (!funcNode) {\n        return types_1.ValueType.none;\n      }\n\n      return types_1.getFunction(funcNode.type.id).returnType;\n\n    case lezer_promql_1.StepInvariantExpr:\n      return getType(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n\n    default:\n      return types_1.ValueType.none;\n  }\n}\n\nexports.getType = getType;","map":{"version":3,"sources":["../../../src/lang-promql/parser/type.ts"],"names":[],"mappings":"cAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGA,IAAA,cAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAeA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA,C,CAEA;;;AACA,SAAgB,OAAhB,CAAwB,IAAxB,EAA+C;;;AAC7C,MAAI,CAAC,IAAL,EAAW;AACT,WAAO,OAAA,CAAA,SAAA,CAAU,IAAjB;AACD;;AACD,UAAQ,IAAI,CAAC,IAAL,CAAU,EAAlB;AACE,SAAK,cAAA,CAAA,IAAL;AACE,aAAO,OAAO,CAAC,IAAI,CAAC,UAAN,CAAd;;AACF,SAAK,cAAA,CAAA,aAAL;AACE,aAAO,OAAA,CAAA,SAAA,CAAU,MAAjB;;AACF,SAAK,cAAA,CAAA,cAAL;AACE,aAAO,OAAA,CAAA,SAAA,CAAU,MAAjB;;AACF,SAAK,cAAA,CAAA,UAAL;AACE,aAAO,OAAO,CAAC,IAAI,CAAC,UAAN,CAAd;;AACF,SAAK,cAAA,CAAA,aAAL;AACE,aAAO,OAAA,CAAA,SAAA,CAAU,MAAjB;;AACF,SAAK,cAAA,CAAA,aAAL;AACE,aAAO,OAAA,CAAA,SAAA,CAAU,MAAjB;;AACF,SAAK,cAAA,CAAA,cAAL;AACE,aAAO,OAAA,CAAA,SAAA,CAAU,MAAjB;;AACF,SAAK,cAAA,CAAA,YAAL;AACE,aAAO,OAAA,CAAA,SAAA,CAAU,MAAjB;;AACF,SAAK,cAAA,CAAA,SAAL;AACE,aAAO,OAAO,CAAC,aAAA,CAAA,WAAA,CAAY,IAAZ,EAAkB,cAAA,CAAA,IAAlB,CAAD,CAAd;;AACF,SAAK,cAAA,CAAA,SAAL;AACE,aAAO,OAAO,CAAC,aAAA,CAAA,WAAA,CAAY,IAAZ,EAAkB,cAAA,CAAA,IAAlB,CAAD,CAAd;;AACF,SAAK,cAAA,CAAA,UAAL;AACE,UAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,UAAN,CAAlB;AACA,UAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,SAAN,CAAlB;;AACA,UAAI,EAAE,KAAK,OAAA,CAAA,SAAA,CAAU,MAAjB,IAA2B,EAAE,KAAK,OAAA,CAAA,SAAA,CAAU,MAAhD,EAAwD;AACtD,eAAO,OAAA,CAAA,SAAA,CAAU,MAAjB;AACD;;AACD,aAAO,OAAA,CAAA,SAAA,CAAU,MAAjB;;AACF,SAAK,cAAA,CAAA,YAAL;AACE,UAAM,QAAQ,GAAG,CAAA,EAAA,GAAA,IAAI,CAAC,UAAL,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,UAAlC;;AACA,UAAI,CAAC,QAAL,EAAe;AACb,eAAO,OAAA,CAAA,SAAA,CAAU,IAAjB;AACD;;AACD,aAAO,OAAA,CAAA,WAAA,CAAY,QAAQ,CAAC,IAAT,CAAc,EAA1B,EAA8B,UAArC;;AACF,SAAK,cAAA,CAAA,iBAAL;AACE,aAAO,OAAO,CAAC,aAAA,CAAA,WAAA,CAAY,IAAZ,EAAkB,cAAA,CAAA,IAAlB,CAAD,CAAd;;AACF;AACE,aAAO,OAAA,CAAA,SAAA,CAAU,IAAjB;AArCJ;AAuCD;;AA3CD,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getType = void 0;\nvar lezer_promql_1 = require(\"lezer-promql\");\nvar path_finder_1 = require(\"./path-finder\");\nvar types_1 = require(\"../types\");\n// Based on https://github.com/prometheus/prometheus/blob/d668a7efe3107dbdcc67bf4e9f12430ed8e2b396/promql/parser/ast.go#L191\nfunction getType(node) {\n    var _a;\n    if (!node) {\n        return types_1.ValueType.none;\n    }\n    switch (node.type.id) {\n        case lezer_promql_1.Expr:\n            return getType(node.firstChild);\n        case lezer_promql_1.AggregateExpr:\n            return types_1.ValueType.vector;\n        case lezer_promql_1.VectorSelector:\n            return types_1.ValueType.vector;\n        case lezer_promql_1.OffsetExpr:\n            return getType(node.firstChild);\n        case lezer_promql_1.StringLiteral:\n            return types_1.ValueType.string;\n        case lezer_promql_1.NumberLiteral:\n            return types_1.ValueType.scalar;\n        case lezer_promql_1.MatrixSelector:\n            return types_1.ValueType.matrix;\n        case lezer_promql_1.SubqueryExpr:\n            return types_1.ValueType.matrix;\n        case lezer_promql_1.ParenExpr:\n            return getType(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n        case lezer_promql_1.UnaryExpr:\n            return getType(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n        case lezer_promql_1.BinaryExpr:\n            var lt = getType(node.firstChild);\n            var rt = getType(node.lastChild);\n            if (lt === types_1.ValueType.scalar && rt === types_1.ValueType.scalar) {\n                return types_1.ValueType.scalar;\n            }\n            return types_1.ValueType.vector;\n        case lezer_promql_1.FunctionCall:\n            var funcNode = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n            if (!funcNode) {\n                return types_1.ValueType.none;\n            }\n            return types_1.getFunction(funcNode.type.id).returnType;\n        case lezer_promql_1.StepInvariantExpr:\n            return getType(path_finder_1.walkThrough(node, lezer_promql_1.Expr));\n        default:\n            return types_1.ValueType.none;\n    }\n}\nexports.getType = getType;\n//# sourceMappingURL=type.js.map"]},"metadata":{},"sourceType":"script"}