{"ast":null,"code":"import _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { AggregateExpr, And, BinaryExpr, BinModifiers, Bool, Bottomk, CountValues, Eql, EqlSingle, Expr, FunctionCall, FunctionCallArgs, FunctionCallBody, Gte, Gtr, Identifier, LabelMatcher, LabelMatchers, LabelMatchList, Lss, Lte, MatrixSelector, MetricIdentifier, Neq, Or, ParenExpr, Quantile, StepInvariantExpr, SubqueryExpr, Topk, UnaryExpr, Unless, VectorSelector } from 'lezer-promql';\nimport { containsAtLeastOneChild, retrieveAllRecursiveNodes, walkThrough } from './path-finder';\nimport { getType } from './type';\nimport { buildLabelMatchers } from './matcher';\nimport { syntaxTree } from '@codemirror/language';\nimport { getFunction, Matcher, VectorMatchCardinality, ValueType } from '../types';\nimport { buildVectorMatching } from './vector';\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(state) {\n    _classCallCheck(this, Parser);\n\n    this.tree = syntaxTree(state);\n    this.state = state;\n    this.diagnostics = [];\n  }\n\n  _createClass(Parser, [{\n    key: \"getDiagnostics\",\n    value: function getDiagnostics() {\n      return this.diagnostics.sort(function (a, b) {\n        return a.from - b.from;\n      });\n    }\n  }, {\n    key: \"analyze\",\n    value: function analyze() {\n      // when you are at the root of the tree, the first node is not `Expr` but a node with no name.\n      // So to be able to iterate other the node relative to the promql node, we have to get the first child at the beginning\n      this.checkAST(this.tree.topNode.firstChild);\n      this.diagnoseAllErrorNodes();\n    }\n  }, {\n    key: \"diagnoseAllErrorNodes\",\n    value: function diagnoseAllErrorNodes() {\n      var cursor = this.tree.cursor();\n\n      while (cursor.next()) {\n        // usually there is an error node at the end of the expression when user is typing\n        // so it's not really a useful information to say the expression is wrong.\n        // Hopefully if there is an error node at the end of the tree, checkAST should yell more precisely\n        if (cursor.type.id === 0 && cursor.to !== this.tree.topNode.to) {\n          var node = cursor.node.parent;\n          this.diagnostics.push({\n            severity: 'error',\n            message: 'unexpected expression',\n            from: node ? node.from : cursor.from,\n            to: node ? node.to : cursor.to\n          });\n        }\n      }\n    } // checkAST is inspired of the same named method from prometheus/prometheus:\n    // https://github.com/prometheus/prometheus/blob/3470ee1fbf9d424784eb2613bab5ab0f14b4d222/promql/parser/parse.go#L433\n\n  }, {\n    key: \"checkAST\",\n    value: function checkAST(node) {\n      if (!node) {\n        return ValueType.none;\n      }\n\n      switch (node.type.id) {\n        case Expr:\n          return this.checkAST(node.firstChild);\n\n        case AggregateExpr:\n          this.checkAggregationExpr(node);\n          break;\n\n        case BinaryExpr:\n          this.checkBinaryExpr(node);\n          break;\n\n        case FunctionCall:\n          this.checkCallFunction(node);\n          break;\n\n        case ParenExpr:\n          this.checkAST(walkThrough(node, Expr));\n          break;\n\n        case UnaryExpr:\n          var unaryExprType = this.checkAST(walkThrough(node, Expr));\n\n          if (unaryExprType !== ValueType.scalar && unaryExprType !== ValueType.vector) {\n            this.addDiagnostic(node, \"unary expression only allowed on expressions of type scalar or instant vector, got \".concat(unaryExprType));\n          }\n\n          break;\n\n        case SubqueryExpr:\n          var subQueryExprType = this.checkAST(walkThrough(node, Expr));\n\n          if (subQueryExprType !== ValueType.vector) {\n            this.addDiagnostic(node, \"subquery is only allowed on instant vector, got \".concat(subQueryExprType, \" in \").concat(node.name, \" instead\"));\n          }\n\n          break;\n\n        case MatrixSelector:\n          this.checkAST(walkThrough(node, Expr));\n          break;\n\n        case VectorSelector:\n          this.checkVectorSelector(node);\n          break;\n\n        case StepInvariantExpr:\n          var exprValue = this.checkAST(walkThrough(node, Expr));\n\n          if (exprValue !== ValueType.vector && exprValue !== ValueType.matrix) {\n            this.addDiagnostic(node, \"@ modifier must be preceded by an instant selector vector or range vector selector or a subquery\");\n          } // if you are looking at the Prometheus code, you will likely find that some checks are missing here.\n          // Specially the one checking if the timestamp after the `@` is ok: https://github.com/prometheus/prometheus/blob/ad5ed416ba635834370bfa06139258b31f8c33f9/promql/parser/parse.go#L722-L725\n          // Since Javascript is managing the number as a float64 and so on 53 bits, we cannot validate that the maxInt64 number is a valid value.\n          // So, to manage properly this issue, we would need to use the BigInt which is possible or by using ES2020.BigInt, or by using the lib: https://github.com/GoogleChromeLabs/jsbi.\n          //   * Introducing a lib just for theses checks is quite overkilled\n          //   * Using ES2020 would be the way to go. Unfortunately moving to ES2020 is breaking the build of the lib.\n          //     So far I didn't find the way to fix it. I think it's likely due to the fact we are building an ESM package which is now something stable in nodeJS/javascript but still experimental in typescript.\n          // For the above reason, we decided to drop these checks.\n\n\n          break;\n      }\n\n      return getType(node);\n    }\n  }, {\n    key: \"checkAggregationExpr\",\n    value: function checkAggregationExpr(node) {\n      var _a; // according to https://github.com/promlabs/lezer-promql/blob/master/src/promql.grammar#L26\n      // the name of the aggregator function is stored in the first child\n\n\n      var aggregateOp = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n\n      if (!aggregateOp) {\n        this.addDiagnostic(node, 'aggregation operator expected in aggregation expression but got nothing');\n        return;\n      }\n\n      var expr = walkThrough(node, FunctionCallBody, FunctionCallArgs, Expr);\n\n      if (!expr) {\n        this.addDiagnostic(node, 'unable to find the parameter for the expression');\n        return;\n      }\n\n      this.expectType(expr, ValueType.vector, 'aggregation expression'); // get the parameter of the aggregation operator\n\n      var params = walkThrough(node, FunctionCallBody, FunctionCallArgs, FunctionCallArgs, Expr);\n\n      if (aggregateOp.type.id === Topk || aggregateOp.type.id === Bottomk || aggregateOp.type.id === Quantile) {\n        if (!params) {\n          this.addDiagnostic(node, 'no parameter found');\n          return;\n        }\n\n        this.expectType(params, ValueType.scalar, 'aggregation parameter');\n      }\n\n      if (aggregateOp.type.id === CountValues) {\n        if (!params) {\n          this.addDiagnostic(node, 'no parameter found');\n          return;\n        }\n\n        this.expectType(params, ValueType.string, 'aggregation parameter');\n      }\n    }\n  }, {\n    key: \"checkBinaryExpr\",\n    value: function checkBinaryExpr(node) {\n      // Following the definition of the BinaryExpr, the left and the right\n      // expression are respectively the first and last child\n      // https://github.com/promlabs/lezer-promql/blob/master/src/promql.grammar#L52\n      var lExpr = node.firstChild;\n      var rExpr = node.lastChild;\n\n      if (!lExpr || !rExpr) {\n        this.addDiagnostic(node, 'left or right expression is missing in binary expression');\n        return;\n      }\n\n      var lt = this.checkAST(lExpr);\n      var rt = this.checkAST(rExpr);\n      var boolModifierUsed = walkThrough(node, BinModifiers, Bool);\n      var isComparisonOperator = containsAtLeastOneChild(node, Eql, Neq, Lte, Lss, Gte, Gtr);\n      var isSetOperator = containsAtLeastOneChild(node, And, Or, Unless); // BOOL modifier check\n\n      if (boolModifierUsed) {\n        if (!isComparisonOperator) {\n          this.addDiagnostic(node, 'bool modifier can only be used on comparison operators');\n        }\n      } else {\n        if (isComparisonOperator && lt === ValueType.scalar && rt === ValueType.scalar) {\n          this.addDiagnostic(node, 'comparisons between scalars must use BOOL modifier');\n        }\n      }\n\n      var vectorMatching = buildVectorMatching(this.state, node);\n\n      if (vectorMatching !== null && vectorMatching.on) {\n        var _iterator = _createForOfIteratorHelper(vectorMatching.matchingLabels),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var l1 = _step.value;\n\n            var _iterator2 = _createForOfIteratorHelper(vectorMatching.include),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var l2 = _step2.value;\n\n                if (l1 === l2) {\n                  this.addDiagnostic(node, \"label \\\"\".concat(l1, \"\\\" must not occur in ON and GROUP clause at once\"));\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (lt !== ValueType.scalar && lt !== ValueType.vector) {\n        this.addDiagnostic(lExpr, 'binary expression must contain only scalar and instant vector types');\n      }\n\n      if (rt !== ValueType.scalar && rt !== ValueType.vector) {\n        this.addDiagnostic(rExpr, 'binary expression must contain only scalar and instant vector types');\n      }\n\n      if ((lt !== ValueType.vector || rt !== ValueType.vector) && vectorMatching !== null) {\n        if (vectorMatching.matchingLabels.length > 0) {\n          this.addDiagnostic(node, 'vector matching only allowed between instant vectors');\n        }\n      } else {\n        if (isSetOperator) {\n          if ((vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) === VectorMatchCardinality.CardOneToMany || (vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) === VectorMatchCardinality.CardManyToOne) {\n            this.addDiagnostic(node, 'no grouping allowed for set operations');\n          }\n\n          if ((vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) !== VectorMatchCardinality.CardManyToMany) {\n            this.addDiagnostic(node, 'set operations must always be many-to-many');\n          }\n        }\n      }\n\n      if ((lt === ValueType.scalar || rt === ValueType.scalar) && isSetOperator) {\n        this.addDiagnostic(node, 'set operator not allowed in binary scalar expression');\n      }\n    }\n  }, {\n    key: \"checkCallFunction\",\n    value: function checkCallFunction(node) {\n      var _a;\n\n      var funcID = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n\n      if (!funcID) {\n        this.addDiagnostic(node, 'function not defined');\n        return;\n      }\n\n      var args = retrieveAllRecursiveNodes(walkThrough(node, FunctionCallBody), FunctionCallArgs, Expr);\n      var funcSignature = getFunction(funcID.type.id);\n      var nargs = funcSignature.argTypes.length;\n\n      if (funcSignature.variadic === 0) {\n        if (args.length !== nargs) {\n          this.addDiagnostic(node, \"expected \".concat(nargs, \" argument(s) in call to \\\"\").concat(funcSignature.name, \"\\\", got \").concat(args.length));\n        }\n      } else {\n        var na = nargs - 1;\n\n        if (na > args.length) {\n          this.addDiagnostic(node, \"expected at least \".concat(na, \" argument(s) in call to \\\"\").concat(funcSignature.name, \"\\\", got \").concat(args.length));\n        } else {\n          var nargsmax = na + funcSignature.variadic;\n\n          if (funcSignature.variadic > 0 && nargsmax < args.length) {\n            this.addDiagnostic(node, \"expected at most \".concat(nargsmax, \" argument(s) in call to \\\"\").concat(funcSignature.name, \"\\\", got \").concat(args.length));\n          }\n        }\n      }\n\n      var j = 0;\n\n      for (var i = 0; i < args.length; i++) {\n        j = i;\n\n        if (j >= funcSignature.argTypes.length) {\n          if (funcSignature.variadic === 0) {\n            // This is not a vararg function so we should not check the\n            // type of the extra arguments.\n            break;\n          }\n\n          j = funcSignature.argTypes.length - 1;\n        }\n\n        this.expectType(args[i], funcSignature.argTypes[j], \"call to function \\\"\".concat(funcSignature.name, \"\\\"\"));\n      }\n    }\n  }, {\n    key: \"checkVectorSelector\",\n    value: function checkVectorSelector(node) {\n      var labelMatchers = buildLabelMatchers(retrieveAllRecursiveNodes(walkThrough(node, LabelMatchers, LabelMatchList), LabelMatchList, LabelMatcher), this.state);\n      var vectorSelectorName = ''; // VectorSelector ( MetricIdentifier ( Identifier ) )\n      // https://github.com/promlabs/lezer-promql/blob/71e2f9fa5ae6f5c5547d5738966cd2512e6b99a8/src/promql.grammar#L200\n\n      var vectorSelectorNodeName = walkThrough(node, MetricIdentifier, Identifier);\n\n      if (vectorSelectorNodeName) {\n        vectorSelectorName = this.state.sliceDoc(vectorSelectorNodeName.from, vectorSelectorNodeName.to);\n      }\n\n      if (vectorSelectorName !== '') {\n        // In this case the last LabelMatcher is checking for the metric name\n        // set outside the braces. This checks if the name has already been set\n        // previously\n        var labelMatcherMetricName = labelMatchers.find(function (lm) {\n          return lm.name === '__name__';\n        });\n\n        if (labelMatcherMetricName) {\n          this.addDiagnostic(node, \"metric name must not be set twice: \".concat(vectorSelectorName, \" or \").concat(labelMatcherMetricName.value));\n        } // adding the metric name as a Matcher to avoid a false positive for this kind of expression:\n        // foo{bare=''}\n\n\n        labelMatchers.push(new Matcher(EqlSingle, '__name__', vectorSelectorName));\n      } // A Vector selector must contain at least one non-empty matcher to prevent\n      // implicit selection of all metrics (e.g. by a typo).\n\n\n      var empty = labelMatchers.every(function (lm) {\n        return lm.matchesEmpty();\n      });\n\n      if (empty) {\n        this.addDiagnostic(node, 'vector selector must contain at least one non-empty matcher');\n      }\n    }\n  }, {\n    key: \"expectType\",\n    value: function expectType(node, want, context) {\n      var t = this.checkAST(node);\n\n      if (t !== want) {\n        this.addDiagnostic(node, \"expected type \".concat(want, \" in \").concat(context, \", got \").concat(t));\n      }\n    }\n  }, {\n    key: \"addDiagnostic\",\n    value: function addDiagnostic(node, msg) {\n      this.diagnostics.push({\n        severity: 'error',\n        message: msg,\n        from: node.from,\n        to: node.to\n      });\n    }\n  }]);\n\n  return Parser;\n}();","map":{"version":3,"sources":["../../../src/lang-promql/parser/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { AggregateExpr, And, BinaryExpr, BinModifiers, Bool, Bottomk, CountValues, Eql, EqlSingle, Expr, FunctionCall, FunctionCallArgs, FunctionCallBody, Gte, Gtr, Identifier, LabelMatcher, LabelMatchers, LabelMatchList, Lss, Lte, MatrixSelector, MetricIdentifier, Neq, Or, ParenExpr, Quantile, StepInvariantExpr, SubqueryExpr, Topk, UnaryExpr, Unless, VectorSelector, } from 'lezer-promql';\nimport { containsAtLeastOneChild, retrieveAllRecursiveNodes, walkThrough } from './path-finder';\nimport { getType } from './type';\nimport { buildLabelMatchers } from './matcher';\nimport { syntaxTree } from '@codemirror/language';\nimport { getFunction, Matcher, VectorMatchCardinality, ValueType } from '../types';\nimport { buildVectorMatching } from './vector';\nexport class Parser {\n    constructor(state) {\n        this.tree = syntaxTree(state);\n        this.state = state;\n        this.diagnostics = [];\n    }\n    getDiagnostics() {\n        return this.diagnostics.sort((a, b) => {\n            return a.from - b.from;\n        });\n    }\n    analyze() {\n        // when you are at the root of the tree, the first node is not `Expr` but a node with no name.\n        // So to be able to iterate other the node relative to the promql node, we have to get the first child at the beginning\n        this.checkAST(this.tree.topNode.firstChild);\n        this.diagnoseAllErrorNodes();\n    }\n    diagnoseAllErrorNodes() {\n        const cursor = this.tree.cursor();\n        while (cursor.next()) {\n            // usually there is an error node at the end of the expression when user is typing\n            // so it's not really a useful information to say the expression is wrong.\n            // Hopefully if there is an error node at the end of the tree, checkAST should yell more precisely\n            if (cursor.type.id === 0 && cursor.to !== this.tree.topNode.to) {\n                const node = cursor.node.parent;\n                this.diagnostics.push({\n                    severity: 'error',\n                    message: 'unexpected expression',\n                    from: node ? node.from : cursor.from,\n                    to: node ? node.to : cursor.to,\n                });\n            }\n        }\n    }\n    // checkAST is inspired of the same named method from prometheus/prometheus:\n    // https://github.com/prometheus/prometheus/blob/3470ee1fbf9d424784eb2613bab5ab0f14b4d222/promql/parser/parse.go#L433\n    checkAST(node) {\n        if (!node) {\n            return ValueType.none;\n        }\n        switch (node.type.id) {\n            case Expr:\n                return this.checkAST(node.firstChild);\n            case AggregateExpr:\n                this.checkAggregationExpr(node);\n                break;\n            case BinaryExpr:\n                this.checkBinaryExpr(node);\n                break;\n            case FunctionCall:\n                this.checkCallFunction(node);\n                break;\n            case ParenExpr:\n                this.checkAST(walkThrough(node, Expr));\n                break;\n            case UnaryExpr:\n                const unaryExprType = this.checkAST(walkThrough(node, Expr));\n                if (unaryExprType !== ValueType.scalar && unaryExprType !== ValueType.vector) {\n                    this.addDiagnostic(node, `unary expression only allowed on expressions of type scalar or instant vector, got ${unaryExprType}`);\n                }\n                break;\n            case SubqueryExpr:\n                const subQueryExprType = this.checkAST(walkThrough(node, Expr));\n                if (subQueryExprType !== ValueType.vector) {\n                    this.addDiagnostic(node, `subquery is only allowed on instant vector, got ${subQueryExprType} in ${node.name} instead`);\n                }\n                break;\n            case MatrixSelector:\n                this.checkAST(walkThrough(node, Expr));\n                break;\n            case VectorSelector:\n                this.checkVectorSelector(node);\n                break;\n            case StepInvariantExpr:\n                const exprValue = this.checkAST(walkThrough(node, Expr));\n                if (exprValue !== ValueType.vector && exprValue !== ValueType.matrix) {\n                    this.addDiagnostic(node, `@ modifier must be preceded by an instant selector vector or range vector selector or a subquery`);\n                }\n                // if you are looking at the Prometheus code, you will likely find that some checks are missing here.\n                // Specially the one checking if the timestamp after the `@` is ok: https://github.com/prometheus/prometheus/blob/ad5ed416ba635834370bfa06139258b31f8c33f9/promql/parser/parse.go#L722-L725\n                // Since Javascript is managing the number as a float64 and so on 53 bits, we cannot validate that the maxInt64 number is a valid value.\n                // So, to manage properly this issue, we would need to use the BigInt which is possible or by using ES2020.BigInt, or by using the lib: https://github.com/GoogleChromeLabs/jsbi.\n                //   * Introducing a lib just for theses checks is quite overkilled\n                //   * Using ES2020 would be the way to go. Unfortunately moving to ES2020 is breaking the build of the lib.\n                //     So far I didn't find the way to fix it. I think it's likely due to the fact we are building an ESM package which is now something stable in nodeJS/javascript but still experimental in typescript.\n                // For the above reason, we decided to drop these checks.\n                break;\n        }\n        return getType(node);\n    }\n    checkAggregationExpr(node) {\n        var _a;\n        // according to https://github.com/promlabs/lezer-promql/blob/master/src/promql.grammar#L26\n        // the name of the aggregator function is stored in the first child\n        const aggregateOp = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n        if (!aggregateOp) {\n            this.addDiagnostic(node, 'aggregation operator expected in aggregation expression but got nothing');\n            return;\n        }\n        const expr = walkThrough(node, FunctionCallBody, FunctionCallArgs, Expr);\n        if (!expr) {\n            this.addDiagnostic(node, 'unable to find the parameter for the expression');\n            return;\n        }\n        this.expectType(expr, ValueType.vector, 'aggregation expression');\n        // get the parameter of the aggregation operator\n        const params = walkThrough(node, FunctionCallBody, FunctionCallArgs, FunctionCallArgs, Expr);\n        if (aggregateOp.type.id === Topk || aggregateOp.type.id === Bottomk || aggregateOp.type.id === Quantile) {\n            if (!params) {\n                this.addDiagnostic(node, 'no parameter found');\n                return;\n            }\n            this.expectType(params, ValueType.scalar, 'aggregation parameter');\n        }\n        if (aggregateOp.type.id === CountValues) {\n            if (!params) {\n                this.addDiagnostic(node, 'no parameter found');\n                return;\n            }\n            this.expectType(params, ValueType.string, 'aggregation parameter');\n        }\n    }\n    checkBinaryExpr(node) {\n        // Following the definition of the BinaryExpr, the left and the right\n        // expression are respectively the first and last child\n        // https://github.com/promlabs/lezer-promql/blob/master/src/promql.grammar#L52\n        const lExpr = node.firstChild;\n        const rExpr = node.lastChild;\n        if (!lExpr || !rExpr) {\n            this.addDiagnostic(node, 'left or right expression is missing in binary expression');\n            return;\n        }\n        const lt = this.checkAST(lExpr);\n        const rt = this.checkAST(rExpr);\n        const boolModifierUsed = walkThrough(node, BinModifiers, Bool);\n        const isComparisonOperator = containsAtLeastOneChild(node, Eql, Neq, Lte, Lss, Gte, Gtr);\n        const isSetOperator = containsAtLeastOneChild(node, And, Or, Unless);\n        // BOOL modifier check\n        if (boolModifierUsed) {\n            if (!isComparisonOperator) {\n                this.addDiagnostic(node, 'bool modifier can only be used on comparison operators');\n            }\n        }\n        else {\n            if (isComparisonOperator && lt === ValueType.scalar && rt === ValueType.scalar) {\n                this.addDiagnostic(node, 'comparisons between scalars must use BOOL modifier');\n            }\n        }\n        const vectorMatching = buildVectorMatching(this.state, node);\n        if (vectorMatching !== null && vectorMatching.on) {\n            for (const l1 of vectorMatching.matchingLabels) {\n                for (const l2 of vectorMatching.include) {\n                    if (l1 === l2) {\n                        this.addDiagnostic(node, `label \"${l1}\" must not occur in ON and GROUP clause at once`);\n                    }\n                }\n            }\n        }\n        if (lt !== ValueType.scalar && lt !== ValueType.vector) {\n            this.addDiagnostic(lExpr, 'binary expression must contain only scalar and instant vector types');\n        }\n        if (rt !== ValueType.scalar && rt !== ValueType.vector) {\n            this.addDiagnostic(rExpr, 'binary expression must contain only scalar and instant vector types');\n        }\n        if ((lt !== ValueType.vector || rt !== ValueType.vector) && vectorMatching !== null) {\n            if (vectorMatching.matchingLabels.length > 0) {\n                this.addDiagnostic(node, 'vector matching only allowed between instant vectors');\n            }\n        }\n        else {\n            if (isSetOperator) {\n                if ((vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) === VectorMatchCardinality.CardOneToMany || (vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) === VectorMatchCardinality.CardManyToOne) {\n                    this.addDiagnostic(node, 'no grouping allowed for set operations');\n                }\n                if ((vectorMatching === null || vectorMatching === void 0 ? void 0 : vectorMatching.card) !== VectorMatchCardinality.CardManyToMany) {\n                    this.addDiagnostic(node, 'set operations must always be many-to-many');\n                }\n            }\n        }\n        if ((lt === ValueType.scalar || rt === ValueType.scalar) && isSetOperator) {\n            this.addDiagnostic(node, 'set operator not allowed in binary scalar expression');\n        }\n    }\n    checkCallFunction(node) {\n        var _a;\n        const funcID = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n        if (!funcID) {\n            this.addDiagnostic(node, 'function not defined');\n            return;\n        }\n        const args = retrieveAllRecursiveNodes(walkThrough(node, FunctionCallBody), FunctionCallArgs, Expr);\n        const funcSignature = getFunction(funcID.type.id);\n        const nargs = funcSignature.argTypes.length;\n        if (funcSignature.variadic === 0) {\n            if (args.length !== nargs) {\n                this.addDiagnostic(node, `expected ${nargs} argument(s) in call to \"${funcSignature.name}\", got ${args.length}`);\n            }\n        }\n        else {\n            const na = nargs - 1;\n            if (na > args.length) {\n                this.addDiagnostic(node, `expected at least ${na} argument(s) in call to \"${funcSignature.name}\", got ${args.length}`);\n            }\n            else {\n                const nargsmax = na + funcSignature.variadic;\n                if (funcSignature.variadic > 0 && nargsmax < args.length) {\n                    this.addDiagnostic(node, `expected at most ${nargsmax} argument(s) in call to \"${funcSignature.name}\", got ${args.length}`);\n                }\n            }\n        }\n        let j = 0;\n        for (let i = 0; i < args.length; i++) {\n            j = i;\n            if (j >= funcSignature.argTypes.length) {\n                if (funcSignature.variadic === 0) {\n                    // This is not a vararg function so we should not check the\n                    // type of the extra arguments.\n                    break;\n                }\n                j = funcSignature.argTypes.length - 1;\n            }\n            this.expectType(args[i], funcSignature.argTypes[j], `call to function \"${funcSignature.name}\"`);\n        }\n    }\n    checkVectorSelector(node) {\n        const labelMatchers = buildLabelMatchers(retrieveAllRecursiveNodes(walkThrough(node, LabelMatchers, LabelMatchList), LabelMatchList, LabelMatcher), this.state);\n        let vectorSelectorName = '';\n        // VectorSelector ( MetricIdentifier ( Identifier ) )\n        // https://github.com/promlabs/lezer-promql/blob/71e2f9fa5ae6f5c5547d5738966cd2512e6b99a8/src/promql.grammar#L200\n        const vectorSelectorNodeName = walkThrough(node, MetricIdentifier, Identifier);\n        if (vectorSelectorNodeName) {\n            vectorSelectorName = this.state.sliceDoc(vectorSelectorNodeName.from, vectorSelectorNodeName.to);\n        }\n        if (vectorSelectorName !== '') {\n            // In this case the last LabelMatcher is checking for the metric name\n            // set outside the braces. This checks if the name has already been set\n            // previously\n            const labelMatcherMetricName = labelMatchers.find((lm) => lm.name === '__name__');\n            if (labelMatcherMetricName) {\n                this.addDiagnostic(node, `metric name must not be set twice: ${vectorSelectorName} or ${labelMatcherMetricName.value}`);\n            }\n            // adding the metric name as a Matcher to avoid a false positive for this kind of expression:\n            // foo{bare=''}\n            labelMatchers.push(new Matcher(EqlSingle, '__name__', vectorSelectorName));\n        }\n        // A Vector selector must contain at least one non-empty matcher to prevent\n        // implicit selection of all metrics (e.g. by a typo).\n        const empty = labelMatchers.every((lm) => lm.matchesEmpty());\n        if (empty) {\n            this.addDiagnostic(node, 'vector selector must contain at least one non-empty matcher');\n        }\n    }\n    expectType(node, want, context) {\n        const t = this.checkAST(node);\n        if (t !== want) {\n            this.addDiagnostic(node, `expected type ${want} in ${context}, got ${t}`);\n        }\n    }\n    addDiagnostic(node, msg) {\n        this.diagnostics.push({\n            severity: 'error',\n            message: msg,\n            from: node.from,\n            to: node.to,\n        });\n    }\n}\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}