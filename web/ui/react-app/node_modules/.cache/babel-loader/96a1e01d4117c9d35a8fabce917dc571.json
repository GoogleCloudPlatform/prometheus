{"ast":null,"code":"/*\n * Fuzzy\n * https://github.com/myork/fuzzy\n *\n * Copyright (c) 2012 Matt York\n * Licensed under the MIT license.\n */\n(function () {\n  var root = this;\n  var fuzzy = {}; // Use in node or in browser\n\n  if (typeof exports !== 'undefined') {\n    module.exports = fuzzy;\n  } else {\n    root.fuzzy = fuzzy;\n  } // Return all elements of `array` that have a fuzzy\n  // match against `pattern`.\n\n\n  fuzzy.simpleFilter = function (pattern, array) {\n    return array.filter(function (str) {\n      return fuzzy.test(pattern, str);\n    });\n  }; // Does `pattern` fuzzy match `str`?\n\n\n  fuzzy.test = function (pattern, str) {\n    return fuzzy.match(pattern, str) !== null;\n  }; // If `pattern` matches `str`, wrap each matching character\n  // in `opts.pre` and `opts.post`. If no match, return null\n\n\n  fuzzy.match = function (pattern, str, opts) {\n    opts = opts || {};\n    var patternIdx = 0,\n        result = [],\n        len = str.length,\n        totalScore = 0,\n        currScore = 0 // prefix\n    ,\n        pre = opts.pre || '' // suffix\n    ,\n        post = opts.post || '' // String to compare against. This might be a lowercase version of the\n    // raw string\n    ,\n        compareString = opts.caseSensitive && str || str.toLowerCase(),\n        ch;\n    pattern = opts.caseSensitive && pattern || pattern.toLowerCase(); // For each character in the string, either add it to the result\n    // or wrap in template if it's the next string in the pattern\n\n    for (var idx = 0; idx < len; idx++) {\n      ch = str[idx];\n\n      if (compareString[idx] === pattern[patternIdx]) {\n        ch = pre + ch + post;\n        patternIdx += 1; // consecutive characters should increase the score more than linearly\n\n        currScore += 1 + currScore;\n      } else {\n        currScore = 0;\n      }\n\n      totalScore += currScore;\n      result[result.length] = ch;\n    } // return rendered string if we have a match for every char\n\n\n    if (patternIdx === pattern.length) {\n      // if the string is an exact match with pattern, totalScore should be maxed\n      totalScore = compareString === pattern ? Infinity : totalScore;\n      return {\n        rendered: result.join(''),\n        score: totalScore\n      };\n    }\n\n    return null;\n  }; // The normal entry point. Filters `arr` for matches against `pattern`.\n  // It returns an array with matching values of the type:\n  //\n  //     [{\n  //         string:   '<b>lah' // The rendered string\n  //       , index:    2        // The index of the element in `arr`\n  //       , original: 'blah'   // The original element in `arr`\n  //     }]\n  //\n  // `opts` is an optional argument bag. Details:\n  //\n  //    opts = {\n  //        // string to put before a matching character\n  //        pre:     '<b>'\n  //\n  //        // string to put after matching character\n  //      , post:    '</b>'\n  //\n  //        // Optional function. Input is an entry in the given arr`,\n  //        // output should be the string to test `pattern` against.\n  //        // In this example, if `arr = [{crying: 'koala'}]` we would return\n  //        // 'koala'.\n  //      , extract: function(arg) { return arg.crying; }\n  //    }\n\n\n  fuzzy.filter = function (pattern, arr, opts) {\n    if (!arr || arr.length === 0) {\n      return [];\n    }\n\n    if (typeof pattern !== 'string') {\n      return arr;\n    }\n\n    opts = opts || {};\n    return arr.reduce(function (prev, element, idx, arr) {\n      var str = element;\n\n      if (opts.extract) {\n        str = opts.extract(element);\n      }\n\n      var rendered = fuzzy.match(pattern, str, opts);\n\n      if (rendered != null) {\n        prev[prev.length] = {\n          string: rendered.rendered,\n          score: rendered.score,\n          index: idx,\n          original: element\n        };\n      }\n\n      return prev;\n    }, []) // Sort by score. Browsers are inconsistent wrt stable/unstable\n    // sorting, so force stable by using the index in the case of tie.\n    // See http://ofb.net/~sethml/is-sort-stable.html\n    .sort(function (a, b) {\n      var compare = b.score - a.score;\n      if (compare) return compare;\n      return a.index - b.index;\n    });\n  };\n})();","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/fuzzy/lib/fuzzy.js"],"names":["root","fuzzy","exports","module","simpleFilter","pattern","array","filter","str","test","match","opts","patternIdx","result","len","length","totalScore","currScore","pre","post","compareString","caseSensitive","toLowerCase","ch","idx","Infinity","rendered","join","score","arr","reduce","prev","element","extract","string","index","original","sort","a","b","compare"],"mappings":"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","sourcesContent":["/*\n * Fuzzy\n * https://github.com/myork/fuzzy\n *\n * Copyright (c) 2012 Matt York\n * Licensed under the MIT license.\n */\n\n(function() {\n\nvar root = this;\n\nvar fuzzy = {};\n\n// Use in node or in browser\nif (typeof exports !== 'undefined') {\n  module.exports = fuzzy;\n} else {\n  root.fuzzy = fuzzy;\n}\n\n// Return all elements of `array` that have a fuzzy\n// match against `pattern`.\nfuzzy.simpleFilter = function(pattern, array) {\n  return array.filter(function(str) {\n    return fuzzy.test(pattern, str);\n  });\n};\n\n// Does `pattern` fuzzy match `str`?\nfuzzy.test = function(pattern, str) {\n  return fuzzy.match(pattern, str) !== null;\n};\n\n// If `pattern` matches `str`, wrap each matching character\n// in `opts.pre` and `opts.post`. If no match, return null\nfuzzy.match = function(pattern, str, opts) {\n  opts = opts || {};\n  var patternIdx = 0\n    , result = []\n    , len = str.length\n    , totalScore = 0\n    , currScore = 0\n    // prefix\n    , pre = opts.pre || ''\n    // suffix\n    , post = opts.post || ''\n    // String to compare against. This might be a lowercase version of the\n    // raw string\n    , compareString =  opts.caseSensitive && str || str.toLowerCase()\n    , ch;\n\n  pattern = opts.caseSensitive && pattern || pattern.toLowerCase();\n\n  // For each character in the string, either add it to the result\n  // or wrap in template if it's the next string in the pattern\n  for(var idx = 0; idx < len; idx++) {\n    ch = str[idx];\n    if(compareString[idx] === pattern[patternIdx]) {\n      ch = pre + ch + post;\n      patternIdx += 1;\n\n      // consecutive characters should increase the score more than linearly\n      currScore += 1 + currScore;\n    } else {\n      currScore = 0;\n    }\n    totalScore += currScore;\n    result[result.length] = ch;\n  }\n\n  // return rendered string if we have a match for every char\n  if(patternIdx === pattern.length) {\n    // if the string is an exact match with pattern, totalScore should be maxed\n    totalScore = (compareString === pattern) ? Infinity : totalScore;\n    return {rendered: result.join(''), score: totalScore};\n  }\n\n  return null;\n};\n\n// The normal entry point. Filters `arr` for matches against `pattern`.\n// It returns an array with matching values of the type:\n//\n//     [{\n//         string:   '<b>lah' // The rendered string\n//       , index:    2        // The index of the element in `arr`\n//       , original: 'blah'   // The original element in `arr`\n//     }]\n//\n// `opts` is an optional argument bag. Details:\n//\n//    opts = {\n//        // string to put before a matching character\n//        pre:     '<b>'\n//\n//        // string to put after matching character\n//      , post:    '</b>'\n//\n//        // Optional function. Input is an entry in the given arr`,\n//        // output should be the string to test `pattern` against.\n//        // In this example, if `arr = [{crying: 'koala'}]` we would return\n//        // 'koala'.\n//      , extract: function(arg) { return arg.crying; }\n//    }\nfuzzy.filter = function(pattern, arr, opts) {\n  if(!arr || arr.length === 0) {\n    return [];\n  }\n  if (typeof pattern !== 'string') {\n    return arr;\n  }\n  opts = opts || {};\n  return arr\n    .reduce(function(prev, element, idx, arr) {\n      var str = element;\n      if(opts.extract) {\n        str = opts.extract(element);\n      }\n      var rendered = fuzzy.match(pattern, str, opts);\n      if(rendered != null) {\n        prev[prev.length] = {\n            string: rendered.rendered\n          , score: rendered.score\n          , index: idx\n          , original: element\n        };\n      }\n      return prev;\n    }, [])\n\n    // Sort by score. Browsers are inconsistent wrt stable/unstable\n    // sorting, so force stable by using the index in the case of tie.\n    // See http://ofb.net/~sethml/is-sort-stable.html\n    .sort(function(a,b) {\n      var compare = b.score - a.score;\n      if(compare) return compare;\n      return a.index - b.index;\n    });\n};\n\n\n}());\n\n"]},"metadata":{},"sourceType":"script"}