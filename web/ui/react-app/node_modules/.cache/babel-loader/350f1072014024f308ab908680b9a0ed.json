{"ast":null,"code":"import _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { Facet, combineConfig, StateField } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport { EditorView, Decoration } from '@codemirror/view';\nimport { NodeProp } from 'lezer-tree';\nvar baseTheme = EditorView.baseTheme({\n  \".cm-matchingBracket\": {\n    color: \"#0b0\"\n  },\n  \".cm-nonmatchingBracket\": {\n    color: \"#a22\"\n  }\n});\nvar DefaultScanDist = 10000,\n    DefaultBrackets = \"()[]{}\";\nvar bracketMatchingConfig = Facet.define({\n  combine: function combine(configs) {\n    return combineConfig(configs, {\n      afterCursor: true,\n      brackets: DefaultBrackets,\n      maxScanDistance: DefaultScanDist\n    });\n  }\n});\nvar matchingMark = Decoration.mark({\n  class: \"cm-matchingBracket\"\n}),\n    nonmatchingMark = Decoration.mark({\n  class: \"cm-nonmatchingBracket\"\n});\nvar bracketMatchingState = StateField.define({\n  create: function create() {\n    return Decoration.none;\n  },\n  update: function update(deco, tr) {\n    if (!tr.docChanged && !tr.selection) return deco;\n    var decorations = [];\n    var config = tr.state.facet(bracketMatchingConfig);\n\n    var _iterator = _createForOfIteratorHelper(tr.state.selection.ranges),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var range = _step.value;\n        if (!range.empty) continue;\n        var match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n        if (!match) continue;\n        var mark = match.matched ? matchingMark : nonmatchingMark;\n        decorations.push(mark.range(match.start.from, match.start.to));\n        if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return Decoration.set(decorations, true);\n  },\n  provide: function provide(f) {\n    return EditorView.decorations.from(f);\n  }\n});\nvar bracketMatchingUnique = [bracketMatchingState, baseTheme]; /// Create an extension that enables bracket matching. Whenever the\n/// cursor is next to a bracket, that bracket and the one it matches\n/// are highlighted. Or, when no matching bracket is found, another\n/// highlighting style is used to indicate this.\n\nfunction bracketMatching() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\n\nfunction matchingNodes(node, dir, brackets) {\n  var byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);\n  if (byProp) return byProp;\n\n  if (node.name.length == 1) {\n    var index = brackets.indexOf(node.name);\n    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];\n  }\n\n  return null;\n} /// Find the matching bracket for the token at `pos`, scanning\n/// direction `dir`. Only the `brackets` and `maxScanDistance`\n/// properties are used from `config`, if given. Returns null if no\n/// bracket was found at `pos`, or a match result otherwise.\n\n\nfunction matchBrackets(state, pos, dir) {\n  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var maxScanDistance = config.maxScanDistance || DefaultScanDist,\n      brackets = config.brackets || DefaultBrackets;\n  var tree = syntaxTree(state),\n      sub = tree.resolve(pos, dir),\n      matches;\n  if (matches = matchingNodes(sub.type, dir, brackets)) return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);else return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);\n}\n\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n  var parent = token.parent,\n      firstToken = {\n    from: token.from,\n    to: token.to\n  };\n  var depth = 0,\n      cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n      if (depth == 0 && matching.indexOf(cursor.type.name) > -1) {\n        return {\n          start: firstToken,\n          end: {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: true\n        };\n      } else if (matchingNodes(cursor.type, dir, brackets)) {\n        depth++;\n      } else if (matchingNodes(cursor.type, -dir, brackets)) {\n        depth--;\n        if (depth == 0) return {\n          start: firstToken,\n          end: {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: false\n        };\n      }\n    }\n  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n  return {\n    start: firstToken,\n    matched: false\n  };\n}\n\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n  var startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n  var bracket = brackets.indexOf(startCh);\n  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n  var startToken = {\n    from: dir < 0 ? pos - 1 : pos,\n    to: dir > 0 ? pos + 1 : pos\n  };\n  var iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),\n      depth = 0;\n\n  for (var distance = 0; !iter.next().done && distance <= maxScanDistance;) {\n    var text = iter.value;\n    if (dir < 0) distance += text.length;\n    var basePos = pos + distance * dir;\n\n    for (var _pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; _pos2 != end; _pos2 += dir) {\n      var found = brackets.indexOf(text[_pos2]);\n      if (found < 0 || tree.resolve(basePos + _pos2, 1).type != tokenType) continue;\n\n      if (found % 2 == 0 == dir > 0) {\n        depth++;\n      } else if (depth == 1) {\n        // Closing\n        return {\n          start: startToken,\n          end: {\n            from: basePos + _pos2,\n            to: basePos + _pos2 + 1\n          },\n          matched: found >> 1 == bracket >> 1\n        };\n      } else {\n        depth--;\n      }\n    }\n\n    if (dir > 0) distance += text.length;\n  }\n\n  return iter.done ? {\n    start: startToken,\n    matched: false\n  } : null;\n}\n\nexport { bracketMatching, matchBrackets };","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/@codemirror/matchbrackets/dist/index.js"],"names":["Facet","combineConfig","StateField","syntaxTree","EditorView","Decoration","NodeProp","baseTheme","color","DefaultScanDist","DefaultBrackets","bracketMatchingConfig","define","combine","configs","afterCursor","brackets","maxScanDistance","matchingMark","mark","class","nonmatchingMark","bracketMatchingState","create","none","update","deco","tr","docChanged","selection","decorations","config","state","facet","ranges","range","empty","match","matchBrackets","head","doc","length","matched","push","start","from","to","end","set","provide","f","bracketMatchingUnique","bracketMatching","of","matchingNodes","node","dir","byProp","prop","openedBy","closedBy","name","index","indexOf","pos","tree","sub","resolve","matches","type","matchMarkedBrackets","matchPlainBrackets","_state","_pos","token","matching","parent","firstToken","depth","cursor","childBefore","childAfter","prevSibling","nextSibling","tokenType","startCh","sliceDoc","bracket","startToken","iter","iterRange","distance","next","done","text","value","basePos","found"],"mappings":"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","sourcesContent":["import { Facet, combineConfig, StateField } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport { EditorView, Decoration } from '@codemirror/view';\nimport { NodeProp } from 'lezer-tree';\n\nconst baseTheme = EditorView.baseTheme({\n    \".cm-matchingBracket\": { color: \"#0b0\" },\n    \".cm-nonmatchingBracket\": { color: \"#a22\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist\n        });\n    }\n});\nconst matchingMark = Decoration.mark({ class: \"cm-matchingBracket\" }), nonmatchingMark = Decoration.mark({ class: \"cm-nonmatchingBracket\" });\nconst bracketMatchingState = StateField.define({\n    create() { return Decoration.none; },\n    update(deco, tr) {\n        if (!tr.docChanged && !tr.selection)\n            return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(tr.state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(tr.state, range.head, 1, config) ||\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\n            if (!match)\n                continue;\n            let mark = match.matched ? matchingMark : nonmatchingMark;\n            decorations.push(mark.range(match.start.from, match.start.to));\n            if (match.end)\n                decorations.push(mark.range(match.end.from, match.end.to));\n        }\n        return Decoration.set(decorations, true);\n    },\n    provide: f => EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/// Create an extension that enables bracket matching. Whenever the\n/// cursor is next to a bracket, that bracket and the one it matches\n/// are highlighted. Or, when no matching bracket is found, another\n/// highlighting style is used to indicate this.\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/// Find the matching bracket for the token at `pos`, scanning\n/// direction `dir`. Only the `brackets` and `maxScanDistance`\n/// properties are used from `config`, if given. Returns null if no\n/// bracket was found at `pos`, or a match result otherwise.\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), sub = tree.resolve(pos, dir), matches;\n    if (matches = matchingNodes(sub.type, dir, brackets))\n        return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);\n    else\n        return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.from, to: token.to };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\n        do {\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1) {\n                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };\n                }\n                else if (matchingNodes(cursor.type, dir, brackets)) {\n                    depth++;\n                }\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\n                    depth--;\n                    if (depth == 0)\n                        return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: false };\n                }\n            }\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\nexport { bracketMatching, matchBrackets };\n"]},"metadata":{},"sourceType":"module"}