{"ast":null,"code":"import _objectSpread from\"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import $ from'jquery';import{escapeHTML}from'../../utils';import moment from'moment-timezone';export var formatValue=function formatValue(y){if(y===null){return'null';}var absY=Math.abs(y);if(absY>=1e24){return(y/1e24).toFixed(2)+'Y';}else if(absY>=1e21){return(y/1e21).toFixed(2)+'Z';}else if(absY>=1e18){return(y/1e18).toFixed(2)+'E';}else if(absY>=1e15){return(y/1e15).toFixed(2)+'P';}else if(absY>=1e12){return(y/1e12).toFixed(2)+'T';}else if(absY>=1e9){return(y/1e9).toFixed(2)+'G';}else if(absY>=1e6){return(y/1e6).toFixed(2)+'M';}else if(absY>=1e3){return(y/1e3).toFixed(2)+'k';}else if(absY>=1){return y.toFixed(2);}else if(absY===0){return y.toFixed(2);}else if(absY<1e-23){return(y/1e-24).toFixed(2)+'y';}else if(absY<1e-20){return(y/1e-21).toFixed(2)+'z';}else if(absY<1e-17){return(y/1e-18).toFixed(2)+'a';}else if(absY<1e-14){return(y/1e-15).toFixed(2)+'f';}else if(absY<1e-11){return(y/1e-12).toFixed(2)+'p';}else if(absY<1e-8){return(y/1e-9).toFixed(2)+'n';}else if(absY<1e-5){return(y/1e-6).toFixed(2)+'µ';}else if(absY<1e-2){return(y/1e-3).toFixed(2)+'m';}else if(absY<=1){return y.toFixed(2);}throw Error(\"couldn't format a value, this is a bug\");};export var getHoverColor=function getHoverColor(color,opacity,stacked){var _$$color$parse=$.color.parse(color),r=_$$color$parse.r,g=_$$color$parse.g,b=_$$color$parse.b;if(!stacked){return\"rgba(\".concat(r,\", \").concat(g,\", \").concat(b,\", \").concat(opacity,\")\");}/*\n    Unfortunately flot doesn't take into consideration\n    the alpha value when adjusting the color on the stacked series.\n    TODO: find better way to set the opacity.\n  */var base=(1-opacity)*255;return\"rgb(\".concat(Math.round(base+opacity*r),\",\").concat(Math.round(base+opacity*g),\",\").concat(Math.round(base+opacity*b),\")\");};export var toHoverColor=function toHoverColor(index,stacked){return function(series,i){return _objectSpread(_objectSpread({},series),{},{color:getHoverColor(series.color,i!==index?0.3:1,stacked)});};};export var getOptions=function getOptions(stacked,useLocalTime){return{grid:{hoverable:true,clickable:true,autoHighlight:true,mouseActiveRadius:100},legend:{show:false},xaxis:{mode:'time',showTicks:true,showMinorTicks:true,timeBase:'milliseconds',timezone:useLocalTime?'browser':undefined},yaxis:{tickFormatter:formatValue},crosshair:{mode:'xy',color:'#bbb'},tooltip:{show:true,cssClass:'graph-tooltip',content:function content(_,xval,yval,_ref){var series=_ref.series;var labels=series.labels,color=series.color;var dateTime=moment(xval);if(!useLocalTime){dateTime=dateTime.utc();}return\"\\n            <div class=\\\"date\\\">\".concat(dateTime.format('YYYY-MM-DD HH:mm:ss Z'),\"</div>\\n            <div>\\n              <span class=\\\"detail-swatch\\\" style=\\\"background-color: \").concat(color,\"\\\"></span>\\n              <span>\").concat(labels.__name__||'value',\": <strong>\").concat(yval,\"</strong></span>\\n            <div>\\n            <div class=\\\"labels mt-1\\\">\\n              \").concat(Object.keys(labels).map(function(k){return k!=='__name__'?\"<div class=\\\"mb-1\\\"><strong>\".concat(k,\"</strong>: \").concat(escapeHTML(labels[k]),\"</div>\"):'';}).join(''),\"\\n            </div>\\n          \");},defaultTheme:false,lines:true},series:{stack:stacked,lines:{lineWidth:stacked?1:2,steps:false,fill:stacked},shadowSize:0}};};// This was adapted from Flot's color generation code.\nexport var getColors=function getColors(data){var colorPool=['#edc240','#afd8f8','#cb4b4b','#4da74d','#9440ed'];var colorPoolSize=colorPool.length;var variation=0;return data.result.map(function(_,i){// Each time we exhaust the colors in the pool we adjust\n// a scaling factor used to produce more variations on\n// those colors. The factor alternates negative/positive\n// to produce lighter/darker colors.\n// Reset the variation after every few cycles, or else\n// it will end up producing only white or black colors.\nif(i%colorPoolSize===0&&i){if(variation>=0){variation=variation<0.5?-variation-0.2:0;}else{variation=-variation;}}return $.color.parse(colorPool[i%colorPoolSize]||'#666').scale('rgb',1+variation);});};export var normalizeData=function normalizeData(_ref2){var queryParams=_ref2.queryParams,data=_ref2.data;var colors=getColors(data);var _ref3=queryParams,startTime=_ref3.startTime,endTime=_ref3.endTime,resolution=_ref3.resolution;return data.result.map(function(_ref4,index){var values=_ref4.values,metric=_ref4.metric;// Insert nulls for all missing steps.\nvar data=[];var pos=0;for(var t=startTime;t<=endTime;t+=resolution){// Allow for floating point inaccuracy.\nvar currentValue=values[pos];if(values.length>pos&&currentValue[0]<t+resolution/100){data.push([currentValue[0]*1000,parseValue(currentValue[1])]);pos++;}else{data.push([t*1000,null]);}}return{labels:metric!==null?metric:{},color:colors[index].toString(),data:data,index:index};});};export var parseValue=function parseValue(value){var val=parseFloat(value);// \"+Inf\", \"-Inf\", \"+Inf\" will be parsed into NaN by parseFloat(). They\n// can't be graphed, so show them as gaps (null).\nreturn isNaN(val)?null:val;};","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/src/pages/graph/GraphHelpers.ts"],"names":["$","escapeHTML","moment","formatValue","y","absY","Math","abs","toFixed","Error","getHoverColor","color","opacity","stacked","parse","r","g","b","base","round","toHoverColor","index","series","i","getOptions","useLocalTime","grid","hoverable","clickable","autoHighlight","mouseActiveRadius","legend","show","xaxis","mode","showTicks","showMinorTicks","timeBase","timezone","undefined","yaxis","tickFormatter","crosshair","tooltip","cssClass","content","_","xval","yval","labels","dateTime","utc","format","__name__","Object","keys","map","k","join","defaultTheme","lines","stack","lineWidth","steps","fill","shadowSize","getColors","data","colorPool","colorPoolSize","length","variation","result","scale","normalizeData","queryParams","colors","startTime","endTime","resolution","values","metric","pos","t","currentValue","push","parseValue","toString","value","val","parseFloat","isNaN"],"mappings":"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","sourcesContent":["import $ from 'jquery';\n\nimport { escapeHTML } from '../../utils';\nimport { Metric } from '../../types/types';\nimport { GraphProps, GraphSeries } from './Graph';\nimport moment from 'moment-timezone';\n\nexport const formatValue = (y: number | null): string => {\n  if (y === null) {\n    return 'null';\n  }\n  const absY = Math.abs(y);\n\n  if (absY >= 1e24) {\n    return (y / 1e24).toFixed(2) + 'Y';\n  } else if (absY >= 1e21) {\n    return (y / 1e21).toFixed(2) + 'Z';\n  } else if (absY >= 1e18) {\n    return (y / 1e18).toFixed(2) + 'E';\n  } else if (absY >= 1e15) {\n    return (y / 1e15).toFixed(2) + 'P';\n  } else if (absY >= 1e12) {\n    return (y / 1e12).toFixed(2) + 'T';\n  } else if (absY >= 1e9) {\n    return (y / 1e9).toFixed(2) + 'G';\n  } else if (absY >= 1e6) {\n    return (y / 1e6).toFixed(2) + 'M';\n  } else if (absY >= 1e3) {\n    return (y / 1e3).toFixed(2) + 'k';\n  } else if (absY >= 1) {\n    return y.toFixed(2);\n  } else if (absY === 0) {\n    return y.toFixed(2);\n  } else if (absY < 1e-23) {\n    return (y / 1e-24).toFixed(2) + 'y';\n  } else if (absY < 1e-20) {\n    return (y / 1e-21).toFixed(2) + 'z';\n  } else if (absY < 1e-17) {\n    return (y / 1e-18).toFixed(2) + 'a';\n  } else if (absY < 1e-14) {\n    return (y / 1e-15).toFixed(2) + 'f';\n  } else if (absY < 1e-11) {\n    return (y / 1e-12).toFixed(2) + 'p';\n  } else if (absY < 1e-8) {\n    return (y / 1e-9).toFixed(2) + 'n';\n  } else if (absY < 1e-5) {\n    return (y / 1e-6).toFixed(2) + 'µ';\n  } else if (absY < 1e-2) {\n    return (y / 1e-3).toFixed(2) + 'm';\n  } else if (absY <= 1) {\n    return y.toFixed(2);\n  }\n  throw Error(\"couldn't format a value, this is a bug\");\n};\n\nexport const getHoverColor = (color: string, opacity: number, stacked: boolean) => {\n  const { r, g, b } = $.color.parse(color);\n  if (!stacked) {\n    return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n  }\n  /*\n    Unfortunately flot doesn't take into consideration\n    the alpha value when adjusting the color on the stacked series.\n    TODO: find better way to set the opacity.\n  */\n  const base = (1 - opacity) * 255;\n  return `rgb(${Math.round(base + opacity * r)},${Math.round(base + opacity * g)},${Math.round(base + opacity * b)})`;\n};\n\nexport const toHoverColor = (index: number, stacked: boolean) => (series: GraphSeries, i: number) => ({\n  ...series,\n  color: getHoverColor(series.color, i !== index ? 0.3 : 1, stacked),\n});\n\nexport const getOptions = (stacked: boolean, useLocalTime: boolean): jquery.flot.plotOptions => {\n  return {\n    grid: {\n      hoverable: true,\n      clickable: true,\n      autoHighlight: true,\n      mouseActiveRadius: 100,\n    },\n    legend: {\n      show: false,\n    },\n    xaxis: {\n      mode: 'time',\n      showTicks: true,\n      showMinorTicks: true,\n      timeBase: 'milliseconds',\n      timezone: useLocalTime ? 'browser' : undefined,\n    },\n    yaxis: {\n      tickFormatter: formatValue,\n    },\n    crosshair: {\n      mode: 'xy',\n      color: '#bbb',\n    },\n    tooltip: {\n      show: true,\n      cssClass: 'graph-tooltip',\n      content: (_, xval, yval, { series }): string => {\n        const { labels, color } = series;\n        let dateTime = moment(xval);\n        if (!useLocalTime) {\n          dateTime = dateTime.utc();\n        }\n        return `\n            <div class=\"date\">${dateTime.format('YYYY-MM-DD HH:mm:ss Z')}</div>\n            <div>\n              <span class=\"detail-swatch\" style=\"background-color: ${color}\"></span>\n              <span>${labels.__name__ || 'value'}: <strong>${yval}</strong></span>\n            <div>\n            <div class=\"labels mt-1\">\n              ${Object.keys(labels)\n                .map(k =>\n                  k !== '__name__' ? `<div class=\"mb-1\"><strong>${k}</strong>: ${escapeHTML(labels[k])}</div>` : ''\n                )\n                .join('')}\n            </div>\n          `;\n      },\n      defaultTheme: false,\n      lines: true,\n    },\n    series: {\n      stack: stacked,\n      lines: {\n        lineWidth: stacked ? 1 : 2,\n        steps: false,\n        fill: stacked,\n      },\n      shadowSize: 0,\n    },\n  };\n};\n\n// This was adapted from Flot's color generation code.\nexport const getColors = (data: { resultType: string; result: Array<{ metric: Metric; values: [number, string][] }> }) => {\n  const colorPool = ['#edc240', '#afd8f8', '#cb4b4b', '#4da74d', '#9440ed'];\n  const colorPoolSize = colorPool.length;\n  let variation = 0;\n  return data.result.map((_, i) => {\n    // Each time we exhaust the colors in the pool we adjust\n    // a scaling factor used to produce more variations on\n    // those colors. The factor alternates negative/positive\n    // to produce lighter/darker colors.\n\n    // Reset the variation after every few cycles, or else\n    // it will end up producing only white or black colors.\n\n    if (i % colorPoolSize === 0 && i) {\n      if (variation >= 0) {\n        variation = variation < 0.5 ? -variation - 0.2 : 0;\n      } else {\n        variation = -variation;\n      }\n    }\n    return $.color.parse(colorPool[i % colorPoolSize] || '#666').scale('rgb', 1 + variation);\n  });\n};\n\nexport const normalizeData = ({ queryParams, data }: GraphProps): GraphSeries[] => {\n  const colors = getColors(data);\n  const { startTime, endTime, resolution } = queryParams!;\n  return data.result.map(({ values, metric }, index) => {\n    // Insert nulls for all missing steps.\n    const data = [];\n    let pos = 0;\n\n    for (let t = startTime; t <= endTime; t += resolution) {\n      // Allow for floating point inaccuracy.\n      const currentValue = values[pos];\n      if (values.length > pos && currentValue[0] < t + resolution / 100) {\n        data.push([currentValue[0] * 1000, parseValue(currentValue[1])]);\n        pos++;\n      } else {\n        data.push([t * 1000, null]);\n      }\n    }\n\n    return {\n      labels: metric !== null ? metric : {},\n      color: colors[index].toString(),\n      data,\n      index,\n    };\n  });\n};\n\nexport const parseValue = (value: string) => {\n  const val = parseFloat(value);\n  // \"+Inf\", \"-Inf\", \"+Inf\" will be parsed into NaN by parseFloat(). They\n  // can't be graphed, so show them as gaps (null).\n  return isNaN(val) ? null : val;\n};\n"]},"metadata":{},"sourceType":"module"}