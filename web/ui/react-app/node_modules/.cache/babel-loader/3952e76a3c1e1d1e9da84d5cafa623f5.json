{"ast":null,"code":"import _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _get from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nvar extend = \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(function (s) {\n  return s ? parseInt(s, 36) : 1;\n}); // Convert offsets into absolute values\n\nfor (var i = 1; i < extend.length; i++) {\n  extend[i] += extend[i - 1];\n}\n\nfunction isExtendingChar(code) {\n  for (var _i = 1; _i < extend.length; _i += 2) {\n    if (extend[_i] > code) return extend[_i - 1] <= code;\n  }\n\n  return false;\n}\n\nfunction isRegionalIndicator(code) {\n  return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\n\nvar ZWJ = 0x200d; /// Returns a next grapheme cluster break _after_ (not equal to)\n/// `pos`, if `forward` is true, or before otherwise. Returns `pos`\n/// itself if no further cluster break is available in the string.\n/// Moves across surrogate pairs, extending characters, characters\n/// joined with zero-width joiners, and flag emoji.\n\nfunction findClusterBreak(str, pos) {\n  var forward = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);\n}\n\nfunction nextClusterBreak(str, pos) {\n  if (pos == str.length) return pos; // If pos is in the middle of a surrogate pair, move to its start\n\n  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;\n  var prev = codePointAt(str, pos);\n  pos += codePointSize(prev);\n\n  while (pos < str.length) {\n    var next = codePointAt(str, pos);\n\n    if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {\n      pos += codePointSize(next);\n      prev = next;\n    } else if (isRegionalIndicator(next)) {\n      var countBefore = 0,\n          _i2 = pos - 2;\n\n      while (_i2 >= 0 && isRegionalIndicator(codePointAt(str, _i2))) {\n        countBefore++;\n        _i2 -= 2;\n      }\n\n      if (countBefore % 2 == 0) break;else pos += 2;\n    } else {\n      break;\n    }\n  }\n\n  return pos;\n}\n\nfunction prevClusterBreak(str, pos) {\n  while (pos > 0) {\n    var found = nextClusterBreak(str, pos - 2);\n    if (found < pos) return found;\n    pos--;\n  }\n\n  return 0;\n}\n\nfunction surrogateLow(ch) {\n  return ch >= 0xDC00 && ch < 0xE000;\n}\n\nfunction surrogateHigh(ch) {\n  return ch >= 0xD800 && ch < 0xDC00;\n} /// Find the code point at the given position in a string (like the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\n\n\nfunction codePointAt(str, pos) {\n  var code0 = str.charCodeAt(pos);\n  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n  var code1 = str.charCodeAt(pos + 1);\n  if (!surrogateLow(code1)) return code0;\n  return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n} /// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (like\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n\n\nfunction fromCodePoint(code) {\n  if (code <= 0xffff) return String.fromCharCode(code);\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n} /// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\n\n\nfunction codePointSize(code) {\n  return code < 0x10000 ? 1 : 2;\n} /// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\n\n\nfunction countColumn(string, n, tabSize) {\n  for (var _i3 = 0; _i3 < string.length;) {\n    if (string.charCodeAt(_i3) == 9) {\n      n += tabSize - n % tabSize;\n      _i3++;\n    } else {\n      n++;\n      _i3 = findClusterBreak(string, _i3);\n    }\n  }\n\n  return n;\n} /// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\n\n\nfunction findColumn(string, n, col, tabSize) {\n  for (var _i4 = 0; _i4 < string.length;) {\n    if (n >= col) return {\n      offset: _i4,\n      leftOver: 0\n    };\n    n += string.charCodeAt(_i4) == 9 ? tabSize - n % tabSize : 1;\n    _i4 = findClusterBreak(string, _i4);\n  }\n\n  return {\n    offset: string.length,\n    leftOver: col - n\n  };\n} /// The data structure for documents.\n\n\nvar Text = /*#__PURE__*/function () {\n  /// @internal\n  function Text() {\n    _classCallCheck(this, Text);\n  } /// Get the line description around the given position.\n\n\n  _createClass(Text, [{\n    key: \"lineAt\",\n    value: function lineAt(pos) {\n      if (pos < 0 || pos > this.length) throw new RangeError(\"Invalid position \".concat(pos, \" in document of length \").concat(this.length));\n      return this.lineInner(pos, false, 1, 0);\n    } /// Get the description for the given (1-based) line number.\n\n  }, {\n    key: \"line\",\n    value: function line(n) {\n      if (n < 1 || n > this.lines) throw new RangeError(\"Invalid line number \".concat(n, \" in \").concat(this.lines, \"-line document\"));\n      return this.lineInner(n, true, 1, 0);\n    } /// Replace a range of the text with the given content.\n\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, text) {\n      var parts = [];\n      this.decompose(0, from, parts, 2\n      /* To */\n      );\n      if (text.length) text.decompose(0, text.length, parts, 1\n      /* From */\n      | 2\n      /* To */\n      );\n      this.decompose(to, this.length, parts, 1\n      /* From */\n      );\n      return TextNode.from(parts, this.length - (to - from) + text.length);\n    } /// Append another document to this one.\n\n  }, {\n    key: \"append\",\n    value: function append(other) {\n      return this.replace(this.length, this.length, other);\n    } /// Retrieve the text between the given points.\n\n  }, {\n    key: \"slice\",\n    value: function slice(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;\n      var parts = [];\n      this.decompose(from, to, parts, 0);\n      return TextNode.from(parts, to - from);\n    } /// Test whether this text is equal to another instance.\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (other == this) return true;\n      if (other.length != this.length || other.lines != this.lines) return false;\n      var a = new RawTextCursor(this),\n          b = new RawTextCursor(other);\n\n      for (;;) {\n        a.next();\n        b.next();\n        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n        if (a.done) return true;\n      }\n    } /// Iterate over the text. When `dir` is `-1`, iteration happens\n    /// from end to start. This will return lines and the breaks between\n    /// them as separate strings, and for long lines, might split lines\n    /// themselves into multiple chunks as well.\n\n  }, {\n    key: \"iter\",\n    value: function iter() {\n      var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      return new RawTextCursor(this, dir);\n    } /// Iterate over a range of the text. When `from` > `to`, the\n    /// iterator will run in reverse.\n\n  }, {\n    key: \"iterRange\",\n    value: function iterRange(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;\n      return new PartialTextCursor(this, from, to);\n    } /// @internal\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.sliceString(0);\n    } /// Convert the document to an array of lines (which can be\n    /// deserialized again via [`Text.of`](#text.Text^of)).\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var lines = [];\n      this.flatten(lines);\n      return lines;\n    } /// Create a `Text` instance for the given array of lines.\n\n  }], [{\n    key: \"of\",\n    value: function of(text) {\n      if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n      if (text.length == 1 && !text[0]) return Text.empty;\n      return text.length <= 32\n      /* Branch */\n      ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n  }]);\n\n  return Text;\n}();\n\nif (typeof Symbol != \"undefined\") Text.prototype[Symbol.iterator] = function () {\n  return this.iter();\n}; // Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\n\nvar TextLeaf = /*#__PURE__*/function (_Text) {\n  _inherits(TextLeaf, _Text);\n\n  var _super = _createSuper(TextLeaf);\n\n  function TextLeaf(text) {\n    var _this;\n\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : textLength(text);\n\n    _classCallCheck(this, TextLeaf);\n\n    _this = _super.call(this);\n    _this.text = text;\n    _this.length = length;\n    return _this;\n  }\n\n  _createClass(TextLeaf, [{\n    key: \"lines\",\n    get: function get() {\n      return this.text.length;\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"lineInner\",\n    value: function lineInner(target, isLine, line, offset) {\n      for (var _i5 = 0;; _i5++) {\n        var string = this.text[_i5],\n            end = offset + string.length;\n        if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n        offset = end + 1;\n        line++;\n      }\n    }\n  }, {\n    key: \"decompose\",\n    value: function decompose(from, to, target, open) {\n      var text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n\n      if (open & 1\n      /* From */\n      ) {\n          var prev = target.pop();\n          var joined = appendText(text.text, prev.text.slice(), 0, text.length);\n\n          if (joined.length <= 32\n          /* Branch */\n          ) {\n              target.push(new TextLeaf(joined, prev.length + text.length));\n            } else {\n            var mid = joined.length >> 1;\n            target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n          }\n        } else {\n        target.push(text);\n      }\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, text) {\n      if (!(text instanceof TextLeaf)) return _get(_getPrototypeOf(TextLeaf.prototype), \"replace\", this).call(this, from, to, text);\n      var lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n      var newLen = this.length + text.length - (to - from);\n      if (lines.length <= 32\n      /* Branch */\n      ) return new TextLeaf(lines, newLen);\n      return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n  }, {\n    key: \"sliceString\",\n    value: function sliceString(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;\n      var lineSep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\\n\";\n      var result = \"\";\n\n      for (var pos = 0, _i6 = 0; pos <= to && _i6 < this.text.length; _i6++) {\n        var line = this.text[_i6],\n            end = pos + line.length;\n        if (pos > from && _i6) result += lineSep;\n        if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n        pos = end + 1;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"flatten\",\n    value: function flatten(target) {\n      var _iterator = _createForOfIteratorHelper(this.text),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n          target.push(line);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }], [{\n    key: \"split\",\n    value: function split(text, target) {\n      var part = [],\n          len = -1;\n\n      var _iterator2 = _createForOfIteratorHelper(text),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var line = _step2.value;\n          part.push(line);\n          len += line.length + 1;\n\n          if (part.length == 32\n          /* Branch */\n          ) {\n              target.push(new TextLeaf(part, len));\n              part = [];\n              len = -1;\n            }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (len > -1) target.push(new TextLeaf(part, len));\n      return target;\n    }\n  }]);\n\n  return TextLeaf;\n}(Text); // Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\n\n\nvar TextNode = /*#__PURE__*/function (_Text2) {\n  _inherits(TextNode, _Text2);\n\n  var _super2 = _createSuper(TextNode);\n\n  function TextNode(children, length) {\n    var _this2;\n\n    _classCallCheck(this, TextNode);\n\n    _this2 = _super2.call(this);\n    _this2.children = children;\n    _this2.length = length;\n    _this2.lines = 0;\n\n    var _iterator3 = _createForOfIteratorHelper(children),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var child = _step3.value;\n        _this2.lines += child.lines;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return _this2;\n  }\n\n  _createClass(TextNode, [{\n    key: \"lineInner\",\n    value: function lineInner(target, isLine, line, offset) {\n      for (var _i7 = 0;; _i7++) {\n        var child = this.children[_i7],\n            end = offset + child.length,\n            endLine = line + child.lines - 1;\n        if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n        offset = end + 1;\n        line = endLine + 1;\n      }\n    }\n  }, {\n    key: \"decompose\",\n    value: function decompose(from, to, target, open) {\n      for (var _i8 = 0, pos = 0; pos <= to && _i8 < this.children.length; _i8++) {\n        var child = this.children[_i8],\n            end = pos + child.length;\n\n        if (from <= end && to >= pos) {\n          var childOpen = open & ((pos <= from ? 1\n          /* From */\n          : 0) | (end >= to ? 2\n          /* To */\n          : 0));\n          if (pos >= from && end <= to && !childOpen) target.push(child);else child.decompose(from - pos, to - pos, target, childOpen);\n        }\n\n        pos = end + 1;\n      }\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, text) {\n      if (text.lines < this.lines) for (var _i9 = 0, pos = 0; _i9 < this.children.length; _i9++) {\n        var child = this.children[_i9],\n            end = pos + child.length; // Fast path: if the change only affects one child and the\n        // child's size remains in the acceptable range, only update\n        // that child\n\n        if (from >= pos && to <= end) {\n          var updated = child.replace(from - pos, to - pos, text);\n          var totalLines = this.lines - child.lines + updated.lines;\n\n          if (updated.lines < totalLines >> 5\n          /* BranchShift */\n          - 1 && updated.lines > totalLines >> 5\n          /* BranchShift */\n          + 1) {\n            var copy = this.children.slice();\n            copy[_i9] = updated;\n            return new TextNode(copy, this.length - (to - from) + text.length);\n          }\n\n          return _get(_getPrototypeOf(TextNode.prototype), \"replace\", this).call(this, pos, end, updated);\n        }\n\n        pos = end + 1;\n      }\n      return _get(_getPrototypeOf(TextNode.prototype), \"replace\", this).call(this, from, to, text);\n    }\n  }, {\n    key: \"sliceString\",\n    value: function sliceString(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;\n      var lineSep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\\n\";\n      var result = \"\";\n\n      for (var _i10 = 0, pos = 0; _i10 < this.children.length && pos <= to; _i10++) {\n        var child = this.children[_i10],\n            end = pos + child.length;\n        if (pos > from && _i10) result += lineSep;\n        if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n        pos = end + 1;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"flatten\",\n    value: function flatten(target) {\n      var _iterator4 = _createForOfIteratorHelper(this.children),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var child = _step4.value;\n          child.flatten(target);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }], [{\n    key: \"from\",\n    value: function from(children) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : children.reduce(function (l, ch) {\n        return l + ch.length + 1;\n      }, -1);\n      var lines = 0;\n\n      var _iterator5 = _createForOfIteratorHelper(children),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _ch = _step5.value;\n          lines += _ch.lines;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      if (lines < 32\n      /* Branch */\n      ) {\n          var flat = [];\n\n          var _iterator6 = _createForOfIteratorHelper(children),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var ch = _step6.value;\n              ch.flatten(flat);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          return new TextLeaf(flat, length);\n        }\n\n      var chunk = Math.max(32\n      /* Branch */\n      , lines >> 5\n      /* BranchShift */\n      ),\n          maxChunk = chunk << 1,\n          minChunk = chunk >> 1;\n      var chunked = [],\n          currentLines = 0,\n          currentLen = -1,\n          currentChunk = [];\n\n      function add(child) {\n        var last;\n\n        if (child.lines > maxChunk && child instanceof TextNode) {\n          var _iterator7 = _createForOfIteratorHelper(child.children),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var node = _step7.value;\n              add(node);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n          flush();\n          chunked.push(child);\n        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32\n        /* Branch */\n        ) {\n            currentLines += child.lines;\n            currentLen += child.length + 1;\n            currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n          } else {\n          if (currentLines + child.lines > chunk) flush();\n          currentLines += child.lines;\n          currentLen += child.length + 1;\n          currentChunk.push(child);\n        }\n      }\n\n      function flush() {\n        if (currentLines == 0) return;\n        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n        currentLen = -1;\n        currentLines = currentChunk.length = 0;\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(children),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var child = _step8.value;\n          add(child);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      flush();\n      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n  }]);\n\n  return TextNode;\n}(Text);\n\nText.empty = new TextLeaf([\"\"], 0);\n\nfunction textLength(text) {\n  var length = -1;\n\n  var _iterator9 = _createForOfIteratorHelper(text),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var line = _step9.value;\n      length += line.length + 1;\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return length;\n}\n\nfunction appendText(text, target) {\n  var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e9;\n\n  for (var pos = 0, _i11 = 0, first = true; _i11 < text.length && pos <= to; _i11++) {\n    var line = text[_i11],\n        end = pos + line.length;\n\n    if (end >= from) {\n      if (end > to) line = line.slice(0, to - pos);\n      if (pos < from) line = line.slice(from - pos);\n\n      if (first) {\n        target[target.length - 1] += line;\n        first = false;\n      } else target.push(line);\n    }\n\n    pos = end + 1;\n  }\n\n  return target;\n}\n\nfunction sliceText(text, from, to) {\n  return appendText(text, [\"\"], from, to);\n}\n\nvar RawTextCursor = /*#__PURE__*/function () {\n  function RawTextCursor(text) {\n    var dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, RawTextCursor);\n\n    this.dir = dir;\n    this.done = false;\n    this.lineBreak = false;\n    this.value = \"\";\n    this.nodes = [text];\n    this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n  }\n\n  _createClass(RawTextCursor, [{\n    key: \"next\",\n    value: function next() {\n      var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      for (;;) {\n        var last = this.nodes.length - 1;\n\n        if (last < 0) {\n          this.done = true;\n          this.value = \"\";\n          this.lineBreak = false;\n          return this;\n        }\n\n        var top = this.nodes[last],\n            offset = this.offsets[last];\n        var size = top instanceof TextLeaf ? top.text.length : top.children.length;\n\n        if (offset == (this.dir > 0 ? size : 0)) {\n          this.nodes.pop();\n          this.offsets.pop();\n        } else if (!this.lineBreak && offset != (this.dir > 0 ? 0 : size)) {\n          // Internal offset with lineBreak == false means we have to\n          // count the line break at this position\n          this.lineBreak = true;\n\n          if (skip == 0) {\n            this.value = \"\\n\";\n            return this;\n          }\n\n          skip--;\n        } else if (top instanceof TextLeaf) {\n          // Move to the next string\n          var next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n          this.offsets[last] = offset += this.dir;\n          this.lineBreak = false;\n\n          if (next.length > Math.max(0, skip)) {\n            this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n            return this;\n          }\n\n          skip -= next.length;\n        } else {\n          var _next = top.children[this.dir > 0 ? offset : offset - 1];\n          this.offsets[last] = offset + this.dir;\n          this.lineBreak = false;\n\n          if (skip > _next.length) {\n            skip -= _next.length;\n          } else {\n            this.nodes.push(_next);\n            this.offsets.push(this.dir > 0 ? 0 : _next instanceof TextLeaf ? _next.text.length : _next.children.length);\n          }\n        }\n      }\n    }\n  }]);\n\n  return RawTextCursor;\n}();\n\nvar PartialTextCursor = /*#__PURE__*/function () {\n  function PartialTextCursor(text, start, end) {\n    _classCallCheck(this, PartialTextCursor);\n\n    this.value = \"\";\n    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n\n    if (start > end) {\n      this.skip = text.length - start;\n      this.limit = start - end;\n    } else {\n      this.skip = start;\n      this.limit = end - start;\n    }\n  }\n\n  _createClass(PartialTextCursor, [{\n    key: \"next\",\n    value: function next() {\n      var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (this.limit <= 0) {\n        this.limit = -1;\n      } else {\n        var _this$cursor$next = this.cursor.next(this.skip + skip),\n            value = _this$cursor$next.value,\n            lineBreak = _this$cursor$next.lineBreak,\n            done = _this$cursor$next.done;\n\n        this.skip = 0;\n        this.value = value;\n        var len = lineBreak ? 1 : value.length;\n        if (len > this.limit) this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n        if (done || this.value.length == 0) this.limit = -1;else this.limit -= this.value.length;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"lineBreak\",\n    get: function get() {\n      return this.cursor.lineBreak;\n    }\n  }, {\n    key: \"done\",\n    get: function get() {\n      return this.limit < 0;\n    }\n  }]);\n\n  return PartialTextCursor;\n}(); /// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\n\n\nvar Line = /*#__PURE__*/function () {\n  /// @internal\n  function Line( /// The position of the start of the line.\n  from, /// The position at the end of the line (_before_ the line break,\n  /// or at the end of document for the last line).\n  to, /// This line's line number (1-based).\n  number, /// The line's content.\n  text) {\n    _classCallCheck(this, Line);\n\n    this.from = from;\n    this.to = to;\n    this.number = number;\n    this.text = text;\n  } /// The length of the line (not including any line break after it).\n\n\n  _createClass(Line, [{\n    key: \"length\",\n    get: function get() {\n      return this.to - this.from;\n    }\n  }]);\n\n  return Line;\n}();\n\nexport { Line, Text, codePointAt, codePointSize, countColumn, findClusterBreak, findColumn, fromCodePoint };","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/@codemirror/text/dist/index.js"],"names":["extend","split","map","s","parseInt","i","length","isExtendingChar","code","isRegionalIndicator","ZWJ","findClusterBreak","str","pos","forward","nextClusterBreak","prevClusterBreak","surrogateLow","charCodeAt","surrogateHigh","prev","codePointAt","codePointSize","next","countBefore","found","ch","code0","code1","fromCodePoint","String","fromCharCode","countColumn","string","n","tabSize","findColumn","col","offset","leftOver","Text","RangeError","lineInner","lines","from","to","text","parts","decompose","TextNode","other","replace","a","RawTextCursor","b","lineBreak","done","value","dir","PartialTextCursor","sliceString","flatten","empty","TextLeaf","Symbol","prototype","iterator","iter","textLength","target","isLine","line","end","Line","open","sliceText","Math","min","max","pop","joined","appendText","slice","push","mid","newLen","lineSep","result","part","len","children","child","endLine","childOpen","updated","totalLines","copy","reduce","l","flat","chunk","maxChunk","minChunk","chunked","currentLines","currentLen","currentChunk","add","last","node","flush","concat","first","nodes","offsets","skip","top","size","start","cursor","limit","number"],"mappings":"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","sourcesContent":["// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor (let i = 1; i < extend.length; i++)\n    extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n    for (let i = 1; i < extend.length; i += 2)\n        if (extend[i] > code)\n            return extend[i - 1] <= code;\n    return false;\n}\nfunction isRegionalIndicator(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/// Returns a next grapheme cluster break _after_ (not equal to)\n/// `pos`, if `forward` is true, or before otherwise. Returns `pos`\n/// itself if no further cluster break is available in the string.\n/// Moves across surrogate pairs, extending characters, characters\n/// joined with zero-width joiners, and flag emoji.\nfunction findClusterBreak(str, pos, forward = true) {\n    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);\n}\nfunction nextClusterBreak(str, pos) {\n    if (pos == str.length)\n        return pos;\n    // If pos is in the middle of a surrogate pair, move to its start\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))\n        pos--;\n    let prev = codePointAt(str, pos);\n    pos += codePointSize(prev);\n    while (pos < str.length) {\n        let next = codePointAt(str, pos);\n        if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {\n            pos += codePointSize(next);\n            prev = next;\n        }\n        else if (isRegionalIndicator(next)) {\n            let countBefore = 0, i = pos - 2;\n            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n                countBefore++;\n                i -= 2;\n            }\n            if (countBefore % 2 == 0)\n                break;\n            else\n                pos += 2;\n        }\n        else {\n            break;\n        }\n    }\n    return pos;\n}\nfunction prevClusterBreak(str, pos) {\n    while (pos > 0) {\n        let found = nextClusterBreak(str, pos - 2);\n        if (found < pos)\n            return found;\n        pos--;\n    }\n    return 0;\n}\nfunction surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }\nfunction surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }\n/// Find the code point at the given position in a string (like the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1))\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (like\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\nfunction codePointSize(code) { return code < 0x10000 ? 1 : 2; }\n\n/// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\nfunction countColumn(string, n, tabSize) {\n    for (let i = 0; i < string.length;) {\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - (n % tabSize);\n            i++;\n        }\n        else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\nfunction findColumn(string, n, col, tabSize) {\n    for (let i = 0; i < string.length;) {\n        if (n >= col)\n            return { offset: i, leftOver: 0 };\n        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;\n        i = findClusterBreak(string, i);\n    }\n    return { offset: string.length, leftOver: col - n };\n}\n\n/// The data structure for documents.\nclass Text {\n    /// @internal\n    constructor() { }\n    /// Get the line description around the given position.\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /// Get the description for the given (1-based) line number.\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /// Replace a range of the text with the given content.\n    replace(from, to, text) {\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* To */);\n        if (text.length)\n            text.decompose(0, text.length, parts, 1 /* From */ | 2 /* To */);\n        this.decompose(to, this.length, parts, 1 /* From */);\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /// Append another document to this one.\n    append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /// Retrieve the text between the given points.\n    slice(from, to = this.length) {\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /// Test whether this text is equal to another instance.\n    eq(other) {\n        if (other == this)\n            return true;\n        if (other.length != this.length || other.lines != this.lines)\n            return false;\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for (;;) {\n            a.next();\n            b.next();\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)\n                return false;\n            if (a.done)\n                return true;\n        }\n    }\n    /// Iterate over the text. When `dir` is `-1`, iteration happens\n    /// from end to start. This will return lines and the breaks between\n    /// them as separate strings, and for long lines, might split lines\n    /// themselves into multiple chunks as well.\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /// Iterate over a range of the text. When `from` > `to`, the\n    /// iterator will run in reverse.\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /// @internal\n    toString() { return this.sliceString(0); }\n    /// Convert the document to an array of lines (which can be\n    /// deserialized again via [`Text.of`](#text.Text^of)).\n    toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /// Create a `Text` instance for the given array of lines.\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0])\n            return Text.empty;\n        return text.length <= 32 /* Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\nif (typeof Symbol != \"undefined\")\n    Text.prototype[Symbol.iterator] = function () { return this.iter(); };\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this\n            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* From */) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Branch */) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            }\n            else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        }\n        else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf))\n            return super.replace(from, to, text);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Branch */)\n            return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)\n            target.push(line);\n    }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text) {\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Branch */) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1)\n            target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)\n            this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target)\n                return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* From */ : 0) | (end >= to ? 2 /* To */ : 0));\n                if (pos >= from && end <= to && !childOpen)\n                    target.push(child);\n                else\n                    child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        if (text.lines < this.lines)\n            for (let i = 0, pos = 0; i < this.children.length; i++) {\n                let child = this.children[i], end = pos + child.length;\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                if (from >= pos && to <= end) {\n                    let updated = child.replace(from - pos, to - pos, text);\n                    let totalLines = this.lines - child.lines + updated.lines;\n                    if (updated.lines < (totalLines >> (5 /* BranchShift */ - 1)) &&\n                        updated.lines > (totalLines >> (5 /* BranchShift */ + 1))) {\n                        let copy = this.children.slice();\n                        copy[i] = updated;\n                        return new TextNode(copy, this.length - (to - from) + text.length);\n                    }\n                    return super.replace(pos, end, updated);\n                }\n                pos = end + 1;\n            }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)\n            child.flatten(target);\n    }\n    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)\n            lines += ch.lines;\n        if (lines < 32 /* Branch */) {\n            let flat = [];\n            for (let ch of children)\n                ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Branch */, lines >> 5 /* BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLines &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.lines + last.lines <= 32 /* Branch */) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            }\n            else {\n                if (currentLines + child.lines > chunk)\n                    flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n    }\n    next(skip = 0) {\n        for (;;) {\n            let last = this.nodes.length - 1;\n            if (last < 0) {\n                this.done = true;\n                this.value = \"\";\n                this.lineBreak = false;\n                return this;\n            }\n            let top = this.nodes[last], offset = this.offsets[last];\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (this.dir > 0 ? size : 0)) {\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else if (!this.lineBreak && offset != (this.dir > 0 ? 0 : size)) {\n                // Internal offset with lineBreak == false means we have to\n                // count the line break at this position\n                this.lineBreak = true;\n                if (skip == 0) {\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            }\n            else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n                this.offsets[last] = (offset += this.dir);\n                this.lineBreak = false;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else {\n                let next = top.children[this.dir > 0 ? offset : offset - 1];\n                this.offsets[last] = offset + this.dir;\n                this.lineBreak = false;\n                if (skip > next.length) {\n                    skip -= next.length;\n                }\n                else {\n                    this.nodes.push(next);\n                    this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);\n                }\n            }\n        }\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        if (start > end) {\n            this.skip = text.length - start;\n            this.limit = start - end;\n        }\n        else {\n            this.skip = start;\n            this.limit = end - start;\n        }\n    }\n    next(skip = 0) {\n        if (this.limit <= 0) {\n            this.limit = -1;\n        }\n        else {\n            let { value, lineBreak, done } = this.cursor.next(this.skip + skip);\n            this.skip = 0;\n            this.value = value;\n            let len = lineBreak ? 1 : value.length;\n            if (len > this.limit)\n                this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n            if (done || this.value.length == 0)\n                this.limit = -1;\n            else\n                this.limit -= this.value.length;\n        }\n        return this;\n    }\n    get lineBreak() { return this.cursor.lineBreak; }\n    get done() { return this.limit < 0; }\n}\n/// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\nclass Line {\n    /// @internal\n    constructor(\n    /// The position of the start of the line.\n    from, \n    /// The position at the end of the line (_before_ the line break,\n    /// or at the end of document for the last line).\n    to, \n    /// This line's line number (1-based).\n    number, \n    /// The line's content.\n    text) {\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /// The length of the line (not including any line break after it).\n    get length() { return this.to - this.from; }\n}\n\nexport { Line, Text, codePointAt, codePointSize, countColumn, findClusterBreak, findColumn, fromCodePoint };\n"]},"metadata":{},"sourceType":"module"}