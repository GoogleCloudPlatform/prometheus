{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;\n\nvar xml_json_1 = __importDefault(require(\"./maps/xml.json\"));\n\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\n\nexports.encodeXML = getASCIIEncoder(inverseXML);\n\nvar entities_json_1 = __importDefault(require(\"./maps/entities.json\"));\n\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\n\nexports.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\n\nexports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\n\nfunction getInverseObj(obj) {\n  return Object.keys(obj).sort().reduce(function (inverse, name) {\n    inverse[obj[name]] = \"&\" + name + \";\";\n    return inverse;\n  }, {});\n}\n\nfunction getInverseReplacer(inverse) {\n  var single = [];\n  var multiple = [];\n\n  for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n    var k = _a[_i];\n\n    if (k.length === 1) {\n      // Add value to single array\n      single.push(\"\\\\\" + k);\n    } else {\n      // Add value to multiple array\n      multiple.push(k);\n    }\n  } // Add ranges to single characters.\n\n\n  single.sort();\n\n  for (var start = 0; start < single.length - 1; start++) {\n    // Find the end of a run of characters\n    var end = start;\n\n    while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n      end += 1;\n    }\n\n    var count = 1 + end - start; // We want to replace at least three characters\n\n    if (count < 3) continue;\n    single.splice(start, count, single[start] + \"-\" + single[end]);\n  }\n\n  multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n  return new RegExp(multiple.join(\"|\"), \"g\");\n} // /[^\\0-\\x7F]/gu\n\n\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\nfunction (str) {\n  return str.codePointAt(0);\n} : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\nfunction (c) {\n  return (c.charCodeAt(0) - 0xd800) * 0x400 + c.charCodeAt(1) - 0xdc00 + 0x10000;\n};\n\nfunction singleCharReplacer(c) {\n  return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + \";\";\n}\n\nfunction getInverse(inverse, re) {\n  return function (data) {\n    return data.replace(re, function (name) {\n      return inverse[name];\n    }).replace(reNonASCII, singleCharReplacer);\n  };\n}\n\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\n\nfunction escape(data) {\n  return data.replace(reEscapeChars, singleCharReplacer);\n}\n\nexports.escape = escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\n\nfunction escapeUTF8(data) {\n  return data.replace(xmlReplacer, singleCharReplacer);\n}\n\nexports.escapeUTF8 = escapeUTF8;\n\nfunction getASCIIEncoder(obj) {\n  return function (data) {\n    return data.replace(reEscapeChars, function (c) {\n      return obj[c] || singleCharReplacer(c);\n    });\n  };\n}","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/entities/lib/encode.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","escapeUTF8","escape","encodeNonAsciiHTML","encodeHTML","encodeXML","xml_json_1","require","inverseXML","getInverseObj","default","xmlReplacer","getInverseReplacer","getASCIIEncoder","entities_json_1","inverseHTML","htmlReplacer","getInverse","obj","keys","sort","reduce","inverse","name","single","multiple","_i","_a","length","k","push","start","end","charCodeAt","count","splice","unshift","join","RegExp","reNonASCII","getCodePoint","String","prototype","codePointAt","str","c","singleCharReplacer","toString","toUpperCase","re","data","replace","reEscapeChars","source"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;\nvar xml_json_1 = __importDefault(require(\"./maps/xml.json\"));\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = __importDefault(require(\"./maps/entities.json\"));\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nexports.escape = escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nexports.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n"]},"metadata":{},"sourceType":"script"}