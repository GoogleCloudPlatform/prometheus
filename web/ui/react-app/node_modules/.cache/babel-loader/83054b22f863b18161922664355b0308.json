{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retrieveAllRecursiveNodes = exports.containsChild = exports.containsAtLeastOneChild = exports.walkThrough = exports.walkBackward = void 0; // walkBackward will iterate other the tree from the leaf to the root until it founds the given `exit` node.\n// It returns null if the exit is not found.\n\nfunction walkBackward(node, exit) {\n  var cursor = node.cursor;\n  var cursorIsMoving = true;\n\n  while (cursorIsMoving && cursor.type.id !== exit) {\n    cursorIsMoving = cursor.parent();\n  }\n\n  return cursor.type.id === exit ? cursor.node : null;\n}\n\nexports.walkBackward = walkBackward; // walkThrough is going to follow the path passed in parameter.\n// If it succeeds to reach the last id/name of the path, then it will return the corresponding Subtree.\n// Otherwise if it's not possible to reach the last id/name of the path, it will return `null`\n// Note: the way followed during the iteration of the tree to find the given path, is only from the root to the leaf.\n\nfunction walkThrough(node) {\n  var path = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    path[_i - 1] = arguments[_i];\n  }\n\n  var cursor = node.cursor;\n  var i = 0;\n  var cursorIsMoving = true;\n  path.unshift(cursor.type.id);\n\n  while (i < path.length && cursorIsMoving) {\n    if (cursor.type.id === path[i] || cursor.type.name === path[i]) {\n      i++;\n\n      if (i < path.length) {\n        cursorIsMoving = cursor.next();\n      }\n    } else {\n      cursorIsMoving = cursor.nextSibling();\n    }\n  }\n\n  if (i >= path.length) {\n    return cursor.node;\n  }\n\n  return null;\n}\n\nexports.walkThrough = walkThrough;\n\nfunction containsAtLeastOneChild(node) {\n  var child = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    child[_i - 1] = arguments[_i];\n  }\n\n  var cursor = node.cursor;\n\n  if (!cursor.next()) {\n    // let's try to move directly to the children level and\n    // return false immediately if the current node doesn't have any child\n    return false;\n  }\n\n  var result = false;\n\n  do {\n    result = child.some(function (n) {\n      return cursor.type.id === n || cursor.type.name === n;\n    });\n  } while (!result && cursor.nextSibling());\n\n  return result;\n}\n\nexports.containsAtLeastOneChild = containsAtLeastOneChild;\n\nfunction containsChild(node) {\n  var child = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    child[_i - 1] = arguments[_i];\n  }\n\n  var cursor = node.cursor;\n\n  if (!cursor.next()) {\n    // let's try to move directly to the children level and\n    // return false immediately if the current node doesn't have any child\n    return false;\n  }\n\n  var i = 0;\n\n  do {\n    if (cursor.type.id === child[i] || cursor.type.name === child[i]) {\n      i++;\n    }\n  } while (i < child.length && cursor.nextSibling());\n\n  return i >= child.length;\n}\n\nexports.containsChild = containsChild;\n\nfunction retrieveAllRecursiveNodes(parentNode, recursiveNode, leaf) {\n  var nodes = [];\n\n  function recursiveRetrieveNode(node, nodes) {\n    var subNode = node === null || node === void 0 ? void 0 : node.getChild(recursiveNode);\n    var le = node === null || node === void 0 ? void 0 : node.lastChild;\n\n    if (subNode && subNode.type.id === recursiveNode) {\n      recursiveRetrieveNode(subNode, nodes);\n    }\n\n    if (le && le.type.id === leaf) {\n      nodes.push(le);\n    }\n  }\n\n  recursiveRetrieveNode(parentNode, nodes);\n  return nodes;\n}\n\nexports.retrieveAllRecursiveNodes = retrieveAllRecursiveNodes;","map":{"version":3,"sources":["../../../src/lang-promql/parser/path-finder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.retrieveAllRecursiveNodes = exports.containsChild = exports.containsAtLeastOneChild = exports.walkThrough = exports.walkBackward = void 0;\n// walkBackward will iterate other the tree from the leaf to the root until it founds the given `exit` node.\n// It returns null if the exit is not found.\nfunction walkBackward(node, exit) {\n    var cursor = node.cursor;\n    var cursorIsMoving = true;\n    while (cursorIsMoving && cursor.type.id !== exit) {\n        cursorIsMoving = cursor.parent();\n    }\n    return cursor.type.id === exit ? cursor.node : null;\n}\nexports.walkBackward = walkBackward;\n// walkThrough is going to follow the path passed in parameter.\n// If it succeeds to reach the last id/name of the path, then it will return the corresponding Subtree.\n// Otherwise if it's not possible to reach the last id/name of the path, it will return `null`\n// Note: the way followed during the iteration of the tree to find the given path, is only from the root to the leaf.\nfunction walkThrough(node) {\n    var path = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        path[_i - 1] = arguments[_i];\n    }\n    var cursor = node.cursor;\n    var i = 0;\n    var cursorIsMoving = true;\n    path.unshift(cursor.type.id);\n    while (i < path.length && cursorIsMoving) {\n        if (cursor.type.id === path[i] || cursor.type.name === path[i]) {\n            i++;\n            if (i < path.length) {\n                cursorIsMoving = cursor.next();\n            }\n        }\n        else {\n            cursorIsMoving = cursor.nextSibling();\n        }\n    }\n    if (i >= path.length) {\n        return cursor.node;\n    }\n    return null;\n}\nexports.walkThrough = walkThrough;\nfunction containsAtLeastOneChild(node) {\n    var child = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        child[_i - 1] = arguments[_i];\n    }\n    var cursor = node.cursor;\n    if (!cursor.next()) {\n        // let's try to move directly to the children level and\n        // return false immediately if the current node doesn't have any child\n        return false;\n    }\n    var result = false;\n    do {\n        result = child.some(function (n) { return cursor.type.id === n || cursor.type.name === n; });\n    } while (!result && cursor.nextSibling());\n    return result;\n}\nexports.containsAtLeastOneChild = containsAtLeastOneChild;\nfunction containsChild(node) {\n    var child = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        child[_i - 1] = arguments[_i];\n    }\n    var cursor = node.cursor;\n    if (!cursor.next()) {\n        // let's try to move directly to the children level and\n        // return false immediately if the current node doesn't have any child\n        return false;\n    }\n    var i = 0;\n    do {\n        if (cursor.type.id === child[i] || cursor.type.name === child[i]) {\n            i++;\n        }\n    } while (i < child.length && cursor.nextSibling());\n    return i >= child.length;\n}\nexports.containsChild = containsChild;\nfunction retrieveAllRecursiveNodes(parentNode, recursiveNode, leaf) {\n    var nodes = [];\n    function recursiveRetrieveNode(node, nodes) {\n        var subNode = node === null || node === void 0 ? void 0 : node.getChild(recursiveNode);\n        var le = node === null || node === void 0 ? void 0 : node.lastChild;\n        if (subNode && subNode.type.id === recursiveNode) {\n            recursiveRetrieveNode(subNode, nodes);\n        }\n        if (le && le.type.id === leaf) {\n            nodes.push(le);\n        }\n    }\n    recursiveRetrieveNode(parentNode, nodes);\n    return nodes;\n}\nexports.retrieveAllRecursiveNodes = retrieveAllRecursiveNodes;\n//# sourceMappingURL=path-finder.js.map"]},"metadata":{},"sourceType":"script"}