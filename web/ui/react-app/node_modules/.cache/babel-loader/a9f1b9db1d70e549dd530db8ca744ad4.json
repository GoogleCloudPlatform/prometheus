{"ast":null,"code":"// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { snippet } from '@codemirror/autocomplete';\nexport var durationTerms = [{\n  label: 'y'\n}, {\n  label: 'w'\n}, {\n  label: 'd'\n}, {\n  label: 'h'\n}, {\n  label: 'm'\n}, {\n  label: 's'\n}, {\n  label: 'ms'\n}];\nexport var matchOpTerms = [{\n  label: '='\n}, {\n  label: '!='\n}, {\n  label: '=~'\n}, {\n  label: '!~'\n}];\nexport var binOpTerms = [{\n  label: '^'\n}, {\n  label: '*'\n}, {\n  label: '/'\n}, {\n  label: '%'\n}, {\n  label: '+'\n}, {\n  label: '-'\n}, {\n  label: '=='\n}, {\n  label: '>='\n}, {\n  label: '>'\n}, {\n  label: '<'\n}, {\n  label: '<='\n}, {\n  label: '!='\n}, {\n  label: 'and'\n}, {\n  label: 'or'\n}, {\n  label: 'unless'\n}];\nexport var binOpModifierTerms = [{\n  label: 'on',\n  info: 'Match only on specified labels',\n  type: 'keyword'\n}, {\n  label: 'ignoring',\n  info: 'Ignore specified labels for matching',\n  type: 'keyword'\n}, {\n  label: 'group_left',\n  info: 'Allow many-to-one matching',\n  type: 'keyword'\n}, {\n  label: 'group_right',\n  info: 'Allow one-to-many matching',\n  type: 'keyword'\n}];\nexport var atModifierTerms = [{\n  label: 'start()',\n  info: 'resolve to the start of the query',\n  type: 'keyword'\n}, {\n  label: 'end()',\n  info: 'resolve to the end of the query',\n  type: 'keyword'\n}];\nexport var functionIdentifierTerms = [{\n  label: 'abs',\n  detail: 'function',\n  info: 'Return absolute values of input series',\n  type: 'function'\n}, {\n  label: 'absent',\n  detail: 'function',\n  info: 'Determine whether input vector is empty',\n  type: 'function'\n}, {\n  label: 'absent_over_time',\n  detail: 'function',\n  info: 'Determine whether input range vector is empty',\n  type: 'function'\n}, {\n  label: 'avg_over_time',\n  detail: 'function',\n  info: 'Average series values over time',\n  type: 'function'\n}, {\n  label: 'ceil',\n  detail: 'function',\n  info: 'Round up values of input series to nearest integer',\n  type: 'function'\n}, {\n  label: 'changes',\n  detail: 'function',\n  info: 'Return number of value changes in input series over time',\n  type: 'function'\n}, {\n  label: 'clamp',\n  detail: 'function',\n  info: 'Limit the value of input series between a minimum and a maximum',\n  type: 'function'\n}, {\n  label: 'clamp_max',\n  detail: 'function',\n  info: 'Limit the value of input series to a maximum',\n  type: 'function'\n}, {\n  label: 'clamp_min',\n  detail: 'function',\n  info: 'Limit the value of input series to a minimum',\n  type: 'function'\n}, {\n  label: 'count_over_time',\n  detail: 'function',\n  info: 'Count the number of values for each input series',\n  type: 'function'\n}, {\n  label: 'days_in_month',\n  detail: 'function',\n  info: 'Return the number of days in current month for provided timestamps',\n  type: 'function'\n}, {\n  label: 'day_of_month',\n  detail: 'function',\n  info: 'Return the day of the month for provided timestamps',\n  type: 'function'\n}, {\n  label: 'day_of_week',\n  detail: 'function',\n  info: 'Return the day of the week for provided timestamps',\n  type: 'function'\n}, {\n  label: 'delta',\n  detail: 'function',\n  info: 'Calculate the difference between beginning and end of a range vector (for gauges)',\n  type: 'function'\n}, {\n  label: 'deriv',\n  detail: 'function',\n  info: 'Calculate the per-second derivative over series in a range vector (for gauges)',\n  type: 'function'\n}, {\n  label: 'exp',\n  detail: 'function',\n  info: 'Calculate exponential function for input vector values',\n  type: 'function'\n}, {\n  label: 'floor',\n  detail: 'function',\n  info: 'Round down values of input series to nearest integer',\n  type: 'function'\n}, {\n  label: 'histogram_quantile',\n  detail: 'function',\n  info: 'Calculate quantiles from histogram buckets',\n  type: 'function'\n}, {\n  label: 'holt_winters',\n  detail: 'function',\n  info: 'Calculate smoothed value of input series',\n  type: 'function'\n}, {\n  label: 'hour',\n  detail: 'function',\n  info: 'Return the hour of the day for provided timestamps',\n  type: 'function'\n}, {\n  label: 'idelta',\n  detail: 'function',\n  info: 'Calculate the difference between the last two samples of a range vector (for counters)',\n  type: 'function'\n}, {\n  label: 'increase',\n  detail: 'function',\n  info: 'Calculate the increase in value over a range of time (for counters)',\n  type: 'function'\n}, {\n  label: 'irate',\n  detail: 'function',\n  info: 'Calculate the per-second increase over the last two samples of a range vector (for counters)',\n  type: 'function'\n}, {\n  label: 'label_replace',\n  detail: 'function',\n  info: 'Set or replace label values',\n  type: 'function'\n}, {\n  label: 'label_join',\n  detail: 'function',\n  info: 'Join together label values into new label',\n  type: 'function'\n}, {\n  label: 'last_over_time',\n  detail: 'function',\n  info: 'The most recent point value in specified interval.',\n  type: 'function'\n}, {\n  label: 'ln',\n  detail: 'function',\n  info: 'Calculate natural logarithm of input series',\n  type: 'function'\n}, {\n  label: 'log10',\n  detail: 'function',\n  info: 'Calulcate base-10 logarithm of input series',\n  type: 'function'\n}, {\n  label: 'log2',\n  detail: 'function',\n  info: 'Calculate base-2 logarithm of input series',\n  type: 'function'\n}, {\n  label: 'max_over_time',\n  detail: 'function',\n  info: 'Return the maximum value over time for input series',\n  type: 'function'\n}, {\n  label: 'min_over_time',\n  detail: 'function',\n  info: 'Return the minimum value over time for input series',\n  type: 'function'\n}, {\n  label: 'minute',\n  detail: 'function',\n  info: 'Return the minute of the hour for provided timestamps',\n  type: 'function'\n}, {\n  label: 'month',\n  detail: 'function',\n  info: 'Return the month for provided timestamps',\n  type: 'function'\n}, {\n  label: 'predict_linear',\n  detail: 'function',\n  info: 'Predict the value of a gauge into the future',\n  type: 'function'\n}, {\n  label: 'quantile_over_time',\n  detail: 'function',\n  info: 'Calculate value quantiles over time for input series',\n  type: 'function'\n}, {\n  label: 'rate',\n  detail: 'function',\n  info: 'Calculate per-second increase over a range vector (for counters)',\n  type: 'function'\n}, {\n  label: 'resets',\n  detail: 'function',\n  info: 'Return number of value decreases (resets) in input series of time',\n  type: 'function'\n}, {\n  label: 'round',\n  detail: 'function',\n  info: 'Round values of input series to nearest integer',\n  type: 'function'\n}, {\n  label: 'scalar',\n  detail: 'function',\n  info: 'Convert single-element series vector into scalar value',\n  type: 'function'\n}, {\n  label: 'sgn',\n  detail: 'function',\n  info: 'Returns the sign of the instant vector',\n  type: 'function'\n}, {\n  label: 'sort',\n  detail: 'function',\n  info: 'Sort input series ascendingly by value',\n  type: 'function'\n}, {\n  label: 'sort_desc',\n  detail: 'function',\n  info: 'Sort input series descendingly by value',\n  type: 'function'\n}, {\n  label: 'sqrt',\n  detail: 'function',\n  info: 'Return the square root for input series',\n  type: 'function'\n}, {\n  label: 'stddev_over_time',\n  detail: 'function',\n  info: 'Calculate the standard deviation within input series over time',\n  type: 'function'\n}, {\n  label: 'stdvar_over_time',\n  detail: 'function',\n  info: 'Calculate the standard variation within input series over time',\n  type: 'function'\n}, {\n  label: 'sum_over_time',\n  detail: 'function',\n  info: 'Calculate the sum over the values of input series over time',\n  type: 'function'\n}, {\n  label: 'time',\n  detail: 'function',\n  info: 'Return the Unix timestamp at the current evaluation time',\n  type: 'function'\n}, {\n  label: 'timestamp',\n  detail: 'function',\n  info: 'Return the Unix timestamp for the samples in the input vector',\n  type: 'function'\n}, {\n  label: 'vector',\n  detail: 'function',\n  info: 'Convert a scalar value into a single-element series vector',\n  type: 'function'\n}, {\n  label: 'year',\n  detail: 'function',\n  info: 'Return the year for provided timestamps',\n  type: 'function'\n}];\nexport var aggregateOpTerms = [{\n  label: 'avg',\n  detail: 'aggregation',\n  info: 'Calculate the average over dimensions',\n  type: 'keyword'\n}, {\n  label: 'bottomk',\n  detail: 'aggregation',\n  info: 'Smallest k elements by sample value',\n  type: 'keyword'\n}, {\n  label: 'count',\n  detail: 'aggregation',\n  info: 'Count number of elements in the vector',\n  type: 'keyword'\n}, {\n  label: 'count_values',\n  detail: 'aggregation',\n  info: 'Count number of elements with the same value',\n  type: 'keyword'\n}, {\n  label: 'group',\n  detail: 'aggregation',\n  info: 'Group series, while setting the sample value to 1',\n  type: 'keyword'\n}, {\n  label: 'max',\n  detail: 'aggregation',\n  info: 'Select maximum over dimensions',\n  type: 'keyword'\n}, {\n  label: 'min',\n  detail: 'aggregation',\n  info: 'Select minimum over dimensions',\n  type: 'keyword'\n}, {\n  label: 'quantile',\n  detail: 'aggregation',\n  info: 'Calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions',\n  type: 'keyword'\n}, {\n  label: 'stddev',\n  detail: 'aggregation',\n  info: 'Calculate population standard deviation over dimensions',\n  type: 'keyword'\n}, {\n  label: 'stdvar',\n  detail: 'aggregation',\n  info: 'Calculate population standard variance over dimensions',\n  type: 'keyword'\n}, {\n  label: 'sum',\n  detail: 'aggregation',\n  info: 'Calculate sum over dimensions',\n  type: 'keyword'\n}, {\n  label: 'topk',\n  detail: 'aggregation',\n  info: 'Largest k elements by sample value',\n  type: 'keyword'\n}];\nexport var aggregateOpModifierTerms = [{\n  label: 'by',\n  info: 'Keep the listed labels, remove all others.',\n  type: 'keyword'\n}, {\n  label: 'without',\n  info: 'Remove the listed labels, preserve all others.',\n  type: 'keyword'\n}];\nexport var snippets = [{\n  label: 'sum(rate(__input_vector__[5m]))',\n  type: 'function',\n  detail: 'snippet',\n  info: 'Sum over rates of increase',\n  apply: snippet('sum(rate(${__input_vector__}[5m]))')\n}, {\n  label: 'histogram_quantile(__quantile__, sum by(le) (rate(__histogram_metric__[5m])))',\n  type: 'function',\n  detail: 'snippet',\n  info: 'Approximate a quantile value from an aggregated histogram',\n  apply: snippet('histogram_quantile(${__quantile__}, sum by(le) (rate(${__histogram_metric__}[5m])))')\n}, {\n  label: 'label_replace(__input_vector__, \"__dst__\", \"__replacement__\", \"__src__\", \"__regex__\")',\n  type: 'function',\n  detail: 'snippet',\n  info: 'Set or replace a label value in an input vector',\n  apply: snippet('label_replace(${__input_vector__}, \"${__dst__}\", \"${__replacement__}\", \"${__src__}\", \"${__regex__}\")')\n}, {\n  label: 'topk(__rank_number__, __input_vector__)',\n  type: 'function',\n  detail: 'snippet',\n  info: 'Largest k elements by sample value',\n  apply: snippet('topk(${__rank_number__}, ${__input_vector__})')\n}, {\n  label: 'bottomk(__rank_number__, __input_vector__)',\n  type: 'function',\n  detail: 'snippet',\n  info: 'Smallest k elements by sample value',\n  apply: snippet('bottomk(${__rank_number__}, ${__input_vector__})')\n}, {\n  label: 'count_values(\"__label_name__\", __input_vector__)',\n  type: 'function',\n  detail: 'snippet',\n  info: 'Count the number of series per distinct sample value',\n  apply: snippet('count_values(\"${__label_name__}\", ${__metric__})')\n}];","map":{"version":3,"sources":["../../../src/lang-promql/complete/promql.terms.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { snippet } from '@codemirror/autocomplete';\nexport const durationTerms = [{ label: 'y' }, { label: 'w' }, { label: 'd' }, { label: 'h' }, { label: 'm' }, { label: 's' }, { label: 'ms' }];\nexport const matchOpTerms = [{ label: '=' }, { label: '!=' }, { label: '=~' }, { label: '!~' }];\nexport const binOpTerms = [\n    { label: '^' },\n    { label: '*' },\n    { label: '/' },\n    { label: '%' },\n    { label: '+' },\n    { label: '-' },\n    { label: '==' },\n    { label: '>=' },\n    { label: '>' },\n    { label: '<' },\n    { label: '<=' },\n    { label: '!=' },\n    { label: 'and' },\n    { label: 'or' },\n    { label: 'unless' },\n];\nexport const binOpModifierTerms = [\n    { label: 'on', info: 'Match only on specified labels', type: 'keyword' },\n    { label: 'ignoring', info: 'Ignore specified labels for matching', type: 'keyword' },\n    { label: 'group_left', info: 'Allow many-to-one matching', type: 'keyword' },\n    { label: 'group_right', info: 'Allow one-to-many matching', type: 'keyword' },\n];\nexport const atModifierTerms = [\n    { label: 'start()', info: 'resolve to the start of the query', type: 'keyword' },\n    { label: 'end()', info: 'resolve to the end of the query', type: 'keyword' },\n];\nexport const functionIdentifierTerms = [\n    {\n        label: 'abs',\n        detail: 'function',\n        info: 'Return absolute values of input series',\n        type: 'function',\n    },\n    {\n        label: 'absent',\n        detail: 'function',\n        info: 'Determine whether input vector is empty',\n        type: 'function',\n    },\n    {\n        label: 'absent_over_time',\n        detail: 'function',\n        info: 'Determine whether input range vector is empty',\n        type: 'function',\n    },\n    {\n        label: 'avg_over_time',\n        detail: 'function',\n        info: 'Average series values over time',\n        type: 'function',\n    },\n    {\n        label: 'ceil',\n        detail: 'function',\n        info: 'Round up values of input series to nearest integer',\n        type: 'function',\n    },\n    {\n        label: 'changes',\n        detail: 'function',\n        info: 'Return number of value changes in input series over time',\n        type: 'function',\n    },\n    {\n        label: 'clamp',\n        detail: 'function',\n        info: 'Limit the value of input series between a minimum and a maximum',\n        type: 'function',\n    },\n    {\n        label: 'clamp_max',\n        detail: 'function',\n        info: 'Limit the value of input series to a maximum',\n        type: 'function',\n    },\n    {\n        label: 'clamp_min',\n        detail: 'function',\n        info: 'Limit the value of input series to a minimum',\n        type: 'function',\n    },\n    {\n        label: 'count_over_time',\n        detail: 'function',\n        info: 'Count the number of values for each input series',\n        type: 'function',\n    },\n    {\n        label: 'days_in_month',\n        detail: 'function',\n        info: 'Return the number of days in current month for provided timestamps',\n        type: 'function',\n    },\n    {\n        label: 'day_of_month',\n        detail: 'function',\n        info: 'Return the day of the month for provided timestamps',\n        type: 'function',\n    },\n    {\n        label: 'day_of_week',\n        detail: 'function',\n        info: 'Return the day of the week for provided timestamps',\n        type: 'function',\n    },\n    {\n        label: 'delta',\n        detail: 'function',\n        info: 'Calculate the difference between beginning and end of a range vector (for gauges)',\n        type: 'function',\n    },\n    {\n        label: 'deriv',\n        detail: 'function',\n        info: 'Calculate the per-second derivative over series in a range vector (for gauges)',\n        type: 'function',\n    },\n    {\n        label: 'exp',\n        detail: 'function',\n        info: 'Calculate exponential function for input vector values',\n        type: 'function',\n    },\n    {\n        label: 'floor',\n        detail: 'function',\n        info: 'Round down values of input series to nearest integer',\n        type: 'function',\n    },\n    {\n        label: 'histogram_quantile',\n        detail: 'function',\n        info: 'Calculate quantiles from histogram buckets',\n        type: 'function',\n    },\n    {\n        label: 'holt_winters',\n        detail: 'function',\n        info: 'Calculate smoothed value of input series',\n        type: 'function',\n    },\n    {\n        label: 'hour',\n        detail: 'function',\n        info: 'Return the hour of the day for provided timestamps',\n        type: 'function',\n    },\n    {\n        label: 'idelta',\n        detail: 'function',\n        info: 'Calculate the difference between the last two samples of a range vector (for counters)',\n        type: 'function',\n    },\n    {\n        label: 'increase',\n        detail: 'function',\n        info: 'Calculate the increase in value over a range of time (for counters)',\n        type: 'function',\n    },\n    {\n        label: 'irate',\n        detail: 'function',\n        info: 'Calculate the per-second increase over the last two samples of a range vector (for counters)',\n        type: 'function',\n    },\n    {\n        label: 'label_replace',\n        detail: 'function',\n        info: 'Set or replace label values',\n        type: 'function',\n    },\n    {\n        label: 'label_join',\n        detail: 'function',\n        info: 'Join together label values into new label',\n        type: 'function',\n    },\n    {\n        label: 'last_over_time',\n        detail: 'function',\n        info: 'The most recent point value in specified interval.',\n        type: 'function',\n    },\n    {\n        label: 'ln',\n        detail: 'function',\n        info: 'Calculate natural logarithm of input series',\n        type: 'function',\n    },\n    {\n        label: 'log10',\n        detail: 'function',\n        info: 'Calulcate base-10 logarithm of input series',\n        type: 'function',\n    },\n    {\n        label: 'log2',\n        detail: 'function',\n        info: 'Calculate base-2 logarithm of input series',\n        type: 'function',\n    },\n    {\n        label: 'max_over_time',\n        detail: 'function',\n        info: 'Return the maximum value over time for input series',\n        type: 'function',\n    },\n    {\n        label: 'min_over_time',\n        detail: 'function',\n        info: 'Return the minimum value over time for input series',\n        type: 'function',\n    },\n    {\n        label: 'minute',\n        detail: 'function',\n        info: 'Return the minute of the hour for provided timestamps',\n        type: 'function',\n    },\n    {\n        label: 'month',\n        detail: 'function',\n        info: 'Return the month for provided timestamps',\n        type: 'function',\n    },\n    {\n        label: 'predict_linear',\n        detail: 'function',\n        info: 'Predict the value of a gauge into the future',\n        type: 'function',\n    },\n    {\n        label: 'quantile_over_time',\n        detail: 'function',\n        info: 'Calculate value quantiles over time for input series',\n        type: 'function',\n    },\n    {\n        label: 'rate',\n        detail: 'function',\n        info: 'Calculate per-second increase over a range vector (for counters)',\n        type: 'function',\n    },\n    {\n        label: 'resets',\n        detail: 'function',\n        info: 'Return number of value decreases (resets) in input series of time',\n        type: 'function',\n    },\n    {\n        label: 'round',\n        detail: 'function',\n        info: 'Round values of input series to nearest integer',\n        type: 'function',\n    },\n    {\n        label: 'scalar',\n        detail: 'function',\n        info: 'Convert single-element series vector into scalar value',\n        type: 'function',\n    },\n    {\n        label: 'sgn',\n        detail: 'function',\n        info: 'Returns the sign of the instant vector',\n        type: 'function',\n    },\n    {\n        label: 'sort',\n        detail: 'function',\n        info: 'Sort input series ascendingly by value',\n        type: 'function',\n    },\n    {\n        label: 'sort_desc',\n        detail: 'function',\n        info: 'Sort input series descendingly by value',\n        type: 'function',\n    },\n    {\n        label: 'sqrt',\n        detail: 'function',\n        info: 'Return the square root for input series',\n        type: 'function',\n    },\n    {\n        label: 'stddev_over_time',\n        detail: 'function',\n        info: 'Calculate the standard deviation within input series over time',\n        type: 'function',\n    },\n    {\n        label: 'stdvar_over_time',\n        detail: 'function',\n        info: 'Calculate the standard variation within input series over time',\n        type: 'function',\n    },\n    {\n        label: 'sum_over_time',\n        detail: 'function',\n        info: 'Calculate the sum over the values of input series over time',\n        type: 'function',\n    },\n    {\n        label: 'time',\n        detail: 'function',\n        info: 'Return the Unix timestamp at the current evaluation time',\n        type: 'function',\n    },\n    {\n        label: 'timestamp',\n        detail: 'function',\n        info: 'Return the Unix timestamp for the samples in the input vector',\n        type: 'function',\n    },\n    {\n        label: 'vector',\n        detail: 'function',\n        info: 'Convert a scalar value into a single-element series vector',\n        type: 'function',\n    },\n    {\n        label: 'year',\n        detail: 'function',\n        info: 'Return the year for provided timestamps',\n        type: 'function',\n    },\n];\nexport const aggregateOpTerms = [\n    {\n        label: 'avg',\n        detail: 'aggregation',\n        info: 'Calculate the average over dimensions',\n        type: 'keyword',\n    },\n    {\n        label: 'bottomk',\n        detail: 'aggregation',\n        info: 'Smallest k elements by sample value',\n        type: 'keyword',\n    },\n    {\n        label: 'count',\n        detail: 'aggregation',\n        info: 'Count number of elements in the vector',\n        type: 'keyword',\n    },\n    {\n        label: 'count_values',\n        detail: 'aggregation',\n        info: 'Count number of elements with the same value',\n        type: 'keyword',\n    },\n    {\n        label: 'group',\n        detail: 'aggregation',\n        info: 'Group series, while setting the sample value to 1',\n        type: 'keyword',\n    },\n    {\n        label: 'max',\n        detail: 'aggregation',\n        info: 'Select maximum over dimensions',\n        type: 'keyword',\n    },\n    {\n        label: 'min',\n        detail: 'aggregation',\n        info: 'Select minimum over dimensions',\n        type: 'keyword',\n    },\n    {\n        label: 'quantile',\n        detail: 'aggregation',\n        info: 'Calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions',\n        type: 'keyword',\n    },\n    {\n        label: 'stddev',\n        detail: 'aggregation',\n        info: 'Calculate population standard deviation over dimensions',\n        type: 'keyword',\n    },\n    {\n        label: 'stdvar',\n        detail: 'aggregation',\n        info: 'Calculate population standard variance over dimensions',\n        type: 'keyword',\n    },\n    {\n        label: 'sum',\n        detail: 'aggregation',\n        info: 'Calculate sum over dimensions',\n        type: 'keyword',\n    },\n    {\n        label: 'topk',\n        detail: 'aggregation',\n        info: 'Largest k elements by sample value',\n        type: 'keyword',\n    },\n];\nexport const aggregateOpModifierTerms = [\n    {\n        label: 'by',\n        info: 'Keep the listed labels, remove all others.',\n        type: 'keyword',\n    },\n    {\n        label: 'without',\n        info: 'Remove the listed labels, preserve all others.',\n        type: 'keyword',\n    },\n];\nexport const snippets = [\n    {\n        label: 'sum(rate(__input_vector__[5m]))',\n        type: 'function',\n        detail: 'snippet',\n        info: 'Sum over rates of increase',\n        apply: snippet('sum(rate(${__input_vector__}[5m]))'),\n    },\n    {\n        label: 'histogram_quantile(__quantile__, sum by(le) (rate(__histogram_metric__[5m])))',\n        type: 'function',\n        detail: 'snippet',\n        info: 'Approximate a quantile value from an aggregated histogram',\n        apply: snippet('histogram_quantile(${__quantile__}, sum by(le) (rate(${__histogram_metric__}[5m])))'),\n    },\n    {\n        label: 'label_replace(__input_vector__, \"__dst__\", \"__replacement__\", \"__src__\", \"__regex__\")',\n        type: 'function',\n        detail: 'snippet',\n        info: 'Set or replace a label value in an input vector',\n        apply: snippet('label_replace(${__input_vector__}, \"${__dst__}\", \"${__replacement__}\", \"${__src__}\", \"${__regex__}\")'),\n    },\n    {\n        label: 'topk(__rank_number__, __input_vector__)',\n        type: 'function',\n        detail: 'snippet',\n        info: 'Largest k elements by sample value',\n        apply: snippet('topk(${__rank_number__}, ${__input_vector__})'),\n    },\n    {\n        label: 'bottomk(__rank_number__, __input_vector__)',\n        type: 'function',\n        detail: 'snippet',\n        info: 'Smallest k elements by sample value',\n        apply: snippet('bottomk(${__rank_number__}, ${__input_vector__})'),\n    },\n    {\n        label: 'count_values(\"__label_name__\", __input_vector__)',\n        type: 'function',\n        detail: 'snippet',\n        info: 'Count the number of series per distinct sample value',\n        apply: snippet('count_values(\"${__label_name__}\", ${__metric__})'),\n    },\n];\n//# sourceMappingURL=promql.terms.js.map"]},"metadata":{},"sourceType":"module"}