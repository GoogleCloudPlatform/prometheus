{"ast":null,"code":"import _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { EditorSelection } from '@codemirror/state'; /// Comment or uncomment the current selection. Will use line comments\n/// if available, otherwise falling back to block comments.\n\nvar toggleComment = function toggleComment(target) {\n  var config = getConfig(target.state);\n  return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;\n};\n\nfunction command(f, option) {\n  return function (_ref) {\n    var state = _ref.state,\n        dispatch = _ref.dispatch;\n    var tr = f(option, state.selection.ranges, state);\n    if (!tr) return false;\n    dispatch(state.update(tr));\n    return true;\n  };\n} /// Comment or uncomment the current selection using line comments.\n/// The line comment syntax is taken from the\n/// [`commentTokens`](#comment.CommentTokens) [language\n/// data](#state.EditorState.languageDataAt).\n\n\nvar toggleLineComment = command(changeLineComment, 0\n/* Toggle */\n); /// Comment the current selection using line comments.\n\nvar lineComment = command(changeLineComment, 1\n/* Comment */\n); /// Uncomment the current selection using line comments.\n\nvar lineUncomment = command(changeLineComment, 2\n/* Uncomment */\n); /// Comment or uncomment the current selection using block comments.\n/// The block comment syntax is taken from the\n/// [`commentTokens`](#comment.CommentTokens) [language\n/// data](#state.EditorState.languageDataAt).\n\nvar toggleBlockComment = command(changeBlockComment, 0\n/* Toggle */\n); /// Comment the current selection using block comments.\n\nvar blockComment = command(changeBlockComment, 1\n/* Comment */\n); /// Uncomment the current selection using block comments.\n\nvar blockUncomment = command(changeBlockComment, 2\n/* Uncomment */\n); /// Default key bindings for this package.\n///\n///  - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](#comment.toggleComment).\n///  - Shift-Alt-a: [`toggleBlockComment`](#comment.toggleBlockComment).\n\nvar commentKeymap = [{\n  key: \"Mod-/\",\n  run: toggleComment\n}, {\n  key: \"Alt-A\",\n  run: toggleBlockComment\n}];\n\nfunction getConfig(state) {\n  var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : state.selection.main.head;\n  var data = state.languageDataAt(\"commentTokens\", pos);\n  return data.length ? data[0] : {};\n}\n\nvar SearchMargin = 50; /// Determines if the given range is block-commented in the given\n/// state.\n\nfunction findBlockComment(state, _ref2, from, to) {\n  var open = _ref2.open,\n      close = _ref2.close;\n  var textBefore = state.sliceDoc(from - SearchMargin, from);\n  var textAfter = state.sliceDoc(to, to + SearchMargin);\n  var spaceBefore = /\\s*$/.exec(textBefore)[0].length,\n      spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n  var beforeOff = textBefore.length - spaceBefore;\n\n  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n    return {\n      open: {\n        pos: from - spaceBefore,\n        margin: spaceBefore && 1\n      },\n      close: {\n        pos: to + spaceAfter,\n        margin: spaceAfter && 1\n      }\n    };\n  }\n\n  var startText, endText;\n\n  if (to - from <= 2 * SearchMargin) {\n    startText = endText = state.sliceDoc(from, to);\n  } else {\n    startText = state.sliceDoc(from, from + SearchMargin);\n    endText = state.sliceDoc(to - SearchMargin, to);\n  }\n\n  var startSpace = /^\\s*/.exec(startText)[0].length,\n      endSpace = /\\s*$/.exec(endText)[0].length;\n  var endOff = endText.length - endSpace - close.length;\n\n  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n    return {\n      open: {\n        pos: from + startSpace + open.length,\n        margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n      },\n      close: {\n        pos: to - endSpace - close.length,\n        margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n      }\n    };\n  }\n\n  return null;\n} // Performs toggle, comment and uncomment of block comments in\n// languages that support them.\n\n\nfunction changeBlockComment(option, ranges, state) {\n  var tokens = ranges.map(function (r) {\n    return getConfig(state, r.from).block;\n  });\n  if (!tokens.every(function (c) {\n    return c;\n  })) return null;\n  var comments = ranges.map(function (r, i) {\n    return findBlockComment(state, tokens[i], r.from, r.to);\n  });\n\n  if (option != 2\n  /* Uncomment */\n  && !comments.every(function (c) {\n    return c;\n  })) {\n    var index = 0;\n    return state.changeByRange(function (range) {\n      var _tokens$index = tokens[index++],\n          open = _tokens$index.open,\n          close = _tokens$index.close;\n      if (comments[index]) return {\n        range: range\n      };\n      var shift = open.length + 1;\n      return {\n        changes: [{\n          from: range.from,\n          insert: open + \" \"\n        }, {\n          from: range.to,\n          insert: \" \" + close\n        }],\n        range: EditorSelection.range(range.anchor + shift, range.head + shift)\n      };\n    });\n  } else if (option != 1\n  /* Comment */\n  && comments.some(function (c) {\n    return c;\n  })) {\n    var changes = [];\n\n    for (var i = 0, comment; i < comments.length; i++) {\n      if (comment = comments[i]) {\n        var token = tokens[i],\n            _comment = comment,\n            open = _comment.open,\n            close = _comment.close;\n        changes.push({\n          from: open.pos - token.open.length,\n          to: open.pos + open.margin\n        }, {\n          from: close.pos - close.margin,\n          to: close.pos + token.close.length\n        });\n      }\n    }\n\n    return {\n      changes: changes\n    };\n  }\n\n  return null;\n} // Performs toggle, comment and uncomment of line comments.\n\n\nfunction changeLineComment(option, ranges, state) {\n  var lines = [];\n  var prevLine = -1;\n\n  var _iterator = _createForOfIteratorHelper(ranges),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          _from = _step$value.from,\n          _to = _step$value.to;\n      var startI = lines.length,\n          minIndent = 1e9;\n\n      for (var pos = _from; pos <= _to;) {\n        var _line2 = state.doc.lineAt(pos);\n\n        if (_line2.from > prevLine && (_from == _to || _to > _line2.from)) {\n          prevLine = _line2.from;\n          var _token2 = getConfig(state, pos).line;\n          if (!_token2) continue;\n          var _indent = /^\\s*/.exec(_line2.text)[0].length;\n\n          var _comment3 = _line2.text.slice(_indent, _indent + _token2.length) == _token2 ? _indent : -1;\n\n          if (_indent < _line2.text.length && _indent < minIndent) minIndent = _indent;\n          lines.push({\n            line: _line2,\n            comment: _comment3,\n            token: _token2,\n            indent: _indent,\n            single: false\n          });\n        }\n\n        pos = _line2.to + 1;\n      }\n\n      if (minIndent < 1e9) for (var i = startI; i < lines.length; i++) {\n        if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n      }\n      if (lines.length == startI + 1) lines[startI].single = true;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (option != 1\n  /* Comment */\n  && lines.some(function (l) {\n    return l.comment >= 0;\n  })) {\n    var changes = [];\n\n    var _iterator2 = _createForOfIteratorHelper(lines),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _step2.value,\n            line = _step2$value.line,\n            comment = _step2$value.comment,\n            token = _step2$value.token;\n\n        if (comment >= 0) {\n          var from = line.from + comment,\n              to = from + token.length;\n          if (line.text[to - line.from] == \" \") to++;\n          changes.push({\n            from: from,\n            to: to\n          });\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return {\n      changes: changes\n    };\n  } else if (option != 2\n  /* Uncomment */\n  && lines.some(function (l) {\n    return l.comment < 0;\n  })) {\n    var _changes = [];\n\n    var _iterator3 = _createForOfIteratorHelper(lines),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _step3.value,\n            _line = _step3$value.line,\n            _comment2 = _step3$value.comment,\n            _token = _step3$value.token,\n            indent = _step3$value.indent,\n            single = _step3$value.single;\n        if (_comment2 != indent && (single || /\\S/.test(_line.text))) _changes.push({\n          from: _line.from + indent,\n          insert: _token + \" \"\n        });\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var changeSet = state.changes(_changes);\n    return {\n      changes: changeSet,\n      selection: state.selection.map(changeSet, 1)\n    };\n  }\n\n  return null;\n}\n\nexport { blockComment, blockUncomment, commentKeymap, lineComment, lineUncomment, toggleBlockComment, toggleComment, toggleLineComment };","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/@codemirror/comment/dist/index.js"],"names":["EditorSelection","toggleComment","target","config","getConfig","state","line","toggleLineComment","block","toggleBlockComment","command","f","option","dispatch","tr","selection","ranges","update","changeLineComment","lineComment","lineUncomment","changeBlockComment","blockComment","blockUncomment","commentKeymap","key","run","pos","main","head","data","languageDataAt","length","SearchMargin","findBlockComment","from","to","open","close","textBefore","sliceDoc","textAfter","spaceBefore","exec","spaceAfter","beforeOff","slice","margin","startText","endText","startSpace","endSpace","endOff","test","charAt","tokens","map","r","every","c","comments","i","index","changeByRange","range","shift","changes","insert","anchor","some","comment","token","push","lines","prevLine","startI","minIndent","doc","lineAt","indent","text","single","l","changeSet"],"mappings":"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","sourcesContent":["import { EditorSelection } from '@codemirror/state';\n\n/// Comment or uncomment the current selection. Will use line comments\n/// if available, otherwise falling back to block comments.\nconst toggleComment = target => {\n    let config = getConfig(target.state);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch }) => {\n        let tr = f(option, state.selection.ranges, state);\n        if (!tr)\n            return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/// Comment or uncomment the current selection using line comments.\n/// The line comment syntax is taken from the\n/// [`commentTokens`](#comment.CommentTokens) [language\n/// data](#state.EditorState.languageDataAt).\nconst toggleLineComment = command(changeLineComment, 0 /* Toggle */);\n/// Comment the current selection using line comments.\nconst lineComment = command(changeLineComment, 1 /* Comment */);\n/// Uncomment the current selection using line comments.\nconst lineUncomment = command(changeLineComment, 2 /* Uncomment */);\n/// Comment or uncomment the current selection using block comments.\n/// The block comment syntax is taken from the\n/// [`commentTokens`](#comment.CommentTokens) [language\n/// data](#state.EditorState.languageDataAt).\nconst toggleBlockComment = command(changeBlockComment, 0 /* Toggle */);\n/// Comment the current selection using block comments.\nconst blockComment = command(changeBlockComment, 1 /* Comment */);\n/// Uncomment the current selection using block comments.\nconst blockUncomment = command(changeBlockComment, 2 /* Uncomment */);\n/// Default key bindings for this package.\n///\n///  - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](#comment.toggleComment).\n///  - Shift-Alt-a: [`toggleBlockComment`](#comment.toggleBlockComment).\nconst commentKeymap = [\n    { key: \"Mod-/\", run: toggleComment },\n    { key: \"Alt-A\", run: toggleBlockComment }\n];\nfunction getConfig(state, pos = state.selection.main.head) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/// Determines if the given range is block-commented in the given\n/// state.\nfunction findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&\n        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },\n            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    }\n    else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open &&\n        endText.slice(endOff, endOff + close.length) == close) {\n        return { open: { pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },\n            close: { pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, ranges, state) {\n    let tokens = ranges.map(r => getConfig(state, r.from).block);\n    if (!tokens.every(c => c))\n        return null;\n    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* Uncomment */ && !comments.every(c => c)) {\n        let index = 0;\n        return state.changeByRange(range => {\n            let { open, close } = tokens[index++];\n            if (comments[index])\n                return { range };\n            let shift = open.length + 1;\n            return {\n                changes: [{ from: range.from, insert: open + \" \" }, { from: range.to, insert: \" \" + close }],\n                range: EditorSelection.range(range.anchor + shift, range.head + shift)\n            };\n        });\n    }\n    else if (option != 1 /* Comment */ && comments.some(c => c)) {\n        let changes = [];\n        for (let i = 0, comment; i < comments.length; i++)\n            if (comment = comments[i]) {\n                let token = tokens[i], { open, close } = comment;\n                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });\n            }\n        return { changes };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, ranges, state) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges) {\n        let startI = lines.length, minIndent = 1e9;\n        for (let pos = from; pos <= to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let token = getConfig(state, pos).line;\n                if (!token)\n                    continue;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent)\n                    minIndent = indent;\n                lines.push({ line, comment, token, indent, single: false });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9)\n            for (let i = startI; i < lines.length; i++)\n                if (lines[i].indent < lines[i].line.text.length)\n                    lines[i].indent = minIndent;\n        if (lines.length == startI + 1)\n            lines[startI].single = true;\n    }\n    if (option != 1 /* Comment */ && lines.some(l => l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)\n            if (comment >= 0) {\n                let from = line.from + comment, to = from + token.length;\n                if (line.text[to - line.from] == \" \")\n                    to++;\n                changes.push({ from, to });\n            }\n        return { changes };\n    }\n    else if (option != 2 /* Uncomment */ && lines.some(l => l.comment < 0)) {\n        let changes = [];\n        for (let { line, comment, token, indent, single } of lines)\n            if (comment != indent && (single || /\\S/.test(line.text)))\n                changes.push({ from: line.from + indent, insert: token + \" \" });\n        let changeSet = state.changes(changes);\n        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };\n    }\n    return null;\n}\n\nexport { blockComment, blockUncomment, commentKeymap, lineComment, lineUncomment, toggleBlockComment, toggleComment, toggleLineComment };\n"]},"metadata":{},"sourceType":"module"}