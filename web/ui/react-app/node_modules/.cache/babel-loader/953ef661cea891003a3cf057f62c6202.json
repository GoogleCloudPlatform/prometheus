{"ast":null,"code":"import _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { MapMode } from '@codemirror/state';\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\n\nvar RangeValue = /*#__PURE__*/function () {\n  function RangeValue() {\n    _classCallCheck(this, RangeValue);\n  }\n\n  _createClass(RangeValue, [{\n    key: \"eq\",\n    value:\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    function eq(other) {\n      return this == other;\n    }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n\n  }, {\n    key: \"range\",\n    value: function range(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      return new Range(from, to, this);\n    }\n  }]);\n\n  return RangeValue;\n}();\n\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\n\nvar Range =\n/**\n@internal\n*/\nfunction Range(\n/**\nThe range's start position.\n*/\nfrom,\n/**\nIts end position.\n*/\nto,\n/**\nThe value associated with this range.\n*/\nvalue) {\n  _classCallCheck(this, Range);\n\n  this.from = from;\n  this.to = to;\n  this.value = value;\n};\n\nfunction cmpRange(a, b) {\n  return a.from - b.from || a.value.startSide - b.value.startSide;\n}\n\nvar Chunk = /*#__PURE__*/function () {\n  function Chunk(from, to, value, // Chunks are marked with the largest point that occurs\n  // in them (or -1 for no points), so that scans that are\n  // only interested in points (such as the\n  // heightmap-related logic) can skip range-only chunks.\n  maxPoint) {\n    _classCallCheck(this, Chunk);\n\n    this.from = from;\n    this.to = to;\n    this.value = value;\n    this.maxPoint = maxPoint;\n  }\n\n  _createClass(Chunk, [{\n    key: \"length\",\n    get: function get() {\n      return this.to[this.to.length - 1];\n    } // With side == -1, return the first index where to >= pos. When\n    // side == 1, the first index where from > pos.\n\n  }, {\n    key: \"findIndex\",\n    value: function findIndex(pos, end) {\n      var side = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : end * 1000000000;\n      var startAt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      if (pos <= 0) return startAt;\n      var arr = end < 0 ? this.to : this.from;\n\n      for (var lo = startAt, hi = arr.length;;) {\n        if (lo == hi) return lo;\n        var mid = lo + hi >> 1;\n        var diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n        if (mid == lo) return diff >= 0 ? lo : hi;\n        if (diff >= 0) hi = mid;else lo = mid + 1;\n      }\n    }\n  }, {\n    key: \"between\",\n    value: function between(offset, from, to, f) {\n      for (var i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++) {\n        if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map(offset, changes) {\n      var value = [],\n          from = [],\n          to = [],\n          newPos = -1,\n          maxPoint = -1;\n\n      for (var i = 0; i < this.value.length; i++) {\n        var val = this.value[i],\n            curFrom = this.from[i] + offset,\n            curTo = this.to[i] + offset,\n            newFrom = void 0,\n            newTo = void 0;\n\n        if (curFrom == curTo) {\n          var mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n          if (mapped == null) continue;\n          newFrom = newTo = mapped;\n        } else {\n          newFrom = changes.mapPos(curFrom, val.startSide);\n          newTo = changes.mapPos(curTo, val.endSide);\n          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n        }\n\n        if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n        if (newPos < 0) newPos = newFrom;\n        if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n        value.push(val);\n        from.push(newFrom - newPos);\n        to.push(newTo - newPos);\n      }\n\n      return {\n        mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n        pos: newPos\n      };\n    }\n  }]);\n\n  return Chunk;\n}();\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\n\n\nvar RangeSet = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function RangeSet(\n  /**\n  @internal\n  */\n  chunkPos,\n  /**\n  @internal\n  */\n  chunk) {\n    var nextLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeSet.empty;\n    var\n    /**\n    @internal\n    */\n    maxPoint = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, RangeSet);\n\n    this.chunkPos = chunkPos;\n    this.chunk = chunk;\n    this.nextLayer = nextLayer;\n    this.maxPoint = maxPoint;\n  }\n  /**\n  @internal\n  */\n\n\n  _createClass(RangeSet, [{\n    key: \"length\",\n    get: function get() {\n      var last = this.chunk.length - 1;\n      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      if (this == RangeSet.empty) return 0;\n      var size = this.nextLayer.size;\n\n      var _iterator = _createForOfIteratorHelper(this.chunk),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var chunk = _step.value;\n          size += chunk.value.length;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return size;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"chunkEnd\",\n    value: function chunkEnd(index) {\n      return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n\n  }, {\n    key: \"update\",\n    value: function update(updateSpec) {\n      var _updateSpec$add = updateSpec.add,\n          add = _updateSpec$add === void 0 ? [] : _updateSpec$add,\n          _updateSpec$sort = updateSpec.sort,\n          sort = _updateSpec$sort === void 0 ? false : _updateSpec$sort,\n          _updateSpec$filterFro = updateSpec.filterFrom,\n          filterFrom = _updateSpec$filterFro === void 0 ? 0 : _updateSpec$filterFro,\n          _updateSpec$filterTo = updateSpec.filterTo,\n          filterTo = _updateSpec$filterTo === void 0 ? this.length : _updateSpec$filterTo;\n      var filter = updateSpec.filter;\n      if (add.length == 0 && !filter) return this;\n      if (sort) add.slice().sort(cmpRange);\n      if (this == RangeSet.empty) return add.length ? RangeSet.of(add) : this;\n      var cur = new LayerCursor(this, null, -1).goto(0),\n          i = 0,\n          spill = [];\n      var builder = new RangeSetBuilder();\n\n      while (cur.value || i < add.length) {\n        if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n          var range = add[i++];\n          if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n        } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n          cur.nextChunk();\n        } else {\n          if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n            if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(new Range(cur.from, cur.to, cur.value));\n          }\n\n          cur.next();\n        }\n      }\n\n      return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n        add: spill,\n        filter: filter,\n        filterFrom: filterFrom,\n        filterTo: filterTo\n      }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n\n  }, {\n    key: \"map\",\n    value: function map(changes) {\n      if (changes.length == 0 || this == RangeSet.empty) return this;\n      var chunks = [],\n          chunkPos = [],\n          maxPoint = -1;\n\n      for (var i = 0; i < this.chunk.length; i++) {\n        var start = this.chunkPos[i],\n            chunk = this.chunk[i];\n        var touch = changes.touchesRange(start, start + chunk.length);\n\n        if (touch === false) {\n          maxPoint = Math.max(maxPoint, chunk.maxPoint);\n          chunks.push(chunk);\n          chunkPos.push(changes.mapPos(start));\n        } else if (touch === true) {\n          var _chunk$map = chunk.map(start, changes),\n              mapped = _chunk$map.mapped,\n              pos = _chunk$map.pos;\n\n          if (mapped) {\n            maxPoint = Math.max(maxPoint, mapped.maxPoint);\n            chunks.push(mapped);\n            chunkPos.push(pos);\n          }\n        }\n      }\n\n      var next = this.nextLayer.map(changes);\n      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n\n  }, {\n    key: \"between\",\n    value: function between(from, to, f) {\n      if (this == RangeSet.empty) return;\n\n      for (var i = 0; i < this.chunk.length; i++) {\n        var start = this.chunkPos[i],\n            chunk = this.chunk[i];\n        if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n      }\n\n      this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n\n  }, {\n    key: \"iter\",\n    value: function iter() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n\n  }], [{\n    key: \"iter\",\n    value: function iter(sets) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n\n  }, {\n    key: \"compare\",\n    value: function compare(oldSets, newSets,\n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator) {\n      var minPointSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n      var a = oldSets.filter(function (set) {\n        return set.maxPoint >= 500\n        /* BigPointSize */\n        || set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize;\n      });\n      var b = newSets.filter(function (set) {\n        return set.maxPoint >= 500\n        /* BigPointSize */\n        || set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize;\n      });\n      var sharedChunks = findSharedChunks(a, b);\n      var sideA = new SpanCursor(a, sharedChunks, minPointSize);\n      var sideB = new SpanCursor(b, sharedChunks, minPointSize);\n      textDiff.iterGaps(function (fromA, fromB, length) {\n        return _compare(sideA, fromA, sideB, fromB, length, comparator);\n      });\n      if (textDiff.empty && textDiff.length == 0) _compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n\n  }, {\n    key: \"spans\",\n    value: function spans(sets, from, to, iterator) {\n      var minPointSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n      var cursor = new SpanCursor(sets, null, minPointSize).goto(from),\n          pos = from;\n      var open = cursor.openStart;\n\n      for (;;) {\n        var curTo = Math.min(cursor.to, to);\n\n        if (cursor.point) {\n          iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n          open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n        } else if (curTo > pos) {\n          iterator.span(pos, curTo, cursor.active, open);\n          open = cursor.openEnd(curTo);\n        }\n\n        if (cursor.to > to) break;\n        pos = cursor.to;\n        cursor.next();\n      }\n\n      return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n\n  }, {\n    key: \"of\",\n    value: function of(ranges) {\n      var sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var build = new RangeSetBuilder();\n\n      var _iterator2 = _createForOfIteratorHelper(ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var range = _step2.value;\n          build.add(range.from, range.to, range.value);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return build.finish();\n    }\n  }]);\n\n  return RangeSet;\n}();\n/**\nThe empty set of ranges.\n*/\n\n\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\n\nvar RangeSetBuilder = /*#__PURE__*/function () {\n  /**\n  Create an empty builder.\n  */\n  function RangeSetBuilder() {\n    _classCallCheck(this, RangeSetBuilder);\n\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunkStart = -1;\n    this.last = null;\n    this.lastFrom = -1000000000\n    /* Far */\n    ;\n    this.lastTo = -1000000000\n    /* Far */\n    ;\n    this.from = [];\n    this.to = [];\n    this.value = [];\n    this.maxPoint = -1;\n    this.setMaxPoint = -1;\n    this.nextLayer = null;\n  }\n\n  _createClass(RangeSetBuilder, [{\n    key: \"finishChunk\",\n    value: function finishChunk(newArrays) {\n      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n      this.chunkPos.push(this.chunkStart);\n      this.chunkStart = -1;\n      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n      this.maxPoint = -1;\n\n      if (newArrays) {\n        this.from = [];\n        this.to = [];\n        this.value = [];\n      }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n\n  }, {\n    key: \"add\",\n    value: function add(from, to, value) {\n      if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"addInner\",\n    value: function addInner(from, to, value) {\n      var diff = from - this.lastTo || value.startSide - this.last.endSide;\n      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n      if (diff < 0) return false;\n      if (this.from.length == 250\n      /* ChunkSize */\n      ) this.finishChunk(true);\n      if (this.chunkStart < 0) this.chunkStart = from;\n      this.from.push(from - this.chunkStart);\n      this.to.push(to - this.chunkStart);\n      this.last = value;\n      this.lastFrom = from;\n      this.lastTo = to;\n      this.value.push(value);\n      if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n      return true;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"addChunk\",\n    value: function addChunk(from, chunk) {\n      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n      if (this.from.length) this.finishChunk(true);\n      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n      this.chunks.push(chunk);\n      this.chunkPos.push(from);\n      var last = chunk.value.length - 1;\n      this.last = chunk.value[last];\n      this.lastFrom = chunk.from[last] + from;\n      this.lastTo = chunk.to[last] + from;\n      return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return this.finishInner(RangeSet.empty);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"finishInner\",\n    value: function finishInner(next) {\n      if (this.from.length) this.finishChunk(false);\n      if (this.chunks.length == 0) return next;\n      var result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n      this.from = null; // Make sure further `add` calls produce errors\n\n      return result;\n    }\n  }]);\n\n  return RangeSetBuilder;\n}();\n\nfunction findSharedChunks(a, b) {\n  var inA = new Map();\n\n  var _iterator3 = _createForOfIteratorHelper(a),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var set = _step3.value;\n\n      for (var i = 0; i < set.chunk.length; i++) {\n        if (set.chunk[i].maxPoint < 500\n        /* BigPointSize */\n        ) inA.set(set.chunk[i], set.chunkPos[i]);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var shared = new Set();\n\n  var _iterator4 = _createForOfIteratorHelper(b),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _set = _step4.value;\n\n      for (var _i = 0; _i < _set.chunk.length; _i++) {\n        if (inA.get(_set.chunk[_i]) == _set.chunkPos[_i]) shared.add(_set.chunk[_i]);\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return shared;\n}\n\nvar LayerCursor = /*#__PURE__*/function () {\n  function LayerCursor(layer, skip, minPoint) {\n    var rank = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, LayerCursor);\n\n    this.layer = layer;\n    this.skip = skip;\n    this.minPoint = minPoint;\n    this.rank = rank;\n  }\n\n  _createClass(LayerCursor, [{\n    key: \"startSide\",\n    get: function get() {\n      return this.value ? this.value.startSide : 0;\n    }\n  }, {\n    key: \"endSide\",\n    get: function get() {\n      return this.value ? this.value.endSide : 0;\n    }\n  }, {\n    key: \"goto\",\n    value: function goto(pos)\n    /* Far */\n    {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;\n      this.chunkIndex = this.rangeIndex = 0;\n      this.gotoInner(pos, side, false);\n      return this;\n    }\n  }, {\n    key: \"gotoInner\",\n    value: function gotoInner(pos, side, forward) {\n      while (this.chunkIndex < this.layer.chunk.length) {\n        var next = this.layer.chunk[this.chunkIndex];\n        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n        this.chunkIndex++;\n        forward = false;\n      }\n\n      var rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0 : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n      if (!forward || this.rangeIndex < rangeIndex) this.rangeIndex = rangeIndex;\n      this.next();\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(pos, side) {\n      if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (;;) {\n        if (this.chunkIndex == this.layer.chunk.length) {\n          this.from = this.to = 1000000000\n          /* Far */\n          ;\n          this.value = null;\n          break;\n        } else {\n          var chunkPos = this.layer.chunkPos[this.chunkIndex],\n              chunk = this.layer.chunk[this.chunkIndex];\n          var from = chunkPos + chunk.from[this.rangeIndex];\n          this.from = from;\n          this.to = chunkPos + chunk.to[this.rangeIndex];\n          this.value = chunk.value[this.rangeIndex];\n\n          if (++this.rangeIndex == chunk.value.length) {\n            this.chunkIndex++;\n\n            if (this.skip) {\n              while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) {\n                this.chunkIndex++;\n              }\n            }\n\n            this.rangeIndex = 0;\n          }\n\n          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n        }\n      }\n    }\n  }, {\n    key: \"nextChunk\",\n    value: function nextChunk() {\n      this.chunkIndex++;\n      this.rangeIndex = 0;\n      this.next();\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(other) {\n      return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n  }]);\n\n  return LayerCursor;\n}();\n\nvar HeapCursor = /*#__PURE__*/function () {\n  function HeapCursor(heap) {\n    _classCallCheck(this, HeapCursor);\n\n    this.heap = heap;\n  }\n\n  _createClass(HeapCursor, [{\n    key: \"startSide\",\n    get: function get() {\n      return this.value ? this.value.startSide : 0;\n    }\n  }, {\n    key: \"goto\",\n    value: function goto(pos)\n    /* Far */\n    {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;\n\n      var _iterator5 = _createForOfIteratorHelper(this.heap),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var cur = _step5.value;\n          cur.goto(pos, side);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      for (var i = this.heap.length >> 1; i >= 0; i--) {\n        heapBubble(this.heap, i);\n      }\n\n      this.next();\n      return this;\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(pos, side) {\n      var _iterator6 = _createForOfIteratorHelper(this.heap),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var cur = _step6.value;\n          cur.forward(pos, side);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      for (var i = this.heap.length >> 1; i >= 0; i--) {\n        heapBubble(this.heap, i);\n      }\n\n      if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.heap.length == 0) {\n        this.from = this.to = 1000000000\n        /* Far */\n        ;\n        this.value = null;\n        this.rank = -1;\n      } else {\n        var top = this.heap[0];\n        this.from = top.from;\n        this.to = top.to;\n        this.value = top.value;\n        this.rank = top.rank;\n        if (top.value) top.next();\n        heapBubble(this.heap, 0);\n      }\n    }\n  }], [{\n    key: \"from\",\n    value: function from(sets) {\n      var skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var minPoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var heap = [];\n\n      for (var i = 0; i < sets.length; i++) {\n        for (var cur = sets[i]; cur != RangeSet.empty; cur = cur.nextLayer) {\n          if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n        }\n      }\n\n      return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n  }]);\n\n  return HeapCursor;\n}();\n\nfunction heapBubble(heap, index) {\n  for (var cur = heap[index];;) {\n    var childIndex = (index << 1) + 1;\n    if (childIndex >= heap.length) break;\n    var child = heap[childIndex];\n\n    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n      child = heap[childIndex + 1];\n      childIndex++;\n    }\n\n    if (cur.compare(child) < 0) break;\n    heap[childIndex] = cur;\n    heap[index] = child;\n    index = childIndex;\n  }\n}\n\nvar SpanCursor = /*#__PURE__*/function () {\n  function SpanCursor(sets, skip, minPoint) {\n    _classCallCheck(this, SpanCursor);\n\n    this.minPoint = minPoint;\n    this.active = [];\n    this.activeTo = [];\n    this.activeRank = [];\n    this.minActive = -1; // A currently active point range, if any\n\n    this.point = null;\n    this.pointFrom = 0;\n    this.pointRank = 0;\n    this.to = -1000000000\n    /* Far */\n    ;\n    this.endSide = 0;\n    this.openStart = -1;\n    this.cursor = HeapCursor.from(sets, skip, minPoint);\n  }\n\n  _createClass(SpanCursor, [{\n    key: \"goto\",\n    value: function goto(pos)\n    /* Far */\n    {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;\n      this.cursor.goto(pos, side);\n      this.active.length = this.activeTo.length = this.activeRank.length = 0;\n      this.minActive = -1;\n      this.to = pos;\n      this.endSide = side;\n      this.openStart = -1;\n      this.next();\n      return this;\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(pos, side) {\n      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) {\n        this.removeActive(this.minActive);\n      }\n\n      this.cursor.forward(pos, side);\n    }\n  }, {\n    key: \"removeActive\",\n    value: function removeActive(index) {\n      remove(this.active, index);\n      remove(this.activeTo, index);\n      remove(this.activeRank, index);\n      this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n  }, {\n    key: \"addActive\",\n    value: function addActive(trackOpen) {\n      var i = 0,\n          _this$cursor = this.cursor,\n          value = _this$cursor.value,\n          to = _this$cursor.to,\n          rank = _this$cursor.rank;\n\n      while (i < this.activeRank.length && this.activeRank[i] <= rank) {\n        i++;\n      }\n\n      insert(this.active, i, value);\n      insert(this.activeTo, i, to);\n      insert(this.activeRank, i, rank);\n      if (trackOpen) insert(trackOpen, i, this.cursor.from);\n      this.minActive = findMinIndex(this.active, this.activeTo);\n    } // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      var from = this.to,\n          wasPoint = this.point;\n      this.point = null;\n      var trackOpen = this.openStart < 0 ? [] : null,\n          trackExtra = 0;\n\n      for (;;) {\n        var a = this.minActive;\n\n        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n          if (this.activeTo[a] > from) {\n            this.to = this.activeTo[a];\n            this.endSide = this.active[a].endSide;\n            break;\n          }\n\n          this.removeActive(a);\n          if (trackOpen) remove(trackOpen, a);\n        } else if (!this.cursor.value) {\n          this.to = this.endSide = 1000000000\n          /* Far */\n          ;\n          break;\n        } else if (this.cursor.from > from) {\n          this.to = this.cursor.from;\n          this.endSide = this.cursor.startSide;\n          break;\n        } else {\n          var nextVal = this.cursor.value;\n\n          if (!nextVal.point) {\n            // Opening a range\n            this.addActive(trackOpen);\n            this.cursor.next();\n          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {\n            // Ignore any non-empty points that end precisely at the end of the prev point\n            this.cursor.next();\n          } else {\n            // New point\n            this.point = nextVal;\n            this.pointFrom = this.cursor.from;\n            this.pointRank = this.cursor.rank;\n            this.to = this.cursor.to;\n            this.endSide = nextVal.endSide;\n            if (this.cursor.from < from) trackExtra = 1;\n            this.cursor.next();\n            if (this.to > from) this.forward(this.to, this.endSide);\n            break;\n          }\n        }\n      }\n\n      if (trackOpen) {\n        var openStart = 0;\n\n        while (openStart < trackOpen.length && trackOpen[openStart] < from) {\n          openStart++;\n        }\n\n        this.openStart = openStart + trackExtra;\n      }\n    }\n  }, {\n    key: \"activeForPoint\",\n    value: function activeForPoint(to) {\n      if (!this.active.length) return this.active;\n      var active = [];\n\n      for (var i = 0; i < this.active.length; i++) {\n        if (this.activeRank[i] > this.pointRank) break;\n        if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide) active.push(this.active[i]);\n      }\n\n      return active;\n    }\n  }, {\n    key: \"openEnd\",\n    value: function openEnd(to) {\n      var open = 0;\n\n      while (open < this.activeTo.length && this.activeTo[open] > to) {\n        open++;\n      }\n\n      return open;\n    }\n  }]);\n\n  return SpanCursor;\n}();\n\nfunction _compare(a, startA, b, startB, length, comparator) {\n  a.goto(startA);\n  b.goto(startB);\n  var endB = startB + length;\n  var pos = startB,\n      dPos = startB - startA;\n\n  for (;;) {\n    var diff = a.to + dPos - b.to || a.endSide - b.endSide;\n    var end = diff < 0 ? a.to + dPos : b.to,\n        clipEnd = Math.min(end, endB);\n\n    if (a.point || b.point) {\n      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n    } else {\n      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n    }\n\n    if (end > endB) break;\n    pos = end;\n    if (diff <= 0) a.next();\n    if (diff >= 0) b.next();\n  }\n}\n\nfunction sameValues(a, b) {\n  if (a.length != b.length) return false;\n\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction remove(array, index) {\n  for (var i = index, e = array.length - 1; i < e; i++) {\n    array[i] = array[i + 1];\n  }\n\n  array.pop();\n}\n\nfunction insert(array, index, value) {\n  for (var i = array.length - 1; i >= index; i--) {\n    array[i + 1] = array[i];\n  }\n\n  array[index] = value;\n}\n\nfunction findMinIndex(value, array) {\n  var found = -1,\n      foundPos = 1000000000\n  /* Far */\n  ;\n\n  for (var i = 0; i < array.length; i++) {\n    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n      found = i;\n      foundPos = array[i];\n    }\n  }\n\n  return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/@codemirror/rangeset/dist/index.js"],"names":["MapMode","RangeValue","other","from","to","Range","prototype","startSide","endSide","point","mapMode","TrackDel","value","cmpRange","a","b","Chunk","maxPoint","length","pos","end","side","startAt","arr","lo","hi","mid","diff","offset","f","i","findIndex","e","undefined","changes","newPos","val","curFrom","curTo","newFrom","newTo","mapped","mapPos","Math","max","push","RangeSet","chunkPos","chunk","nextLayer","empty","last","chunkEnd","size","index","updateSpec","add","sort","filterFrom","filterTo","filter","slice","of","cur","LayerCursor","goto","spill","builder","RangeSetBuilder","range","addInner","rangeIndex","chunkIndex","addChunk","nextChunk","next","finishInner","update","chunks","start","touch","touchesRange","map","between","HeapCursor","sets","oldSets","newSets","textDiff","comparator","minPointSize","set","indexOf","sharedChunks","findSharedChunks","sideA","SpanCursor","sideB","iterGaps","fromA","fromB","compare","iterator","cursor","open","openStart","min","activeForPoint","openEnd","span","active","ranges","build","finish","chunkStart","lastFrom","lastTo","setMaxPoint","newArrays","Error","finishChunk","result","inA","Map","shared","Set","get","layer","skip","minPoint","rank","gotoInner","forward","has","heap","heapBubble","top","childIndex","child","activeTo","activeRank","minActive","pointFrom","pointRank","removeActive","remove","findMinIndex","trackOpen","insert","wasPoint","trackExtra","nextVal","addActive","startA","startB","endB","dPos","clipEnd","eq","comparePoint","sameValues","compareRange","array","pop","found","foundPos"],"mappings":"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","sourcesContent":["import { MapMode } from '@codemirror/state';\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // With side == -1, return the first index where to >= pos. When\n    // side == 1, the first index where from > pos.\n    findIndex(pos, end, side = end * 1000000000 /* Far */, startAt = 0) {\n        if (pos <= 0)\n            return startAt;\n        let arr = end < 0 ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer = RangeSet.empty, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this == RangeSet.empty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this == RangeSet.empty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.length == 0 || this == RangeSet.empty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this == RangeSet.empty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\nclass RangeSetBuilder {\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* Far */;\n        this.lastTo = -1000000000 /* Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint < 500 /* BigPointSize */)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (inA.get(set.chunk[i]) == set.chunkPos[i])\n                shared.add(set.chunk[i]);\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0\n            : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n        if (!forward || this.rangeIndex < rangeIndex)\n            this.rangeIndex = rangeIndex;\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                if (++this.rangeIndex == chunk.value.length) {\n                    this.chunkIndex++;\n                    if (this.skip) {\n                        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                            this.chunkIndex++;\n                    }\n                    this.rangeIndex = 0;\n                }\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; cur != RangeSet.empty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* Far */;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = 0; i < this.active.length; i++) {\n            if (this.activeRank[i] > this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active;\n    }\n    openEnd(to) {\n        let open = 0;\n        while (open < this.activeTo.length && this.activeTo[open] > to)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };\n"]},"metadata":{},"sourceType":"module"}