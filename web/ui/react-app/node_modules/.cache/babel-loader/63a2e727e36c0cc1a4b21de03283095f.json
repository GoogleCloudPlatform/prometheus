{"ast":null,"code":"// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { AggregateExpr, BinaryExpr, Expr, FunctionCall, MatrixSelector, NumberLiteral, OffsetExpr, ParenExpr, StepInvariantExpr, StringLiteral, SubqueryExpr, UnaryExpr, VectorSelector } from 'lezer-promql';\nimport { walkThrough } from './path-finder';\nimport { getFunction, ValueType } from '../types'; // Based on https://github.com/prometheus/prometheus/blob/d668a7efe3107dbdcc67bf4e9f12430ed8e2b396/promql/parser/ast.go#L191\n\nexport function getType(node) {\n  var _a;\n\n  if (!node) {\n    return ValueType.none;\n  }\n\n  switch (node.type.id) {\n    case Expr:\n      return getType(node.firstChild);\n\n    case AggregateExpr:\n      return ValueType.vector;\n\n    case VectorSelector:\n      return ValueType.vector;\n\n    case OffsetExpr:\n      return getType(node.firstChild);\n\n    case StringLiteral:\n      return ValueType.string;\n\n    case NumberLiteral:\n      return ValueType.scalar;\n\n    case MatrixSelector:\n      return ValueType.matrix;\n\n    case SubqueryExpr:\n      return ValueType.matrix;\n\n    case ParenExpr:\n      return getType(walkThrough(node, Expr));\n\n    case UnaryExpr:\n      return getType(walkThrough(node, Expr));\n\n    case BinaryExpr:\n      var lt = getType(node.firstChild);\n      var rt = getType(node.lastChild);\n\n      if (lt === ValueType.scalar && rt === ValueType.scalar) {\n        return ValueType.scalar;\n      }\n\n      return ValueType.vector;\n\n    case FunctionCall:\n      var funcNode = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n\n      if (!funcNode) {\n        return ValueType.none;\n      }\n\n      return getFunction(funcNode.type.id).returnType;\n\n    case StepInvariantExpr:\n      return getType(walkThrough(node, Expr));\n\n    default:\n      return ValueType.none;\n  }\n}","map":{"version":3,"sources":["../../../src/lang-promql/parser/type.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,SACE,aADF,EAEE,UAFF,EAGE,IAHF,EAIE,YAJF,EAKE,cALF,EAME,aANF,EAOE,UAPF,EAQE,SARF,EASE,iBATF,EAUE,aAVF,EAWE,YAXF,EAYE,SAZF,EAaE,cAbF,QAcO,cAdP;AAeA,SAAS,WAAT,QAA4B,eAA5B;AACA,SAAS,WAAT,EAAsB,SAAtB,QAAuC,UAAvC,C,CAEA;;AACA,OAAM,SAAU,OAAV,CAAkB,IAAlB,EAAyC;;;AAC7C,MAAI,CAAC,IAAL,EAAW;AACT,WAAO,SAAS,CAAC,IAAjB;AACD;;AACD,UAAQ,IAAI,CAAC,IAAL,CAAU,EAAlB;AACE,SAAK,IAAL;AACE,aAAO,OAAO,CAAC,IAAI,CAAC,UAAN,CAAd;;AACF,SAAK,aAAL;AACE,aAAO,SAAS,CAAC,MAAjB;;AACF,SAAK,cAAL;AACE,aAAO,SAAS,CAAC,MAAjB;;AACF,SAAK,UAAL;AACE,aAAO,OAAO,CAAC,IAAI,CAAC,UAAN,CAAd;;AACF,SAAK,aAAL;AACE,aAAO,SAAS,CAAC,MAAjB;;AACF,SAAK,aAAL;AACE,aAAO,SAAS,CAAC,MAAjB;;AACF,SAAK,cAAL;AACE,aAAO,SAAS,CAAC,MAAjB;;AACF,SAAK,YAAL;AACE,aAAO,SAAS,CAAC,MAAjB;;AACF,SAAK,SAAL;AACE,aAAO,OAAO,CAAC,WAAW,CAAC,IAAD,EAAO,IAAP,CAAZ,CAAd;;AACF,SAAK,SAAL;AACE,aAAO,OAAO,CAAC,WAAW,CAAC,IAAD,EAAO,IAAP,CAAZ,CAAd;;AACF,SAAK,UAAL;AACE,UAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,UAAN,CAAlB;AACA,UAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,SAAN,CAAlB;;AACA,UAAI,EAAE,KAAK,SAAS,CAAC,MAAjB,IAA2B,EAAE,KAAK,SAAS,CAAC,MAAhD,EAAwD;AACtD,eAAO,SAAS,CAAC,MAAjB;AACD;;AACD,aAAO,SAAS,CAAC,MAAjB;;AACF,SAAK,YAAL;AACE,UAAM,QAAQ,GAAG,CAAA,EAAA,GAAA,IAAI,CAAC,UAAL,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,UAAlC;;AACA,UAAI,CAAC,QAAL,EAAe;AACb,eAAO,SAAS,CAAC,IAAjB;AACD;;AACD,aAAO,WAAW,CAAC,QAAQ,CAAC,IAAT,CAAc,EAAf,CAAX,CAA8B,UAArC;;AACF,SAAK,iBAAL;AACE,aAAO,OAAO,CAAC,WAAW,CAAC,IAAD,EAAO,IAAP,CAAZ,CAAd;;AACF;AACE,aAAO,SAAS,CAAC,IAAjB;AArCJ;AAuCD","sourceRoot":"","sourcesContent":["// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { AggregateExpr, BinaryExpr, Expr, FunctionCall, MatrixSelector, NumberLiteral, OffsetExpr, ParenExpr, StepInvariantExpr, StringLiteral, SubqueryExpr, UnaryExpr, VectorSelector, } from 'lezer-promql';\nimport { walkThrough } from './path-finder';\nimport { getFunction, ValueType } from '../types';\n// Based on https://github.com/prometheus/prometheus/blob/d668a7efe3107dbdcc67bf4e9f12430ed8e2b396/promql/parser/ast.go#L191\nexport function getType(node) {\n    var _a;\n    if (!node) {\n        return ValueType.none;\n    }\n    switch (node.type.id) {\n        case Expr:\n            return getType(node.firstChild);\n        case AggregateExpr:\n            return ValueType.vector;\n        case VectorSelector:\n            return ValueType.vector;\n        case OffsetExpr:\n            return getType(node.firstChild);\n        case StringLiteral:\n            return ValueType.string;\n        case NumberLiteral:\n            return ValueType.scalar;\n        case MatrixSelector:\n            return ValueType.matrix;\n        case SubqueryExpr:\n            return ValueType.matrix;\n        case ParenExpr:\n            return getType(walkThrough(node, Expr));\n        case UnaryExpr:\n            return getType(walkThrough(node, Expr));\n        case BinaryExpr:\n            const lt = getType(node.firstChild);\n            const rt = getType(node.lastChild);\n            if (lt === ValueType.scalar && rt === ValueType.scalar) {\n                return ValueType.scalar;\n            }\n            return ValueType.vector;\n        case FunctionCall:\n            const funcNode = (_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild;\n            if (!funcNode) {\n                return ValueType.none;\n            }\n            return getFunction(funcNode.type.id).returnType;\n        case StepInvariantExpr:\n            return getType(walkThrough(node, Expr));\n        default:\n            return ValueType.none;\n    }\n}\n//# sourceMappingURL=type.js.map"]},"metadata":{},"sourceType":"module"}