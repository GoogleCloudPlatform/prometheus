{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelMatchersToString = exports.buildLabelMatchers = void 0;\n\nvar lezer_promql_1 = require(\"lezer-promql\");\n\nvar types_1 = require(\"../types\");\n\nfunction createMatcher(labelMatcher, state) {\n  var matcher = new types_1.Matcher(0, '', '');\n  var cursor = labelMatcher.cursor;\n\n  if (!cursor.next()) {\n    // weird case, that would mean the labelMatcher doesn't have any child.\n    return matcher;\n  }\n\n  do {\n    switch (cursor.type.id) {\n      case lezer_promql_1.LabelName:\n        matcher.name = state.sliceDoc(cursor.from, cursor.to);\n        break;\n\n      case lezer_promql_1.MatchOp:\n        var ope = cursor.node.firstChild;\n\n        if (ope) {\n          matcher.type = ope.type.id;\n        }\n\n        break;\n\n      case lezer_promql_1.StringLiteral:\n        matcher.value = state.sliceDoc(cursor.from, cursor.to).slice(1, -1);\n        break;\n    }\n  } while (cursor.nextSibling());\n\n  return matcher;\n}\n\nfunction buildLabelMatchers(labelMatchers, state) {\n  var matchers = [];\n  labelMatchers.forEach(function (value) {\n    matchers.push(createMatcher(value, state));\n  });\n  return matchers;\n}\n\nexports.buildLabelMatchers = buildLabelMatchers;\n\nfunction labelMatchersToString(metricName, matchers, labelName) {\n  var e_1, _a;\n\n  if (!matchers || matchers.length === 0) {\n    return metricName;\n  }\n\n  var matchersAsString = '';\n\n  try {\n    for (var matchers_1 = __values(matchers), matchers_1_1 = matchers_1.next(); !matchers_1_1.done; matchers_1_1 = matchers_1.next()) {\n      var matcher = matchers_1_1.value;\n\n      if (matcher.name === labelName || matcher.value === '') {\n        continue;\n      }\n\n      var type = '';\n\n      switch (matcher.type) {\n        case lezer_promql_1.EqlSingle:\n          type = '=';\n          break;\n\n        case lezer_promql_1.Neq:\n          type = '!=';\n          break;\n\n        case lezer_promql_1.NeqRegex:\n          type = '!~';\n          break;\n\n        case lezer_promql_1.EqlRegex:\n          type = '=~';\n          break;\n\n        default:\n          type = '=';\n      }\n\n      var m = \"\" + matcher.name + type + \"\\\"\" + matcher.value + \"\\\"\";\n\n      if (matchersAsString === '') {\n        matchersAsString = m;\n      } else {\n        matchersAsString = matchersAsString + \",\" + m;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (matchers_1_1 && !matchers_1_1.done && (_a = matchers_1.return)) _a.call(matchers_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return metricName + \"{\" + matchersAsString + \"}\";\n}\n\nexports.labelMatchersToString = labelMatchersToString;","map":{"version":3,"sources":["../../../src/lang-promql/parser/matcher.ts"],"names":[],"mappings":"cAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAGA,IAAA,cAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,SAAS,aAAT,CAAuB,YAAvB,EAAiD,KAAjD,EAAmE;AACjE,MAAM,OAAO,GAAG,IAAI,OAAA,CAAA,OAAJ,CAAY,CAAZ,EAAe,EAAf,EAAmB,EAAnB,CAAhB;AACA,MAAM,MAAM,GAAG,YAAY,CAAC,MAA5B;;AACA,MAAI,CAAC,MAAM,CAAC,IAAP,EAAL,EAAoB;AAClB;AACA,WAAO,OAAP;AACD;;AACD,KAAG;AACD,YAAQ,MAAM,CAAC,IAAP,CAAY,EAApB;AACE,WAAK,cAAA,CAAA,SAAL;AACE,QAAA,OAAO,CAAC,IAAR,GAAe,KAAK,CAAC,QAAN,CAAe,MAAM,CAAC,IAAtB,EAA4B,MAAM,CAAC,EAAnC,CAAf;AACA;;AACF,WAAK,cAAA,CAAA,OAAL;AACE,YAAM,GAAG,GAAG,MAAM,CAAC,IAAP,CAAY,UAAxB;;AACA,YAAI,GAAJ,EAAS;AACP,UAAA,OAAO,CAAC,IAAR,GAAe,GAAG,CAAC,IAAJ,CAAS,EAAxB;AACD;;AACD;;AACF,WAAK,cAAA,CAAA,aAAL;AACE,QAAA,OAAO,CAAC,KAAR,GAAgB,KAAK,CAAC,QAAN,CAAe,MAAM,CAAC,IAAtB,EAA4B,MAAM,CAAC,EAAnC,EAAuC,KAAvC,CAA6C,CAA7C,EAAgD,CAAC,CAAjD,CAAhB;AACA;AAZJ;AAcD,GAfD,QAeS,MAAM,CAAC,WAAP,EAfT;;AAgBA,SAAO,OAAP;AACD;;AAED,SAAgB,kBAAhB,CAAmC,aAAnC,EAAgE,KAAhE,EAAkF;AAChF,MAAM,QAAQ,GAAc,EAA5B;AACA,EAAA,aAAa,CAAC,OAAd,CAAsB,UAAC,KAAD,EAAM;AAC1B,IAAA,QAAQ,CAAC,IAAT,CAAc,aAAa,CAAC,KAAD,EAAQ,KAAR,CAA3B;AACD,GAFD;AAGA,SAAO,QAAP;AACD;;AAND,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAQA,SAAgB,qBAAhB,CAAsC,UAAtC,EAA0D,QAA1D,EAAgF,SAAhF,EAAkG;;;AAChG,MAAI,CAAC,QAAD,IAAa,QAAQ,CAAC,MAAT,KAAoB,CAArC,EAAwC;AACtC,WAAO,UAAP;AACD;;AAED,MAAI,gBAAgB,GAAG,EAAvB;;;AACA,SAAsB,IAAA,UAAA,GAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAA8B,CAAA,YAAA,CAAA,IAA9B,EAA8B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAAgC;AAA3B,UAAM,OAAO,GAAA,YAAA,CAAA,KAAb;;AACH,UAAI,OAAO,CAAC,IAAR,KAAiB,SAAjB,IAA8B,OAAO,CAAC,KAAR,KAAkB,EAApD,EAAwD;AACtD;AACD;;AACD,UAAI,IAAI,GAAG,EAAX;;AACA,cAAQ,OAAO,CAAC,IAAhB;AACE,aAAK,cAAA,CAAA,SAAL;AACE,UAAA,IAAI,GAAG,GAAP;AACA;;AACF,aAAK,cAAA,CAAA,GAAL;AACE,UAAA,IAAI,GAAG,IAAP;AACA;;AACF,aAAK,cAAA,CAAA,QAAL;AACE,UAAA,IAAI,GAAG,IAAP;AACA;;AACF,aAAK,cAAA,CAAA,QAAL;AACE,UAAA,IAAI,GAAG,IAAP;AACA;;AACF;AACE,UAAA,IAAI,GAAG,GAAP;AAdJ;;AAgBA,UAAM,CAAC,GAAG,KAAG,OAAO,CAAC,IAAX,GAAkB,IAAlB,GAAsB,IAAtB,GAA0B,OAAO,CAAC,KAAlC,GAAuC,IAAjD;;AACA,UAAI,gBAAgB,KAAK,EAAzB,EAA6B;AAC3B,QAAA,gBAAgB,GAAG,CAAnB;AACD,OAFD,MAEO;AACL,QAAA,gBAAgB,GAAM,gBAAgB,GAAA,GAAhB,GAAoB,CAA1C;AACD;AACF;;;;;;;;;;;;;AACD,SAAU,UAAU,GAAA,GAAV,GAAc,gBAAd,GAA8B,GAAxC;AACD;;AAnCD,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.labelMatchersToString = exports.buildLabelMatchers = void 0;\nvar lezer_promql_1 = require(\"lezer-promql\");\nvar types_1 = require(\"../types\");\nfunction createMatcher(labelMatcher, state) {\n    var matcher = new types_1.Matcher(0, '', '');\n    var cursor = labelMatcher.cursor;\n    if (!cursor.next()) {\n        // weird case, that would mean the labelMatcher doesn't have any child.\n        return matcher;\n    }\n    do {\n        switch (cursor.type.id) {\n            case lezer_promql_1.LabelName:\n                matcher.name = state.sliceDoc(cursor.from, cursor.to);\n                break;\n            case lezer_promql_1.MatchOp:\n                var ope = cursor.node.firstChild;\n                if (ope) {\n                    matcher.type = ope.type.id;\n                }\n                break;\n            case lezer_promql_1.StringLiteral:\n                matcher.value = state.sliceDoc(cursor.from, cursor.to).slice(1, -1);\n                break;\n        }\n    } while (cursor.nextSibling());\n    return matcher;\n}\nfunction buildLabelMatchers(labelMatchers, state) {\n    var matchers = [];\n    labelMatchers.forEach(function (value) {\n        matchers.push(createMatcher(value, state));\n    });\n    return matchers;\n}\nexports.buildLabelMatchers = buildLabelMatchers;\nfunction labelMatchersToString(metricName, matchers, labelName) {\n    var e_1, _a;\n    if (!matchers || matchers.length === 0) {\n        return metricName;\n    }\n    var matchersAsString = '';\n    try {\n        for (var matchers_1 = __values(matchers), matchers_1_1 = matchers_1.next(); !matchers_1_1.done; matchers_1_1 = matchers_1.next()) {\n            var matcher = matchers_1_1.value;\n            if (matcher.name === labelName || matcher.value === '') {\n                continue;\n            }\n            var type = '';\n            switch (matcher.type) {\n                case lezer_promql_1.EqlSingle:\n                    type = '=';\n                    break;\n                case lezer_promql_1.Neq:\n                    type = '!=';\n                    break;\n                case lezer_promql_1.NeqRegex:\n                    type = '!~';\n                    break;\n                case lezer_promql_1.EqlRegex:\n                    type = '=~';\n                    break;\n                default:\n                    type = '=';\n            }\n            var m = \"\" + matcher.name + type + \"\\\"\" + matcher.value + \"\\\"\";\n            if (matchersAsString === '') {\n                matchersAsString = m;\n            }\n            else {\n                matchersAsString = matchersAsString + \",\" + m;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (matchers_1_1 && !matchers_1_1.done && (_a = matchers_1.return)) _a.call(matchers_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return metricName + \"{\" + matchersAsString + \"}\";\n}\nexports.labelMatchersToString = labelMatchersToString;\n//# sourceMappingURL=matcher.js.map"]},"metadata":{},"sourceType":"script"}