{"ast":null,"code":"import _toConsumableArray from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { EditorView, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, Prec } from '@codemirror/state';\nimport { showPanel, getPanel } from '@codemirror/panel';\nimport { RangeSetBuilder } from '@codemirror/rangeset';\nimport elt from 'crelt';\nimport { codePointAt, fromCodePoint, codePointSize, findClusterBreak } from '@codemirror/text';\nvar basicNormalize = typeof String.prototype.normalize == \"function\" ? function (x) {\n  return x.normalize(\"NFKD\");\n} : function (x) {\n  return x;\n};\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\n\nvar SearchCursor = /*#__PURE__*/function () {\n  /**\n  Create a text cursor. The query is the search string, `from` to\n  `to` provides the region to search.\n  \n  When `normalize` is given, it will be called, on both the query\n  string and the content it is matched against, before comparing.\n  You can, for example, create a case-insensitive search by\n  passing `s => s.toLowerCase()`.\n  \n  Text is always normalized with\n  [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n  (when supported).\n  */\n  function SearchCursor(text, query) {\n    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : text.length;\n    var normalize = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, SearchCursor);\n\n    /**\n    The current match (only holds a meaningful value after\n    [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n    `done` is false).\n    */\n    this.value = {\n      from: 0,\n      to: 0\n    };\n    /**\n    Whether the end of the iterated region has been reached.\n    */\n\n    this.done = false;\n    this.matches = [];\n    this.buffer = \"\";\n    this.bufferPos = 0;\n    this.iter = text.iterRange(from, to);\n    this.bufferStart = from;\n    this.normalize = normalize ? function (x) {\n      return normalize(basicNormalize(x));\n    } : basicNormalize;\n    this.query = this.normalize(query);\n  }\n\n  _createClass(SearchCursor, [{\n    key: \"peek\",\n    value: function peek() {\n      if (this.bufferPos == this.buffer.length) {\n        this.bufferStart += this.buffer.length;\n        this.iter.next();\n        if (this.iter.done) return -1;\n        this.bufferPos = 0;\n        this.buffer = this.iter.value;\n      }\n\n      return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      while (this.matches.length) {\n        this.matches.pop();\n      }\n\n      return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n\n  }, {\n    key: \"nextOverlapping\",\n    value: function nextOverlapping() {\n      for (;;) {\n        var next = this.peek();\n\n        if (next < 0) {\n          this.done = true;\n          return this;\n        }\n\n        var str = fromCodePoint(next),\n            start = this.bufferStart + this.bufferPos;\n        this.bufferPos += codePointSize(next);\n        var norm = this.normalize(str);\n\n        for (var i = 0, pos = start;; i++) {\n          var code = norm.charCodeAt(i);\n          var match = this.match(code, pos);\n\n          if (match) {\n            this.value = match;\n            return this;\n          }\n\n          if (i == norm.length - 1) break;\n          if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n        }\n      }\n    }\n  }, {\n    key: \"match\",\n    value: function match(code, pos) {\n      var match = null;\n\n      for (var i = 0; i < this.matches.length; i += 2) {\n        var index = this.matches[i],\n            keep = false;\n\n        if (this.query.charCodeAt(index) == code) {\n          if (index == this.query.length - 1) {\n            match = {\n              from: this.matches[i + 1],\n              to: pos + 1\n            };\n          } else {\n            this.matches[i]++;\n            keep = true;\n          }\n        }\n\n        if (!keep) {\n          this.matches.splice(i, 2);\n          i -= 2;\n        }\n      }\n\n      if (this.query.charCodeAt(0) == code) {\n        if (this.query.length == 1) match = {\n          from: pos,\n          to: pos + 1\n        };else this.matches.push(1, pos);\n      }\n\n      return match;\n    }\n  }]);\n\n  return SearchCursor;\n}();\n\nvar empty = {\n  from: -1,\n  to: -1,\n  match: /.*/.exec(\"\")\n};\nvar baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n\nvar RegExpCursor = /*#__PURE__*/function () {\n  function RegExpCursor(text, query, options) {\n    var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : text.length;\n\n    _classCallCheck(this, RegExpCursor);\n\n    this.to = to;\n    this.curLine = \"\";\n    this.done = false;\n    this.value = empty;\n    if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.iter = text.iter();\n    var startLine = text.lineAt(from);\n    this.curLineStart = startLine.from;\n    this.matchPos = from;\n    this.getLine(this.curLineStart);\n  }\n\n  _createClass(RegExpCursor, [{\n    key: \"getLine\",\n    value: function getLine(skip) {\n      this.iter.next(skip);\n\n      if (this.iter.lineBreak) {\n        this.curLine = \"\";\n      } else {\n        this.curLine = this.iter.value;\n        if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n        this.iter.next();\n      }\n    }\n  }, {\n    key: \"nextLine\",\n    value: function nextLine() {\n      this.curLineStart = this.curLineStart + this.curLine.length + 1;\n      if (this.curLineStart > this.to) this.curLine = \"\";else this.getLine(0);\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (var off = this.matchPos - this.curLineStart;;) {\n        this.re.lastIndex = off;\n        var match = this.matchPos <= this.to && this.re.exec(this.curLine);\n\n        if (match) {\n          var from = this.curLineStart + match.index,\n              to = from + match[0].length;\n          this.matchPos = to + (from == to ? 1 : 0);\n          if (from == this.curLine.length) this.nextLine();\n\n          if (from < to || from > this.value.to) {\n            this.value = {\n              from: from,\n              to: to,\n              match: match\n            };\n            return this;\n          }\n\n          off = this.matchPos - this.curLineStart;\n        } else if (this.curLineStart + this.curLine.length < this.to) {\n          this.nextLine();\n          off = 0;\n        } else {\n          this.done = true;\n          return this;\n        }\n      }\n    }\n  }]);\n\n  return RegExpCursor;\n}();\n\nvar flattened = new WeakMap(); // Reusable (partially) flattened document strings\n\nvar FlattenedDoc = /*#__PURE__*/function () {\n  function FlattenedDoc(from, text) {\n    _classCallCheck(this, FlattenedDoc);\n\n    this.from = from;\n    this.text = text;\n  }\n\n  _createClass(FlattenedDoc, [{\n    key: \"to\",\n    get: function get() {\n      return this.from + this.text.length;\n    }\n  }], [{\n    key: \"get\",\n    value: function get(doc, from, to) {\n      var cached = flattened.get(doc);\n\n      if (!cached || cached.from >= to || cached.to <= from) {\n        var flat = new FlattenedDoc(from, doc.sliceString(from, to));\n        flattened.set(doc, flat);\n        return flat;\n      }\n\n      if (cached.from == from && cached.to == to) return cached;\n      var text = cached.text,\n          cachedFrom = cached.from;\n\n      if (cachedFrom > from) {\n        text = doc.sliceString(from, cachedFrom) + text;\n        cachedFrom = from;\n      }\n\n      if (cached.to < to) text += doc.sliceString(cached.to, to);\n      flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n      return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n  }]);\n\n  return FlattenedDoc;\n}();\n\nvar MultilineRegExpCursor = /*#__PURE__*/function () {\n  function MultilineRegExpCursor(text, query, options, from, to) {\n    _classCallCheck(this, MultilineRegExpCursor);\n\n    this.text = text;\n    this.to = to;\n    this.done = false;\n    this.value = empty;\n    this.matchPos = from;\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000\n    /* Base */\n    ));\n  }\n\n  _createClass(MultilineRegExpCursor, [{\n    key: \"chunkEnd\",\n    value: function chunkEnd(pos) {\n      return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (;;) {\n        var off = this.re.lastIndex = this.matchPos - this.flat.from;\n        var match = this.re.exec(this.flat.text); // Skip empty matches directly after the last match\n\n        if (match && !match[0] && match.index == off) {\n          this.re.lastIndex = off + 1;\n          match = this.re.exec(this.flat.text);\n        } // If a match goes almost to the end of a noncomplete chunk, try\n        // again, since it'll likely be able to match more\n\n\n        if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10) match = null;\n\n        if (match) {\n          var from = this.flat.from + match.index,\n              to = from + match[0].length;\n          this.value = {\n            from: from,\n            to: to,\n            match: match\n          };\n          this.matchPos = to + (from == to ? 1 : 0);\n          return this;\n        } else {\n          if (this.flat.to == this.to) {\n            this.done = true;\n            return this;\n          } // Grow the flattened doc\n\n\n          this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n      }\n    }\n  }]);\n\n  return MultilineRegExpCursor;\n}();\n\nfunction validRegExp(source) {\n  try {\n    new RegExp(source, baseFlags);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction createLineDialog(view) {\n  var input = elt(\"input\", {\n    class: \"cm-textfield\",\n    name: \"line\"\n  });\n  var dom = elt(\"form\", {\n    class: \"cm-gotoLine\",\n    onkeydown: function onkeydown(event) {\n      if (event.keyCode == 27) {\n        // Escape\n        event.preventDefault();\n        view.dispatch({\n          effects: dialogEffect.of(false)\n        });\n        view.focus();\n      } else if (event.keyCode == 13) {\n        // Enter\n        event.preventDefault();\n        go();\n      }\n    },\n    onsubmit: function onsubmit(event) {\n      event.preventDefault();\n      go();\n    }\n  }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", {\n    class: \"cm-button\",\n    type: \"submit\"\n  }, view.state.phrase(\"go\")));\n\n  function go() {\n    var match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n    if (!match) return;\n    var state = view.state,\n        startLine = state.doc.lineAt(state.selection.main.head);\n\n    var _match = _slicedToArray(match, 5),\n        sign = _match[1],\n        ln = _match[2],\n        cl = _match[3],\n        percent = _match[4];\n\n    var col = cl ? +cl.slice(1) : 0;\n    var line = ln ? +ln : startLine.number;\n\n    if (ln && percent) {\n      var pc = line / 100;\n      if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n      line = Math.round(state.doc.lines * pc);\n    } else if (ln && sign) {\n      line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n    }\n\n    var docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n    view.dispatch({\n      effects: dialogEffect.of(false),\n      selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n      scrollIntoView: true\n    });\n    view.focus();\n  }\n\n  return {\n    dom: dom,\n    pos: -10\n  };\n}\n\nvar dialogEffect = StateEffect.define();\nvar dialogField = StateField.define({\n  create: function create() {\n    return true;\n  },\n  update: function update(value, tr) {\n    var _iterator = _createForOfIteratorHelper(tr.effects),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var e = _step.value;\n        if (e.is(dialogEffect)) value = e.value;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return value;\n  },\n  provide: function provide(f) {\n    return showPanel.from(f, function (val) {\n      return val ? createLineDialog : null;\n    });\n  }\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\n\nvar gotoLine = function gotoLine(view) {\n  var panel = getPanel(view, createLineDialog);\n\n  if (!panel) {\n    var effects = [dialogEffect.of(true)];\n    if (view.state.field(dialogField, false) == null) effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n    view.dispatch({\n      effects: effects\n    });\n    panel = getPanel(view, createLineDialog);\n  }\n\n  if (panel) panel.dom.querySelector(\"input\").focus();\n  return true;\n};\n\nvar baseTheme$1 = EditorView.baseTheme({\n  \".cm-panel.cm-gotoLine\": {\n    padding: \"2px 6px 4px\",\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  }\n});\nvar defaultHighlightOptions = {\n  highlightWordAroundCursor: false,\n  minSelectionLength: 1,\n  maxMatches: 100\n};\nvar highlightConfig = Facet.define({\n  combine: function combine(options) {\n    return combineConfig(options, defaultHighlightOptions, {\n      highlightWordAroundCursor: function highlightWordAroundCursor(a, b) {\n        return a || b;\n      },\n      minSelectionLength: Math.min,\n      maxMatches: Math.min\n    });\n  }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\n\nfunction highlightSelectionMatches(options) {\n  var ext = [defaultTheme, matchHighlighter];\n  if (options) ext.push(highlightConfig.of(options));\n  return ext;\n}\n\nfunction wordAt(doc, pos, check) {\n  var line = doc.lineAt(pos);\n  var from = pos - line.from,\n      to = pos - line.from;\n\n  while (from > 0) {\n    var prev = findClusterBreak(line.text, from, false);\n    if (check(line.text.slice(prev, from)) != CharCategory.Word) break;\n    from = prev;\n  }\n\n  while (to < line.length) {\n    var next = findClusterBreak(line.text, to);\n    if (check(line.text.slice(to, next)) != CharCategory.Word) break;\n    to = next;\n  }\n\n  return from == to ? null : line.text.slice(from, to);\n}\n\nvar matchDeco = Decoration.mark({\n  class: \"cm-selectionMatch\"\n});\nvar mainMatchDeco = Decoration.mark({\n  class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\nvar matchHighlighter = ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.decorations = this.getDeco(view);\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update) {\n      if (_update.selectionSet || _update.docChanged || _update.viewportChanged) this.decorations = this.getDeco(_update.view);\n    }\n  }, {\n    key: \"getDeco\",\n    value: function getDeco(view) {\n      var conf = view.state.facet(highlightConfig);\n      var state = view.state,\n          sel = state.selection;\n      if (sel.ranges.length > 1) return Decoration.none;\n      var range = sel.main,\n          query,\n          check = null;\n\n      if (range.empty) {\n        if (!conf.highlightWordAroundCursor) return Decoration.none;\n        check = state.charCategorizer(range.head);\n        query = wordAt(state.doc, range.head, check);\n        if (!query) return Decoration.none;\n      } else {\n        var len = range.to - range.from;\n        if (len < conf.minSelectionLength || len > 200) return Decoration.none;\n        query = state.sliceDoc(range.from, range.to).trim();\n        if (!query) return Decoration.none;\n      }\n\n      var deco = [];\n\n      var _iterator2 = _createForOfIteratorHelper(view.visibleRanges),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var part = _step2.value;\n          var cursor = new SearchCursor(state.doc, query, part.from, part.to);\n\n          while (!cursor.nextOverlapping().done) {\n            var _cursor$value = cursor.value,\n                from = _cursor$value.from,\n                to = _cursor$value.to;\n\n            if (!check || (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word)) {\n              if (check && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n              if (deco.length > conf.maxMatches) return Decoration.none;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return Decoration.set(deco);\n    }\n  }]);\n\n  return _class;\n}(), {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n});\nvar defaultTheme = EditorView.baseTheme({\n  \".cm-selectionMatch\": {\n    backgroundColor: \"#99ff7780\"\n  },\n  \".cm-searchMatch .cm-selectionMatch\": {\n    backgroundColor: \"transparent\"\n  }\n});\n\nvar Query = /*#__PURE__*/function () {\n  function Query(search, replace, caseInsensitive) {\n    _classCallCheck(this, Query);\n\n    this.search = search;\n    this.replace = replace;\n    this.caseInsensitive = caseInsensitive;\n  }\n\n  _createClass(Query, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return this.search == other.search && this.replace == other.replace && this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;\n    }\n  }]);\n\n  return Query;\n}();\n\nvar StringQuery = /*#__PURE__*/function (_Query) {\n  _inherits(StringQuery, _Query);\n\n  var _super = _createSuper(StringQuery);\n\n  function StringQuery(search, replace, caseInsensitive) {\n    var _this;\n\n    _classCallCheck(this, StringQuery);\n\n    _this = _super.call(this, search, replace, caseInsensitive);\n    _this.unquoted = search.replace(/\\\\([nrt\\\\])/g, function (_, ch) {\n      return ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\";\n    });\n    return _this;\n  }\n\n  _createClass(StringQuery, [{\n    key: \"cursor\",\n    value: function cursor(doc) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : doc.length;\n      return new SearchCursor(doc, this.unquoted, from, to, this.caseInsensitive ? function (x) {\n        return x.toLowerCase();\n      } : undefined);\n    }\n  }, {\n    key: \"nextMatch\",\n    value: function nextMatch(doc, curFrom, curTo) {\n      var cursor = this.cursor(doc, curTo).nextOverlapping();\n      if (cursor.done) cursor = this.cursor(doc, 0, curFrom).nextOverlapping();\n      return cursor.done ? null : cursor.value;\n    } // Searching in reverse is, rather than implementing inverted search\n    // cursor, done by scanning chunk after chunk forward.\n\n  }, {\n    key: \"prevMatchInRange\",\n    value: function prevMatchInRange(doc, from, to) {\n      for (var pos = to;;) {\n        var start = Math.max(from, pos - 10000\n        /* ChunkSize */\n        - this.unquoted.length);\n        var cursor = this.cursor(doc, start, pos),\n            range = null;\n\n        while (!cursor.nextOverlapping().done) {\n          range = cursor.value;\n        }\n\n        if (range) return range;\n        if (start == from) return null;\n        pos -= 10000\n        /* ChunkSize */\n        ;\n      }\n    }\n  }, {\n    key: \"prevMatch\",\n    value: function prevMatch(doc, curFrom, curTo) {\n      return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n    }\n  }, {\n    key: \"getReplacement\",\n    value: function getReplacement(_result) {\n      return this.replace;\n    }\n  }, {\n    key: \"matchAll\",\n    value: function matchAll(doc, limit) {\n      var cursor = this.cursor(doc),\n          ranges = [];\n\n      while (!cursor.next().done) {\n        if (ranges.length >= limit) return null;\n        ranges.push(cursor.value);\n      }\n\n      return ranges;\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(doc, from, to, add) {\n      var cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));\n\n      while (!cursor.next().done) {\n        add(cursor.value.from, cursor.value.to);\n      }\n    }\n  }, {\n    key: \"valid\",\n    get: function get() {\n      return !!this.search;\n    }\n  }]);\n\n  return StringQuery;\n}(Query);\n\nvar RegExpQuery = /*#__PURE__*/function (_Query2) {\n  _inherits(RegExpQuery, _Query2);\n\n  var _super2 = _createSuper(RegExpQuery);\n\n  function RegExpQuery(search, replace, caseInsensitive) {\n    var _this2;\n\n    _classCallCheck(this, RegExpQuery);\n\n    _this2 = _super2.call(this, search, replace, caseInsensitive);\n    _this2.valid = !!search && validRegExp(search);\n    return _this2;\n  }\n\n  _createClass(RegExpQuery, [{\n    key: \"cursor\",\n    value: function cursor(doc) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : doc.length;\n      return new RegExpCursor(doc, this.search, this.caseInsensitive ? {\n        ignoreCase: true\n      } : undefined, from, to);\n    }\n  }, {\n    key: \"nextMatch\",\n    value: function nextMatch(doc, curFrom, curTo) {\n      var cursor = this.cursor(doc, curTo).next();\n      if (cursor.done) cursor = this.cursor(doc, 0, curFrom).next();\n      return cursor.done ? null : cursor.value;\n    }\n  }, {\n    key: \"prevMatchInRange\",\n    value: function prevMatchInRange(doc, from, to) {\n      for (var size = 1;; size++) {\n        var start = Math.max(from, to - size * 10000\n        /* ChunkSize */\n        );\n        var cursor = this.cursor(doc, start, to),\n            range = null;\n\n        while (!cursor.next().done) {\n          range = cursor.value;\n        }\n\n        if (range && (start == from || range.from > start + 10)) return range;\n        if (start == from) return null;\n      }\n    }\n  }, {\n    key: \"prevMatch\",\n    value: function prevMatch(doc, curFrom, curTo) {\n      return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n    }\n  }, {\n    key: \"getReplacement\",\n    value: function getReplacement(result) {\n      return this.replace.replace(/\\$([$&\\d+])/g, function (m, i) {\n        return i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m;\n      });\n    }\n  }, {\n    key: \"matchAll\",\n    value: function matchAll(doc, limit) {\n      var cursor = this.cursor(doc),\n          ranges = [];\n\n      while (!cursor.next().done) {\n        if (ranges.length >= limit) return null;\n        ranges.push(cursor.value);\n      }\n\n      return ranges;\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(doc, from, to, add) {\n      var cursor = this.cursor(doc, Math.max(0, from - 250\n      /* HighlightMargin */\n      ), Math.min(to + 250\n      /* HighlightMargin */\n      , doc.length));\n\n      while (!cursor.next().done) {\n        add(cursor.value.from, cursor.value.to);\n      }\n    }\n  }]);\n\n  return RegExpQuery;\n}(Query);\n\nvar setQuery = StateEffect.define();\nvar togglePanel = StateEffect.define();\nvar searchState = StateField.define({\n  create: function create() {\n    return new SearchState(new StringQuery(\"\", \"\", false), null);\n  },\n  update: function update(value, tr) {\n    var _iterator3 = _createForOfIteratorHelper(tr.effects),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var effect = _step3.value;\n        if (effect.is(setQuery)) value = new SearchState(effect.value, value.panel);else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return value;\n  },\n  provide: function provide(f) {\n    return showPanel.from(f, function (val) {\n      return val.panel;\n    });\n  }\n});\n\nvar SearchState = function SearchState(query, panel) {\n  _classCallCheck(this, SearchState);\n\n  this.query = query;\n  this.panel = panel;\n};\n\nvar matchMark = Decoration.mark({\n  class: \"cm-searchMatch\"\n}),\n    selectedMatchMark = Decoration.mark({\n  class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nvar searchHighlighter = ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class2(view) {\n    _classCallCheck(this, _class2);\n\n    this.view = view;\n    this.decorations = this.highlight(view.state.field(searchState));\n  }\n\n  _createClass(_class2, [{\n    key: \"update\",\n    value: function update(_update2) {\n      var state = _update2.state.field(searchState);\n\n      if (state != _update2.startState.field(searchState) || _update2.docChanged || _update2.selectionSet) this.decorations = this.highlight(state);\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(_ref) {\n      var query = _ref.query,\n          panel = _ref.panel;\n      if (!panel || !query.valid) return Decoration.none;\n      var view = this.view;\n      var builder = new RangeSetBuilder();\n\n      for (var i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n        var _ranges$i = ranges[i],\n            from = _ranges$i.from,\n            to = _ranges$i.to;\n\n        while (i < l - 1 && to > ranges[i + 1].from - 2 * 250\n        /* HighlightMargin */\n        ) {\n          to = ranges[++i].to;\n        }\n\n        query.highlight(view.state.doc, from, to, function (from, to) {\n          var selected = view.state.selection.ranges.some(function (r) {\n            return r.from == from && r.to == to;\n          });\n          builder.add(from, to, selected ? selectedMatchMark : matchMark);\n        });\n      }\n\n      return builder.finish();\n    }\n  }]);\n\n  return _class2;\n}(), {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n});\n\nfunction searchCommand(f) {\n  return function (view) {\n    var state = view.state.field(searchState, false);\n    return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n  };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\n\n\nvar findNext = searchCommand(function (view, _ref2) {\n  var query = _ref2.query;\n  var _view$state$selection = view.state.selection.main,\n      from = _view$state$selection.from,\n      to = _view$state$selection.to;\n  var next = query.nextMatch(view.state.doc, from, to);\n  if (!next || next.from == from && next.to == to) return false;\n  view.dispatch({\n    selection: {\n      anchor: next.from,\n      head: next.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, next)\n  });\n  return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\n\nvar findPrevious = searchCommand(function (view, _ref3) {\n  var query = _ref3.query;\n  var state = view.state,\n      _state$selection$main = state.selection.main,\n      from = _state$selection$main.from,\n      to = _state$selection$main.to;\n  var range = query.prevMatch(state.doc, from, to);\n  if (!range) return false;\n  view.dispatch({\n    selection: {\n      anchor: range.from,\n      head: range.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, range)\n  });\n  return true;\n});\n/**\nSelect all instances of the search query.\n*/\n\nvar selectMatches = searchCommand(function (view, _ref4) {\n  var query = _ref4.query;\n  var ranges = query.matchAll(view.state.doc, 1000);\n  if (!ranges || !ranges.length) return false;\n  view.dispatch({\n    selection: EditorSelection.create(ranges.map(function (r) {\n      return EditorSelection.range(r.from, r.to);\n    }))\n  });\n  return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\n\nvar selectSelectionMatches = function selectSelectionMatches(_ref5) {\n  var state = _ref5.state,\n      dispatch = _ref5.dispatch;\n  var sel = state.selection;\n  if (sel.ranges.length > 1 || sel.main.empty) return false;\n  var _sel$main = sel.main,\n      from = _sel$main.from,\n      to = _sel$main.to;\n  var ranges = [],\n      main = 0;\n\n  for (var cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n    if (ranges.length > 1000) return false;\n    if (cur.value.from == from) main = ranges.length;\n    ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n  }\n\n  dispatch(state.update({\n    selection: EditorSelection.create(ranges, main)\n  }));\n  return true;\n};\n/**\nReplace the current match of the search query.\n*/\n\n\nvar replaceNext = searchCommand(function (view, _ref6) {\n  var query = _ref6.query;\n  var state = view.state,\n      _state$selection$main2 = state.selection.main,\n      from = _state$selection$main2.from,\n      to = _state$selection$main2.to;\n  var next = query.nextMatch(state.doc, from, from);\n  if (!next) return false;\n  var changes = [],\n      selection,\n      replacement;\n\n  if (next.from == from && next.to == to) {\n    replacement = state.toText(query.getReplacement(next));\n    changes.push({\n      from: next.from,\n      to: next.to,\n      insert: replacement\n    });\n    next = query.nextMatch(state.doc, next.from, next.to);\n  }\n\n  if (next) {\n    var off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n    selection = {\n      anchor: next.from - off,\n      head: next.to - off\n    };\n  }\n\n  view.dispatch({\n    changes: changes,\n    selection: selection,\n    scrollIntoView: !!selection,\n    effects: next ? announceMatch(view, next) : undefined\n  });\n  return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\n\nvar replaceAll = searchCommand(function (view, _ref7) {\n  var query = _ref7.query;\n  var changes = query.matchAll(view.state.doc, 1e9).map(function (match) {\n    var from = match.from,\n        to = match.to;\n    return {\n      from: from,\n      to: to,\n      insert: query.getReplacement(match)\n    };\n  });\n  if (!changes.length) return false;\n  view.dispatch({\n    changes: changes\n  });\n  return true;\n});\n\nfunction createSearchPanel(view) {\n  var _view$state$field = view.state.field(searchState),\n      query = _view$state$field.query;\n\n  return {\n    dom: buildPanel({\n      view: view,\n      query: query,\n      updateQuery: function updateQuery(q) {\n        if (!query.eq(q)) {\n          query = q;\n          view.dispatch({\n            effects: setQuery.of(query)\n          });\n        }\n      }\n    }),\n    mount: function mount() {\n      this.dom.querySelector(\"[name=search]\").select();\n    },\n    pos: 80\n  };\n}\n/**\nMake sure the search panel is open and focused.\n*/\n\n\nvar openSearchPanel = function openSearchPanel(view) {\n  var state = view.state.field(searchState, false);\n\n  if (state && state.panel) {\n    var panel = getPanel(view, createSearchPanel);\n    if (!panel) return false;\n    panel.dom.querySelector(\"[name=search]\").focus();\n  } else {\n    view.dispatch({\n      effects: [togglePanel.of(true)].concat(_toConsumableArray(state ? [] : [StateEffect.appendConfig.of(searchExtensions)]))\n    });\n  }\n\n  return true;\n};\n/**\nClose the search panel.\n*/\n\n\nvar closeSearchPanel = function closeSearchPanel(view) {\n  var state = view.state.field(searchState, false);\n  if (!state || !state.panel) return false;\n  var panel = getPanel(view, createSearchPanel);\n  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n*/\n\n\nvar searchKeymap = [{\n  key: \"Mod-f\",\n  run: openSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"F3\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-g\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Escape\",\n  run: closeSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-Shift-l\",\n  run: selectSelectionMatches\n}, {\n  key: \"Alt-g\",\n  run: gotoLine\n}];\n\nfunction buildPanel(conf) {\n  function phrase(phrase) {\n    return conf.view.state.phrase(phrase);\n  }\n\n  var searchField = elt(\"input\", {\n    value: conf.query.search,\n    placeholder: phrase(\"Find\"),\n    \"aria-label\": phrase(\"Find\"),\n    class: \"cm-textfield\",\n    name: \"search\",\n    onchange: update,\n    onkeyup: update\n  });\n  var replaceField = elt(\"input\", {\n    value: conf.query.replace,\n    placeholder: phrase(\"Replace\"),\n    \"aria-label\": phrase(\"Replace\"),\n    class: \"cm-textfield\",\n    name: \"replace\",\n    onchange: update,\n    onkeyup: update\n  });\n  var caseField = elt(\"input\", {\n    type: \"checkbox\",\n    name: \"case\",\n    checked: !conf.query.caseInsensitive,\n    onchange: update\n  });\n  var reField = elt(\"input\", {\n    type: \"checkbox\",\n    name: \"re\",\n    checked: conf.query instanceof RegExpQuery,\n    onchange: update\n  });\n\n  function update() {\n    conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));\n  }\n\n  function keydown(e) {\n    if (runScopeHandlers(conf.view, e, \"search-panel\")) {\n      e.preventDefault();\n    } else if (e.keyCode == 13 && e.target == searchField) {\n      e.preventDefault();\n      (e.shiftKey ? findPrevious : findNext)(conf.view);\n    } else if (e.keyCode == 13 && e.target == replaceField) {\n      e.preventDefault();\n      replaceNext(conf.view);\n    }\n  }\n\n  function button(name, onclick, content) {\n    return elt(\"button\", {\n      class: \"cm-button\",\n      name: name,\n      onclick: onclick\n    }, content);\n  }\n\n  var panel = elt(\"div\", {\n    onkeydown: keydown,\n    class: \"cm-search\"\n  }, [searchField, button(\"next\", function () {\n    return findNext(conf.view);\n  }, [phrase(\"next\")]), button(\"prev\", function () {\n    return findPrevious(conf.view);\n  }, [phrase(\"previous\")]), button(\"select\", function () {\n    return selectMatches(conf.view);\n  }, [phrase(\"all\")]), elt(\"label\", null, [caseField, phrase(\"match case\")]), elt(\"label\", null, [reField, phrase(\"regexp\")]), elt(\"br\"), replaceField, button(\"replace\", function () {\n    return replaceNext(conf.view);\n  }, [phrase(\"replace\")]), button(\"replaceAll\", function () {\n    return replaceAll(conf.view);\n  }, [phrase(\"replace all\")]), elt(\"button\", {\n    name: \"close\",\n    onclick: function onclick() {\n      return closeSearchPanel(conf.view);\n    },\n    \"aria-label\": phrase(\"close\")\n  }, [\"Ã—\"])]);\n  return panel;\n}\n\nvar AnnounceMargin = 30;\nvar Break = /[\\s\\.,:;?!]/;\n\nfunction announceMatch(view, _ref8) {\n  var from = _ref8.from,\n      to = _ref8.to;\n  var lineStart = view.state.doc.lineAt(from).from,\n      lineEnd = view.state.doc.lineAt(to).to;\n  var start = Math.max(lineStart, from - AnnounceMargin),\n      end = Math.min(lineEnd, to + AnnounceMargin);\n  var text = view.state.sliceDoc(start, end);\n\n  if (start != lineStart) {\n    for (var i = 0; i < AnnounceMargin; i++) {\n      if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n        text = text.slice(i);\n        break;\n      }\n    }\n  }\n\n  if (end != lineEnd) {\n    for (var _i = text.length - 1; _i > text.length - AnnounceMargin; _i--) {\n      if (!Break.test(text[_i - 1]) && Break.test(text[_i])) {\n        text = text.slice(0, _i);\n        break;\n      }\n    }\n  }\n\n  return EditorView.announce.of(\"\".concat(view.state.phrase(\"current match\"), \". \").concat(text, \" \").concat(view.state.phrase(\"on line\"), \" \").concat(view.state.doc.lineAt(from).number));\n}\n\nvar baseTheme = EditorView.baseTheme({\n  \".cm-panel.cm-search\": {\n    padding: \"2px 6px 4px\",\n    position: \"relative\",\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"4px\",\n      backgroundColor: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    },\n    \"& input, & button, & label\": {\n      margin: \".2em .6em .2em 0\"\n    },\n    \"& input[type=checkbox]\": {\n      marginRight: \".2em\"\n    },\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  },\n  \"&light .cm-searchMatch\": {\n    backgroundColor: \"#ffff0054\"\n  },\n  \"&dark .cm-searchMatch\": {\n    backgroundColor: \"#00ffff8a\"\n  },\n  \"&light .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff6a0054\"\n  },\n  \"&dark .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff00ff8a\"\n  }\n});\nvar searchExtensions = [searchState, Prec.override(searchHighlighter), baseTheme];\nexport { RegExpCursor, SearchCursor, closeSearchPanel, findNext, findPrevious, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, searchKeymap, selectMatches, selectSelectionMatches };","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/@codemirror/search/dist/index.js"],"names":["EditorView","Decoration","ViewPlugin","runScopeHandlers","StateEffect","StateField","EditorSelection","Facet","combineConfig","CharCategory","Prec","showPanel","getPanel","RangeSetBuilder","elt","codePointAt","fromCodePoint","codePointSize","findClusterBreak","basicNormalize","String","prototype","normalize","x","SearchCursor","text","query","from","to","length","value","done","matches","buffer","bufferPos","iter","iterRange","bufferStart","next","pop","nextOverlapping","peek","str","start","norm","i","pos","code","charCodeAt","match","index","keep","splice","push","empty","exec","baseFlags","unicode","RegExpCursor","options","curLine","test","MultilineRegExpCursor","re","RegExp","ignoreCase","startLine","lineAt","curLineStart","matchPos","getLine","skip","lineBreak","slice","off","lastIndex","nextLine","flattened","WeakMap","FlattenedDoc","doc","cached","get","flat","sliceString","set","cachedFrom","chunkEnd","validRegExp","source","_a","createLineDialog","view","input","class","name","dom","onkeydown","event","keyCode","preventDefault","dispatch","effects","dialogEffect","of","focus","go","onsubmit","state","phrase","type","selection","main","head","sign","ln","cl","percent","col","line","number","pc","lines","Math","round","docLine","max","min","cursor","scrollIntoView","define","dialogField","create","update","tr","e","is","provide","f","val","gotoLine","panel","field","appendConfig","baseTheme$1","querySelector","baseTheme","padding","fontSize","defaultHighlightOptions","highlightWordAroundCursor","minSelectionLength","maxMatches","highlightConfig","combine","a","b","highlightSelectionMatches","ext","defaultTheme","matchHighlighter","wordAt","check","prev","Word","matchDeco","mark","mainMatchDeco","fromClass","decorations","getDeco","selectionSet","docChanged","viewportChanged","conf","facet","sel","ranges","none","range","charCategorizer","len","sliceDoc","trim","deco","visibleRanges","part","v","backgroundColor","Query","search","replace","caseInsensitive","other","constructor","StringQuery","unquoted","_","ch","toLowerCase","undefined","curFrom","curTo","prevMatchInRange","_result","limit","add","RegExpQuery","valid","size","result","m","setQuery","togglePanel","searchState","SearchState","effect","createSearchPanel","matchMark","selectedMatchMark","searchHighlighter","highlight","startState","builder","l","selected","some","r","finish","searchCommand","openSearchPanel","findNext","nextMatch","anchor","announceMatch","findPrevious","prevMatch","selectMatches","matchAll","map","selectSelectionMatches","cur","replaceNext","changes","replacement","toText","getReplacement","insert","replaceAll","buildPanel","updateQuery","q","eq","mount","select","searchExtensions","closeSearchPanel","contains","root","activeElement","searchKeymap","key","run","scope","shift","searchField","placeholder","onchange","onkeyup","replaceField","caseField","checked","reField","keydown","target","shiftKey","button","onclick","content","AnnounceMargin","Break","lineStart","lineEnd","end","announce","position","top","right","border","font","margin","marginRight","override"],"mappings":"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","sourcesContent":["import { EditorView, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, Prec } from '@codemirror/state';\nimport { showPanel, getPanel } from '@codemirror/panel';\nimport { RangeSetBuilder } from '@codemirror/rangeset';\nimport elt from 'crelt';\nimport { codePointAt, fromCodePoint, codePointSize, findClusterBreak } from '@codemirror/text';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize) {\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (match) {\n                    this.value = match;\n                    return this;\n                }\n                if (i == norm.length - 1)\n                    break;\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: pos + 1 };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: pos + 1 };\n            else\n                this.matches.push(1, pos);\n        }\n        return match;\n    }\n}\n\nconst empty = { from: -1, to: -1, match: /.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\nclass RegExpCursor {\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.to = to;\n        this.curLine = \"\";\n        this.done = false;\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = from;\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = to + (from == to ? 1 : 0);\n                if (from == this.curLine.length)\n                    this.nextLine();\n                if (from < to || from > this.value.to) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = from;\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            // If a match goes almost to the end of a noncomplete chunk, try\n            // again, since it'll likely be able to match more\n            if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)\n                match = null;\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                this.value = { from, to, match };\n                this.matchPos = to + (from == to ? 1 : 0);\n                return this;\n            }\n            else {\n                if (this.flat.to == this.to) {\n                    this.done = true;\n                    return this;\n                }\n                // Grow the flattened doc\n                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n            }\n        }\n    }\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\nfunction createLineDialog(view) {\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\" });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        view.dispatch({\n            effects: dialogEffect.of(false),\n            selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n            scrollIntoView: true\n        });\n        view.focus();\n    }\n    return { dom, pos: -10 };\n}\nconst dialogEffect = StateEffect.define();\nconst dialogField = StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").focus();\n    return true;\n};\nconst baseTheme$1 = EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100\n};\nconst highlightConfig = Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nfunction wordAt(doc, pos, check) {\n    let line = doc.lineAt(pos);\n    let from = pos - line.from, to = pos - line.from;\n    while (from > 0) {\n        let prev = findClusterBreak(line.text, from, false);\n        if (check(line.text.slice(prev, from)) != CharCategory.Word)\n            break;\n        from = prev;\n    }\n    while (to < line.length) {\n        let next = findClusterBreak(line.text, to);\n        if (check(line.text.slice(to, next)) != CharCategory.Word)\n            break;\n        to = next;\n    }\n    return from == to ? null : line.text.slice(from, to);\n}\nconst matchDeco = Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\nconst matchHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = wordAt(state.doc, range.head, check);\n            if (!query)\n                return Decoration.none;\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            query = state.sliceDoc(range.from, range.to).trim();\n            if (!query)\n                return Decoration.none;\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.nextOverlapping().done) {\n                let { from, to } = cursor.value;\n                if (!check || ((from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n                    (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word))) {\n                    if (check && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n\nclass Query {\n    constructor(search, replace, caseInsensitive) {\n        this.search = search;\n        this.replace = replace;\n        this.caseInsensitive = caseInsensitive;\n    }\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;\n    }\n}\nclass StringQuery extends Query {\n    constructor(search, replace, caseInsensitive) {\n        super(search, replace, caseInsensitive);\n        this.unquoted = search.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new SearchCursor(doc, this.unquoted, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);\n    }\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = this.cursor(doc, curTo).nextOverlapping();\n        if (cursor.done)\n            cursor = this.cursor(doc, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(doc, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* ChunkSize */ - this.unquoted.length);\n            let cursor = this.cursor(doc, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* ChunkSize */;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(_result) { return this.replace; }\n    matchAll(doc, limit) {\n        let cursor = this.cursor(doc), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n    get valid() { return !!this.search; }\n}\nclass RegExpQuery extends Query {\n    constructor(search, replace, caseInsensitive) {\n        super(search, replace, caseInsensitive);\n        this.valid = !!search && validRegExp(search);\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new RegExpCursor(doc, this.search, this.caseInsensitive ? { ignoreCase: true } : undefined, from, to);\n    }\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = this.cursor(doc, curTo).next();\n        if (cursor.done)\n            cursor = this.cursor(doc, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(doc, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* ChunkSize */);\n            let cursor = this.cursor(doc, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(result) {\n        return this.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m);\n    }\n    matchAll(doc, limit) {\n        let cursor = this.cursor(doc), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = this.cursor(doc, Math.max(0, from - 250 /* HighlightMargin */), Math.min(to + 250 /* HighlightMargin */, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nconst setQuery = StateEffect.define();\nconst togglePanel = StateEffect.define();\nconst searchState = StateField.define({\n    create() {\n        return new SearchState(new StringQuery(\"\", \"\", false), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setQuery))\n                value = new SearchState(effect.value, value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state.doc, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = searchCommand((view, { query }) => {\n    let { from, to } = view.state.selection.main;\n    let next = query.nextMatch(view.state.doc, from, to);\n    if (!next || next.from == from && next.to == to)\n        return false;\n    view.dispatch({\n        selection: { anchor: next.from, head: next.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, next)\n    });\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    let range = query.prevMatch(state.doc, from, to);\n    if (!range)\n        return false;\n    view.dispatch({\n        selection: { anchor: range.from, head: range.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, range)\n    });\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state.doc, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to)))\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({ selection: EditorSelection.create(ranges, main) }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    let next = query.nextMatch(state.doc, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state.doc, next.from, next.to);\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = { anchor: next.from - off, head: next.to - off };\n    }\n    view.dispatch({\n        changes, selection,\n        scrollIntoView: !!selection,\n        effects: next ? announceMatch(view, next) : undefined\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = searchCommand((view, { query }) => {\n    let changes = query.matchAll(view.state.doc, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    view.dispatch({ changes });\n    return true;\n});\nfunction createSearchPanel(view) {\n    let { query } = view.state.field(searchState);\n    return {\n        dom: buildPanel({\n            view,\n            query,\n            updateQuery(q) {\n                if (!query.eq(q)) {\n                    query = q;\n                    view.dispatch({ effects: setQuery.of(query) });\n                }\n            }\n        }),\n        mount() {\n            this.dom.querySelector(\"[name=search]\").select();\n        },\n        pos: 80\n    };\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let panel = getPanel(view, createSearchPanel);\n        if (!panel)\n            return false;\n        panel.dom.querySelector(\"[name=search]\").focus();\n    }\n    else {\n        view.dispatch({ effects: [togglePanel.of(true), ...state ? [] : [StateEffect.appendConfig.of(searchExtensions)]] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Alt-g\", run: gotoLine }\n];\nfunction buildPanel(conf) {\n    function phrase(phrase) { return conf.view.state.phrase(phrase); }\n    let searchField = elt(\"input\", {\n        value: conf.query.search,\n        placeholder: phrase(\"Find\"),\n        \"aria-label\": phrase(\"Find\"),\n        class: \"cm-textfield\",\n        name: \"search\",\n        onchange: update,\n        onkeyup: update\n    });\n    let replaceField = elt(\"input\", {\n        value: conf.query.replace,\n        placeholder: phrase(\"Replace\"),\n        \"aria-label\": phrase(\"Replace\"),\n        class: \"cm-textfield\",\n        name: \"replace\",\n        onchange: update,\n        onkeyup: update\n    });\n    let caseField = elt(\"input\", {\n        type: \"checkbox\",\n        name: \"case\",\n        checked: !conf.query.caseInsensitive,\n        onchange: update\n    });\n    let reField = elt(\"input\", {\n        type: \"checkbox\",\n        name: \"re\",\n        checked: conf.query instanceof RegExpQuery,\n        onchange: update\n    });\n    function update() {\n        conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));\n    }\n    function keydown(e) {\n        if (runScopeHandlers(conf.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(conf.view);\n        }\n        else if (e.keyCode == 13 && e.target == replaceField) {\n            e.preventDefault();\n            replaceNext(conf.view);\n        }\n    }\n    function button(name, onclick, content) {\n        return elt(\"button\", { class: \"cm-button\", name, onclick }, content);\n    }\n    let panel = elt(\"div\", { onkeydown: keydown, class: \"cm-search\" }, [\n        searchField,\n        button(\"next\", () => findNext(conf.view), [phrase(\"next\")]),\n        button(\"prev\", () => findPrevious(conf.view), [phrase(\"previous\")]),\n        button(\"select\", () => selectMatches(conf.view), [phrase(\"all\")]),\n        elt(\"label\", null, [caseField, phrase(\"match case\")]),\n        elt(\"label\", null, [reField, phrase(\"regexp\")]),\n        elt(\"br\"),\n        replaceField,\n        button(\"replace\", () => replaceNext(conf.view), [phrase(\"replace\")]),\n        button(\"replaceAll\", () => replaceAll(conf.view), [phrase(\"replace all\")]),\n        elt(\"button\", { name: \"close\", onclick: () => closeSearchPanel(conf.view), \"aria-label\": phrase(\"close\") }, [\"Ã—\"])\n    ]);\n    return panel;\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != lineStart) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${view.state.doc.lineAt(from).number}`);\n}\nconst baseTheme = EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    Prec.override(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, closeSearchPanel, findNext, findPrevious, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, searchKeymap, selectMatches, selectSelectionMatches };\n"]},"metadata":{},"sourceType":"module"}