{"ast":null,"code":"import _slicedToArray from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _toConsumableArray from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { Add, AggregateExpr, And, BinaryExpr, BinModifiers, Bool, Div, Duration, Eql, EqlRegex, EqlSingle, Expr, FunctionCallBody, GroupingLabel, GroupingLabels, Gte, Gtr, Identifier, LabelMatcher, LabelMatchers, LabelMatchList, LabelName, Lss, Lte, MatchOp, MatrixSelector, MetricIdentifier, Mod, Mul, Neq, NeqRegex, NumberLiteral, OffsetExpr, Or, Pow, PromQL, StepInvariantExpr, StringLiteral, Sub, SubqueryExpr, Unless, VectorSelector } from 'lezer-promql';\nimport { containsAtLeastOneChild, containsChild, retrieveAllRecursiveNodes, walkBackward, walkThrough, buildLabelMatchers } from '../parser';\nimport { aggregateOpModifierTerms, aggregateOpTerms, atModifierTerms, binOpModifierTerms, binOpTerms, durationTerms, functionIdentifierTerms, matchOpTerms, snippets } from './promql.terms';\nimport { syntaxTree } from '@codemirror/language';\nvar autocompleteNodes = {\n  matchOp: matchOpTerms,\n  binOp: binOpTerms,\n  duration: durationTerms,\n  binOpModifier: binOpModifierTerms,\n  atModifier: atModifierTerms,\n  functionIdentifier: functionIdentifierTerms,\n  aggregateOp: aggregateOpTerms,\n  aggregateOpModifier: aggregateOpModifierTerms\n}; // ContextKind is the different possible value determinate by the autocompletion\n\nexport var ContextKind;\n\n(function (ContextKind) {\n  // dynamic autocompletion (required a distant server)\n  ContextKind[ContextKind[\"MetricName\"] = 0] = \"MetricName\";\n  ContextKind[ContextKind[\"LabelName\"] = 1] = \"LabelName\";\n  ContextKind[ContextKind[\"LabelValue\"] = 2] = \"LabelValue\"; // static autocompletion\n\n  ContextKind[ContextKind[\"Function\"] = 3] = \"Function\";\n  ContextKind[ContextKind[\"Aggregation\"] = 4] = \"Aggregation\";\n  ContextKind[ContextKind[\"BinOpModifier\"] = 5] = \"BinOpModifier\";\n  ContextKind[ContextKind[\"BinOp\"] = 6] = \"BinOp\";\n  ContextKind[ContextKind[\"MatchOp\"] = 7] = \"MatchOp\";\n  ContextKind[ContextKind[\"AggregateOpModifier\"] = 8] = \"AggregateOpModifier\";\n  ContextKind[ContextKind[\"Duration\"] = 9] = \"Duration\";\n  ContextKind[ContextKind[\"Offset\"] = 10] = \"Offset\";\n  ContextKind[ContextKind[\"Bool\"] = 11] = \"Bool\";\n  ContextKind[ContextKind[\"AtModifiers\"] = 12] = \"AtModifiers\";\n})(ContextKind || (ContextKind = {}));\n\nfunction getMetricNameInVectorSelector(tree, state) {\n  // Find if there is a defined metric name. Should be used to autocomplete a labelValue or a labelName\n  // First find the parent \"VectorSelector\" to be able to find then the subChild \"MetricIdentifier\" if it exists.\n  var currentNode = walkBackward(tree, VectorSelector);\n\n  if (!currentNode) {\n    // Weird case that shouldn't happen, because \"VectorSelector\" is by definition the parent of the LabelMatchers.\n    return '';\n  }\n\n  currentNode = walkThrough(currentNode, MetricIdentifier, Identifier);\n\n  if (!currentNode) {\n    return '';\n  }\n\n  return state.sliceDoc(currentNode.from, currentNode.to);\n}\n\nfunction arrayToCompletionResult(data, from, to) {\n  var includeSnippet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var span = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var options = data;\n\n  if (includeSnippet) {\n    options.push.apply(options, _toConsumableArray(snippets));\n  }\n\n  return {\n    from: from,\n    to: to,\n    options: options,\n    span: span ? /^[a-zA-Z0-9_:]+$/ : undefined\n  };\n} // computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel calculates the start position only when the node is a LabelMatchers or a GroupingLabels\n\n\nfunction computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel(node, pos) {\n  // Here we can have two different situations:\n  // 1. `metric{}` or `sum by()` with the cursor between the bracket\n  // and so we have increment the starting position to avoid to consider the open bracket when filtering the autocompletion list.\n  // 2. `metric{foo=\"bar\",} or `sum by(foo,)  with the cursor after the comma.\n  // Then the start number should be the current position to avoid to consider the previous labelMatcher/groupingLabel when filtering the autocompletion list.\n  var start = node.from + 1;\n\n  if (node.firstChild !== null) {\n    // here that means the LabelMatchers / GroupingLabels has a child, which is not possible if we have the expression `metric{}`. So we are likely trying to autocomplete the label list after a comma\n    start = pos;\n  }\n\n  return start;\n} // computeStartCompletePosition calculates the start position of the autocompletion.\n// It is an important step because the start position will be used by CMN to find the string and then to use it to filter the CompletionResult.\n// A wrong `start` position will lead to have the completion not working.\n// Note: this method is exported only for testing purpose.\n\n\nexport function computeStartCompletePosition(node, pos) {\n  var _a, _b, _c, _d, _e, _f;\n\n  var start = node.from;\n\n  if (node.type.id === LabelMatchers || node.type.id === GroupingLabels) {\n    start = computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel(node, pos);\n  } else if (node.type.id === FunctionCallBody || node.type.id === StringLiteral && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type.id) === LabelMatcher) {\n    // When the cursor is between bracket, quote, we need to increment the starting position to avoid to consider the open bracket/ first string.\n    start++;\n  } else if (node.type.id === OffsetExpr || node.type.id === NumberLiteral && ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type.id) === 0 && ((_c = node.parent.parent) === null || _c === void 0 ? void 0 : _c.type.id) === SubqueryExpr || node.type.id === 0 && (((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type.id) === OffsetExpr || ((_e = node.parent) === null || _e === void 0 ? void 0 : _e.type.id) === MatrixSelector || ((_f = node.parent) === null || _f === void 0 ? void 0 : _f.type.id) === SubqueryExpr && containsAtLeastOneChild(node.parent, Duration))) {\n    start = pos;\n  }\n\n  return start;\n} // analyzeCompletion is going to determinate what should be autocompleted.\n// The value of the autocompletion is then calculate by the function buildCompletion.\n// Note: this method is exported for testing purpose only. Do not use it directly.\n\nexport function analyzeCompletion(state, node) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;\n\n  var result = [];\n\n  switch (node.type.id) {\n    case 0:\n      // 0 is the id of the error node\n      if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type.id) === OffsetExpr) {\n        // we are likely in the given situation:\n        // `metric_name offset 5` that leads to this tree:\n        // `Expr(OffsetExpr(Expr(VectorSelector(MetricIdentifier(Identifier))),Offset,⚠))`\n        // Here we can just autocomplete a duration.\n        result.push({\n          kind: ContextKind.Duration\n        });\n        break;\n      }\n\n      if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type.id) === LabelMatcher) {\n        // In this case the current token is not itself a valid match op yet:\n        //      metric_name{labelName!}\n        result.push({\n          kind: ContextKind.MatchOp\n        });\n        break;\n      }\n\n      if (((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type.id) === MatrixSelector) {\n        // we are likely in the given situation:\n        // `metric_name{}[5]`\n        // We can also just autocomplete a duration\n        result.push({\n          kind: ContextKind.Duration\n        });\n        break;\n      }\n\n      if (((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type.id) === StepInvariantExpr) {\n        // we are likely in the given situation:\n        //   `expr @ s`\n        // we can autocomplete start / end\n        result.push({\n          kind: ContextKind.AtModifiers\n        });\n        break;\n      }\n\n      if (((_e = node.parent) === null || _e === void 0 ? void 0 : _e.type.id) === SubqueryExpr && containsAtLeastOneChild(node.parent, Duration)) {\n        // we are likely in the given situation:\n        //    `rate(foo[5d:5])`\n        // so we should autocomplete a duration\n        result.push({\n          kind: ContextKind.Duration\n        });\n        break;\n      } // when we are in the situation 'metric_name !', we have the following tree\n      // Expr(VectorSelector(MetricIdentifier(Identifier),⚠))\n      // We should try to know if the char '!' is part of a binOp.\n      // Note: as it is quite experimental, maybe it requires more condition and to check the current tree (parent, other child at the same level ..etc.).\n\n\n      var operator = state.sliceDoc(node.from, node.to);\n\n      if (binOpTerms.filter(function (term) {\n        return term.label.includes(operator);\n      }).length > 0) {\n        result.push({\n          kind: ContextKind.BinOp\n        });\n      }\n\n      break;\n\n    case Identifier:\n      // sometimes an Identifier has an error has parent. This should be treated in priority\n      if (((_f = node.parent) === null || _f === void 0 ? void 0 : _f.type.id) === 0) {\n        if (((_g = node.parent.parent) === null || _g === void 0 ? void 0 : _g.type.id) === AggregateExpr) {\n          // it matches 'sum() b'. So here we can autocomplete:\n          // - the aggregate operation modifier\n          // - the binary operation (since it's not mandatory to have an aggregate operation modifier)\n          result.push({\n            kind: ContextKind.AggregateOpModifier\n          }, {\n            kind: ContextKind.BinOp\n          });\n          break;\n        }\n\n        if (((_h = node.parent.parent) === null || _h === void 0 ? void 0 : _h.type.id) === VectorSelector) {\n          // it matches 'sum b'. So here we also have to autocomplete the aggregate operation modifier only\n          // if the associated metricIdentifier is matching an aggregation operation.\n          // Note: here is the corresponding tree in order to understand the situation:\n          // Expr(\n          // \tVectorSelector(\n          // \t\tMetricIdentifier(Identifier),\n          // \t\t⚠(Identifier)\n          // \t)\n          // )\n          var _operator = getMetricNameInVectorSelector(node, state);\n\n          if (aggregateOpTerms.filter(function (term) {\n            return term.label === _operator;\n          }).length > 0) {\n            result.push({\n              kind: ContextKind.AggregateOpModifier\n            });\n          } // It's possible it also match the expr 'metric_name unle'.\n          // It's also possible that the operator is also a metric even if it matches the list of aggregation function.\n          // So we also have to autocomplete the binary operator.\n          //\n          // The expr `metric_name off` leads to the same tree. So we have to provide the offset keyword too here.\n\n\n          result.push({\n            kind: ContextKind.BinOp\n          }, {\n            kind: ContextKind.Offset\n          });\n          break;\n        }\n      } // As the leaf Identifier is coming for a lot of different case, we have to take a bit time to analyze the tree\n      // in order to know what we have to autocomplete exactly.\n      // Here is some cases:\n      // 1. metric_name / ignor --> we should autocomplete the BinOpModifier + metric/function/aggregation\n      // 2. http_requests_total{method=\"GET\"} off --> offset or binOp should be autocompleted here\n      // 3. rate(foo[5m]) un --> offset or binOp should be autocompleted\n      // 4. sum(http_requests_total{method=\"GET\"} off) --> offset or binOp should be autocompleted\n      // 5. sum(http_requests_total{method=\"GET\"} / o) --> BinOpModifier + metric/function/aggregation\n      // All examples above gives a different tree each time but ends up to be treated in this case.\n      // But they all have the following common tree pattern:\n      // Parent( Expr(...),\n      //         ... ,\n      //         Expr(VectorSelector(MetricIdentifier(Identifier)))\n      //       )\n      //\n      // So the first things to do is to get the `Parent` and to determinate if we are in this configuration.\n      // Otherwise we would just have to autocomplete the metric / function / aggregation.\n\n\n      var parent = (_l = (_k = (_j = node.parent) === null || _j === void 0 ? void 0 : _j.parent) === null || _k === void 0 ? void 0 : _k.parent) === null || _l === void 0 ? void 0 : _l.parent;\n\n      if (!parent) {\n        // this case is normally impossible since by definition, the identifier has 3 parents,\n        // and in Lexer, there is always a default parent in top of everything.\n        result.push({\n          kind: ContextKind.MetricName,\n          metricName: state.sliceDoc(node.from, node.to)\n        }, {\n          kind: ContextKind.Function\n        }, {\n          kind: ContextKind.Aggregation\n        });\n        break;\n      } // now we have to know if we have two Expr in the direct children of the `parent`\n\n\n      var containExprTwice = containsChild(parent, Expr, Expr);\n\n      if (containExprTwice) {\n        if (parent.type.id === BinaryExpr && !containsAtLeastOneChild(parent, 0)) {\n          // We are likely in the case 1 or 5\n          result.push({\n            kind: ContextKind.MetricName,\n            metricName: state.sliceDoc(node.from, node.to)\n          }, {\n            kind: ContextKind.Function\n          }, {\n            kind: ContextKind.Aggregation\n          }, {\n            kind: ContextKind.BinOpModifier\n          }); // in  case the BinaryExpr is a comparison, we should autocomplete the `bool` keyword. But only if it is not present.\n          // When the `bool` keyword is NOT present, then the expression looks like this:\n          // \t\t\tBinaryExpr( Expr(...), Gtr , BinModifiers, Expr(...) )\n          // When the `bool` keyword is present, then the expression looks like this:\n          //      BinaryExpr( Expr(...), Gtr , BinModifiers(Bool), Expr(...) )\n          // To know if it is not present, we just have to check if the Bool is not present as a child of the BinModifiers.\n\n          if (containsAtLeastOneChild(parent, Eql, Gte, Gtr, Lte, Lss, Neq) && !walkThrough(parent, BinModifiers, Bool)) {\n            result.push({\n              kind: ContextKind.Bool\n            });\n          }\n        } else if (parent.type.id !== BinaryExpr || parent.type.id === BinaryExpr && containsAtLeastOneChild(parent, 0)) {\n          result.push({\n            kind: ContextKind.BinOp\n          }, {\n            kind: ContextKind.Offset\n          });\n        }\n      } else {\n        result.push({\n          kind: ContextKind.MetricName,\n          metricName: state.sliceDoc(node.from, node.to)\n        }, {\n          kind: ContextKind.Function\n        }, {\n          kind: ContextKind.Aggregation\n        });\n      }\n\n      break;\n\n    case PromQL:\n      if (!node.firstChild) {\n        // this situation can happen when there is nothing in the text area and the user is explicitly triggering the autocompletion (with ctrl + space)\n        result.push({\n          kind: ContextKind.MetricName,\n          metricName: ''\n        }, {\n          kind: ContextKind.Function\n        }, {\n          kind: ContextKind.Aggregation\n        });\n      }\n\n      break;\n\n    case GroupingLabels:\n      // In this case we are in the given situation:\n      //      sum by ()\n      // So we have to autocomplete any labelName\n      result.push({\n        kind: ContextKind.LabelName\n      });\n      break;\n\n    case LabelMatchers:\n      // In that case we are in the given situation:\n      //       metric_name{} or {}\n      // so we have or to autocomplete any kind of labelName or to autocomplete only the labelName associated to the metric\n      result.push({\n        kind: ContextKind.LabelName,\n        metricName: getMetricNameInVectorSelector(node, state)\n      });\n      break;\n\n    case LabelName:\n      if (((_m = node.parent) === null || _m === void 0 ? void 0 : _m.type.id) === GroupingLabel) {\n        // In this case we are in the given situation:\n        //      sum by (myL)\n        // So we have to continue to autocomplete any kind of labelName\n        result.push({\n          kind: ContextKind.LabelName\n        });\n      } else if (((_o = node.parent) === null || _o === void 0 ? void 0 : _o.type.id) === LabelMatcher) {\n        // In that case we are in the given situation:\n        //       metric_name{myL} or {myL}\n        // so we have or to continue to autocomplete any kind of labelName or\n        // to continue to autocomplete only the labelName associated to the metric\n        result.push({\n          kind: ContextKind.LabelName,\n          metricName: getMetricNameInVectorSelector(node, state)\n        });\n      }\n\n      break;\n\n    case StringLiteral:\n      if (((_p = node.parent) === null || _p === void 0 ? void 0 : _p.type.id) === LabelMatcher) {\n        // In this case we are in the given situation:\n        //      metric_name{labelName=\"\"}\n        // So we can autocomplete the labelValue\n        // Get the labelName.\n        // By definition it's the firstChild: https://github.com/promlabs/lezer-promql/blob/0ef65e196a8db6a989ff3877d57fd0447d70e971/src/promql.grammar#L250\n        var labelName = '';\n\n        if (((_q = node.parent.firstChild) === null || _q === void 0 ? void 0 : _q.type.id) === LabelName) {\n          labelName = state.sliceDoc(node.parent.firstChild.from, node.parent.firstChild.to);\n        } // then find the metricName if it exists\n\n\n        var metricName = getMetricNameInVectorSelector(node, state); // finally get the full matcher available\n\n        var labelMatchers = buildLabelMatchers(retrieveAllRecursiveNodes(walkBackward(node, LabelMatchList), LabelMatchList, LabelMatcher), state);\n        result.push({\n          kind: ContextKind.LabelValue,\n          metricName: metricName,\n          labelName: labelName,\n          matchers: labelMatchers\n        });\n      }\n\n      break;\n\n    case NumberLiteral:\n      if (((_r = node.parent) === null || _r === void 0 ? void 0 : _r.type.id) === 0 && ((_s = node.parent.parent) === null || _s === void 0 ? void 0 : _s.type.id) === SubqueryExpr) {\n        // Here we are likely in this situation:\n        //     `go[5d:4]`\n        // and we have the given tree:\n        // Expr( SubqueryExpr(\n        // \t\tExpr(VectorSelector(MetricIdentifier(Identifier))),\n        // \t\tDuration, Duration, ⚠(NumberLiteral)\n        // ))\n        // So we should continue to autocomplete a duration\n        result.push({\n          kind: ContextKind.Duration\n        });\n      }\n\n      break;\n\n    case Duration:\n    case OffsetExpr:\n      result.push({\n        kind: ContextKind.Duration\n      });\n      break;\n\n    case FunctionCallBody:\n      // In this case we are in the given situation:\n      //       sum() or in rate()\n      // with the cursor between the bracket. So we can autocomplete the metric, the function and the aggregation.\n      result.push({\n        kind: ContextKind.MetricName,\n        metricName: ''\n      }, {\n        kind: ContextKind.Function\n      }, {\n        kind: ContextKind.Aggregation\n      });\n      break;\n\n    case Neq:\n      if (((_t = node.parent) === null || _t === void 0 ? void 0 : _t.type.id) === MatchOp) {\n        result.push({\n          kind: ContextKind.MatchOp\n        });\n      } else if (((_u = node.parent) === null || _u === void 0 ? void 0 : _u.type.id) === BinaryExpr) {\n        result.push({\n          kind: ContextKind.BinOp\n        });\n      }\n\n      break;\n\n    case EqlSingle:\n    case EqlRegex:\n    case NeqRegex:\n    case MatchOp:\n      result.push({\n        kind: ContextKind.MatchOp\n      });\n      break;\n\n    case Pow:\n    case Mul:\n    case Div:\n    case Mod:\n    case Add:\n    case Sub:\n    case Eql:\n    case Gte:\n    case Gtr:\n    case Lte:\n    case Lss:\n    case And:\n    case Unless:\n    case Or:\n    case BinaryExpr:\n      result.push({\n        kind: ContextKind.BinOp\n      });\n      break;\n  }\n\n  return result;\n} // HybridComplete provides a full completion result with or without a remote prometheus.\n\nexport var HybridComplete = /*#__PURE__*/function () {\n  function HybridComplete(prometheusClient) {\n    var maxMetricsMetadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n\n    _classCallCheck(this, HybridComplete);\n\n    this.prometheusClient = prometheusClient;\n    this.maxMetricsMetadata = maxMetricsMetadata;\n  }\n\n  _createClass(HybridComplete, [{\n    key: \"getPrometheusClient\",\n    value: function getPrometheusClient() {\n      return this.prometheusClient;\n    }\n  }, {\n    key: \"promQL\",\n    value: function promQL(context) {\n      var _this = this;\n\n      var state = context.state,\n          pos = context.pos;\n      var tree = syntaxTree(state).resolve(pos, -1);\n      var contexts = analyzeCompletion(state, tree);\n      var asyncResult = Promise.resolve([]);\n      var completeSnippet = false;\n      var span = true;\n\n      var _iterator = _createForOfIteratorHelper(contexts),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var context = _step.value;\n\n          switch (context.kind) {\n            case ContextKind.Aggregation:\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat(autocompleteNodes.aggregateOp);\n              });\n              break;\n\n            case ContextKind.Function:\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat(autocompleteNodes.functionIdentifier);\n              });\n              break;\n\n            case ContextKind.BinOpModifier:\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat(autocompleteNodes.binOpModifier);\n              });\n              break;\n\n            case ContextKind.BinOp:\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat(autocompleteNodes.binOp);\n              });\n              break;\n\n            case ContextKind.MatchOp:\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat(autocompleteNodes.matchOp);\n              });\n              break;\n\n            case ContextKind.AggregateOpModifier:\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat(autocompleteNodes.aggregateOpModifier);\n              });\n              break;\n\n            case ContextKind.Duration:\n              span = false;\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat(autocompleteNodes.duration);\n              });\n              break;\n\n            case ContextKind.Offset:\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat([{\n                  label: 'offset'\n                }]);\n              });\n              break;\n\n            case ContextKind.Bool:\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat([{\n                  label: 'bool'\n                }]);\n              });\n              break;\n\n            case ContextKind.AtModifiers:\n              asyncResult = asyncResult.then(function (result) {\n                return result.concat(autocompleteNodes.atModifier);\n              });\n              break;\n\n            case ContextKind.MetricName:\n              asyncResult = asyncResult.then(function (result) {\n                completeSnippet = true;\n                return _this.autocompleteMetricName(result, context);\n              });\n              break;\n\n            case ContextKind.LabelName:\n              asyncResult = asyncResult.then(function (result) {\n                return _this.autocompleteLabelName(result, context);\n              });\n              break;\n\n            case ContextKind.LabelValue:\n              asyncResult = asyncResult.then(function (result) {\n                return _this.autocompleteLabelValue(result, context);\n              });\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return asyncResult.then(function (result) {\n        return arrayToCompletionResult(result, computeStartCompletePosition(tree, pos), pos, completeSnippet, span);\n      });\n    }\n  }, {\n    key: \"autocompleteMetricName\",\n    value: function autocompleteMetricName(result, context) {\n      var _this2 = this;\n\n      if (!this.prometheusClient) {\n        return result;\n      }\n\n      var metricCompletion = new Map();\n      return this.prometheusClient.metricNames(context.metricName).then(function (metricNames) {\n        var _a;\n\n        var _iterator2 = _createForOfIteratorHelper(metricNames),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var metricName = _step2.value;\n            metricCompletion.set(metricName, {\n              label: metricName,\n              type: 'constant'\n            });\n          } // avoid to get all metric metadata if the prometheus server is too big\n\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (metricNames.length <= _this2.maxMetricsMetadata) {\n          // in order to enrich the completion list of the metric,\n          // we are trying to find the associated metadata\n          return (_a = _this2.prometheusClient) === null || _a === void 0 ? void 0 : _a.metricMetadata();\n        }\n      }).then(function (metricMetadata) {\n        if (metricMetadata) {\n          var _iterator3 = _createForOfIteratorHelper(metricCompletion),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _step3$value = _slicedToArray(_step3.value, 2),\n                  metricName = _step3$value[0],\n                  node = _step3$value[1];\n\n              // For histograms and summaries, the metadata is only exposed for the base metric name,\n              // not separately for the _count, _sum, and _bucket time series.\n              var metadata = metricMetadata[metricName.replace(/(_count|_sum|_bucket)$/, '')];\n\n              if (metadata) {\n                if (metadata.length > 1) {\n                  // it means the metricName has different possible helper and type\n                  var _iterator4 = _createForOfIteratorHelper(metadata),\n                      _step4;\n\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      var m = _step4.value;\n\n                      if (node.detail === '') {\n                        node.detail = m.type;\n                      } else if (node.detail !== m.type) {\n                        node.detail = 'unknown';\n                        node.info = 'multiple different definitions for this metric';\n                      }\n\n                      if (node.info === '') {\n                        node.info = m.help;\n                      } else if (node.info !== m.help) {\n                        node.info = 'multiple different definitions for this metric';\n                      }\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n                } else if (metadata.length === 1) {\n                  var _metadata$ = metadata[0],\n                      type = _metadata$.type,\n                      help = _metadata$.help;\n\n                  if (type === 'histogram' || type === 'summary') {\n                    if (metricName.endsWith('_count')) {\n                      type = 'counter';\n                      help = \"The total number of observations for: \".concat(help);\n                    }\n\n                    if (metricName.endsWith('_sum')) {\n                      type = 'counter';\n                      help = \"The total sum of observations for: \".concat(help);\n                    }\n\n                    if (metricName.endsWith('_bucket')) {\n                      type = 'counter';\n                      help = \"The total count of observations for a bucket in the histogram: \".concat(help);\n                    }\n                  }\n\n                  node.detail = type;\n                  node.info = help;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n\n        return result.concat(Array.from(metricCompletion.values()));\n      });\n    }\n  }, {\n    key: \"autocompleteLabelName\",\n    value: function autocompleteLabelName(result, context) {\n      if (!this.prometheusClient) {\n        return result;\n      }\n\n      return this.prometheusClient.labelNames(context.metricName).then(function (labelNames) {\n        return result.concat(labelNames.map(function (value) {\n          return {\n            label: value,\n            type: 'constant'\n          };\n        }));\n      });\n    }\n  }, {\n    key: \"autocompleteLabelValue\",\n    value: function autocompleteLabelValue(result, context) {\n      if (!this.prometheusClient || !context.labelName) {\n        return result;\n      }\n\n      return this.prometheusClient.labelValues(context.labelName, context.metricName, context.matchers).then(function (labelValues) {\n        return result.concat(labelValues.map(function (value) {\n          return {\n            label: value,\n            type: 'text'\n          };\n        }));\n      });\n    }\n  }]);\n\n  return HybridComplete;\n}();","map":{"version":3,"sources":["../../../src/lang-promql/complete/hybrid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { Add, AggregateExpr, And, BinaryExpr, BinModifiers, Bool, Div, Duration, Eql, EqlRegex, EqlSingle, Expr, FunctionCallBody, GroupingLabel, GroupingLabels, Gte, Gtr, Identifier, LabelMatcher, LabelMatchers, LabelMatchList, LabelName, Lss, Lte, MatchOp, MatrixSelector, MetricIdentifier, Mod, Mul, Neq, NeqRegex, NumberLiteral, OffsetExpr, Or, Pow, PromQL, StepInvariantExpr, StringLiteral, Sub, SubqueryExpr, Unless, VectorSelector, } from 'lezer-promql';\nimport { containsAtLeastOneChild, containsChild, retrieveAllRecursiveNodes, walkBackward, walkThrough, buildLabelMatchers } from '../parser';\nimport { aggregateOpModifierTerms, aggregateOpTerms, atModifierTerms, binOpModifierTerms, binOpTerms, durationTerms, functionIdentifierTerms, matchOpTerms, snippets, } from './promql.terms';\nimport { syntaxTree } from '@codemirror/language';\nconst autocompleteNodes = {\n    matchOp: matchOpTerms,\n    binOp: binOpTerms,\n    duration: durationTerms,\n    binOpModifier: binOpModifierTerms,\n    atModifier: atModifierTerms,\n    functionIdentifier: functionIdentifierTerms,\n    aggregateOp: aggregateOpTerms,\n    aggregateOpModifier: aggregateOpModifierTerms,\n};\n// ContextKind is the different possible value determinate by the autocompletion\nexport var ContextKind;\n(function (ContextKind) {\n    // dynamic autocompletion (required a distant server)\n    ContextKind[ContextKind[\"MetricName\"] = 0] = \"MetricName\";\n    ContextKind[ContextKind[\"LabelName\"] = 1] = \"LabelName\";\n    ContextKind[ContextKind[\"LabelValue\"] = 2] = \"LabelValue\";\n    // static autocompletion\n    ContextKind[ContextKind[\"Function\"] = 3] = \"Function\";\n    ContextKind[ContextKind[\"Aggregation\"] = 4] = \"Aggregation\";\n    ContextKind[ContextKind[\"BinOpModifier\"] = 5] = \"BinOpModifier\";\n    ContextKind[ContextKind[\"BinOp\"] = 6] = \"BinOp\";\n    ContextKind[ContextKind[\"MatchOp\"] = 7] = \"MatchOp\";\n    ContextKind[ContextKind[\"AggregateOpModifier\"] = 8] = \"AggregateOpModifier\";\n    ContextKind[ContextKind[\"Duration\"] = 9] = \"Duration\";\n    ContextKind[ContextKind[\"Offset\"] = 10] = \"Offset\";\n    ContextKind[ContextKind[\"Bool\"] = 11] = \"Bool\";\n    ContextKind[ContextKind[\"AtModifiers\"] = 12] = \"AtModifiers\";\n})(ContextKind || (ContextKind = {}));\nfunction getMetricNameInVectorSelector(tree, state) {\n    // Find if there is a defined metric name. Should be used to autocomplete a labelValue or a labelName\n    // First find the parent \"VectorSelector\" to be able to find then the subChild \"MetricIdentifier\" if it exists.\n    let currentNode = walkBackward(tree, VectorSelector);\n    if (!currentNode) {\n        // Weird case that shouldn't happen, because \"VectorSelector\" is by definition the parent of the LabelMatchers.\n        return '';\n    }\n    currentNode = walkThrough(currentNode, MetricIdentifier, Identifier);\n    if (!currentNode) {\n        return '';\n    }\n    return state.sliceDoc(currentNode.from, currentNode.to);\n}\nfunction arrayToCompletionResult(data, from, to, includeSnippet = false, span = true) {\n    const options = data;\n    if (includeSnippet) {\n        options.push(...snippets);\n    }\n    return {\n        from: from,\n        to: to,\n        options: options,\n        span: span ? /^[a-zA-Z0-9_:]+$/ : undefined,\n    };\n}\n// computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel calculates the start position only when the node is a LabelMatchers or a GroupingLabels\nfunction computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel(node, pos) {\n    // Here we can have two different situations:\n    // 1. `metric{}` or `sum by()` with the cursor between the bracket\n    // and so we have increment the starting position to avoid to consider the open bracket when filtering the autocompletion list.\n    // 2. `metric{foo=\"bar\",} or `sum by(foo,)  with the cursor after the comma.\n    // Then the start number should be the current position to avoid to consider the previous labelMatcher/groupingLabel when filtering the autocompletion list.\n    let start = node.from + 1;\n    if (node.firstChild !== null) {\n        // here that means the LabelMatchers / GroupingLabels has a child, which is not possible if we have the expression `metric{}`. So we are likely trying to autocomplete the label list after a comma\n        start = pos;\n    }\n    return start;\n}\n// computeStartCompletePosition calculates the start position of the autocompletion.\n// It is an important step because the start position will be used by CMN to find the string and then to use it to filter the CompletionResult.\n// A wrong `start` position will lead to have the completion not working.\n// Note: this method is exported only for testing purpose.\nexport function computeStartCompletePosition(node, pos) {\n    var _a, _b, _c, _d, _e, _f;\n    let start = node.from;\n    if (node.type.id === LabelMatchers || node.type.id === GroupingLabels) {\n        start = computeStartCompleteLabelPositionInLabelMatcherOrInGroupingLabel(node, pos);\n    }\n    else if (node.type.id === FunctionCallBody || (node.type.id === StringLiteral && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type.id) === LabelMatcher)) {\n        // When the cursor is between bracket, quote, we need to increment the starting position to avoid to consider the open bracket/ first string.\n        start++;\n    }\n    else if (node.type.id === OffsetExpr ||\n        (node.type.id === NumberLiteral && ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type.id) === 0 && ((_c = node.parent.parent) === null || _c === void 0 ? void 0 : _c.type.id) === SubqueryExpr) ||\n        (node.type.id === 0 &&\n            (((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type.id) === OffsetExpr ||\n                ((_e = node.parent) === null || _e === void 0 ? void 0 : _e.type.id) === MatrixSelector ||\n                (((_f = node.parent) === null || _f === void 0 ? void 0 : _f.type.id) === SubqueryExpr && containsAtLeastOneChild(node.parent, Duration))))) {\n        start = pos;\n    }\n    return start;\n}\n// analyzeCompletion is going to determinate what should be autocompleted.\n// The value of the autocompletion is then calculate by the function buildCompletion.\n// Note: this method is exported for testing purpose only. Do not use it directly.\nexport function analyzeCompletion(state, node) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;\n    const result = [];\n    switch (node.type.id) {\n        case 0: // 0 is the id of the error node\n            if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type.id) === OffsetExpr) {\n                // we are likely in the given situation:\n                // `metric_name offset 5` that leads to this tree:\n                // `Expr(OffsetExpr(Expr(VectorSelector(MetricIdentifier(Identifier))),Offset,⚠))`\n                // Here we can just autocomplete a duration.\n                result.push({ kind: ContextKind.Duration });\n                break;\n            }\n            if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type.id) === LabelMatcher) {\n                // In this case the current token is not itself a valid match op yet:\n                //      metric_name{labelName!}\n                result.push({ kind: ContextKind.MatchOp });\n                break;\n            }\n            if (((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type.id) === MatrixSelector) {\n                // we are likely in the given situation:\n                // `metric_name{}[5]`\n                // We can also just autocomplete a duration\n                result.push({ kind: ContextKind.Duration });\n                break;\n            }\n            if (((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type.id) === StepInvariantExpr) {\n                // we are likely in the given situation:\n                //   `expr @ s`\n                // we can autocomplete start / end\n                result.push({ kind: ContextKind.AtModifiers });\n                break;\n            }\n            if (((_e = node.parent) === null || _e === void 0 ? void 0 : _e.type.id) === SubqueryExpr && containsAtLeastOneChild(node.parent, Duration)) {\n                // we are likely in the given situation:\n                //    `rate(foo[5d:5])`\n                // so we should autocomplete a duration\n                result.push({ kind: ContextKind.Duration });\n                break;\n            }\n            // when we are in the situation 'metric_name !', we have the following tree\n            // Expr(VectorSelector(MetricIdentifier(Identifier),⚠))\n            // We should try to know if the char '!' is part of a binOp.\n            // Note: as it is quite experimental, maybe it requires more condition and to check the current tree (parent, other child at the same level ..etc.).\n            const operator = state.sliceDoc(node.from, node.to);\n            if (binOpTerms.filter((term) => term.label.includes(operator)).length > 0) {\n                result.push({ kind: ContextKind.BinOp });\n            }\n            break;\n        case Identifier:\n            // sometimes an Identifier has an error has parent. This should be treated in priority\n            if (((_f = node.parent) === null || _f === void 0 ? void 0 : _f.type.id) === 0) {\n                if (((_g = node.parent.parent) === null || _g === void 0 ? void 0 : _g.type.id) === AggregateExpr) {\n                    // it matches 'sum() b'. So here we can autocomplete:\n                    // - the aggregate operation modifier\n                    // - the binary operation (since it's not mandatory to have an aggregate operation modifier)\n                    result.push({ kind: ContextKind.AggregateOpModifier }, { kind: ContextKind.BinOp });\n                    break;\n                }\n                if (((_h = node.parent.parent) === null || _h === void 0 ? void 0 : _h.type.id) === VectorSelector) {\n                    // it matches 'sum b'. So here we also have to autocomplete the aggregate operation modifier only\n                    // if the associated metricIdentifier is matching an aggregation operation.\n                    // Note: here is the corresponding tree in order to understand the situation:\n                    // Expr(\n                    // \tVectorSelector(\n                    // \t\tMetricIdentifier(Identifier),\n                    // \t\t⚠(Identifier)\n                    // \t)\n                    // )\n                    const operator = getMetricNameInVectorSelector(node, state);\n                    if (aggregateOpTerms.filter((term) => term.label === operator).length > 0) {\n                        result.push({ kind: ContextKind.AggregateOpModifier });\n                    }\n                    // It's possible it also match the expr 'metric_name unle'.\n                    // It's also possible that the operator is also a metric even if it matches the list of aggregation function.\n                    // So we also have to autocomplete the binary operator.\n                    //\n                    // The expr `metric_name off` leads to the same tree. So we have to provide the offset keyword too here.\n                    result.push({ kind: ContextKind.BinOp }, { kind: ContextKind.Offset });\n                    break;\n                }\n            }\n            // As the leaf Identifier is coming for a lot of different case, we have to take a bit time to analyze the tree\n            // in order to know what we have to autocomplete exactly.\n            // Here is some cases:\n            // 1. metric_name / ignor --> we should autocomplete the BinOpModifier + metric/function/aggregation\n            // 2. http_requests_total{method=\"GET\"} off --> offset or binOp should be autocompleted here\n            // 3. rate(foo[5m]) un --> offset or binOp should be autocompleted\n            // 4. sum(http_requests_total{method=\"GET\"} off) --> offset or binOp should be autocompleted\n            // 5. sum(http_requests_total{method=\"GET\"} / o) --> BinOpModifier + metric/function/aggregation\n            // All examples above gives a different tree each time but ends up to be treated in this case.\n            // But they all have the following common tree pattern:\n            // Parent( Expr(...),\n            //         ... ,\n            //         Expr(VectorSelector(MetricIdentifier(Identifier)))\n            //       )\n            //\n            // So the first things to do is to get the `Parent` and to determinate if we are in this configuration.\n            // Otherwise we would just have to autocomplete the metric / function / aggregation.\n            const parent = (_l = (_k = (_j = node.parent) === null || _j === void 0 ? void 0 : _j.parent) === null || _k === void 0 ? void 0 : _k.parent) === null || _l === void 0 ? void 0 : _l.parent;\n            if (!parent) {\n                // this case is normally impossible since by definition, the identifier has 3 parents,\n                // and in Lexer, there is always a default parent in top of everything.\n                result.push({ kind: ContextKind.MetricName, metricName: state.sliceDoc(node.from, node.to) }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation });\n                break;\n            }\n            // now we have to know if we have two Expr in the direct children of the `parent`\n            const containExprTwice = containsChild(parent, Expr, Expr);\n            if (containExprTwice) {\n                if (parent.type.id === BinaryExpr && !containsAtLeastOneChild(parent, 0)) {\n                    // We are likely in the case 1 or 5\n                    result.push({ kind: ContextKind.MetricName, metricName: state.sliceDoc(node.from, node.to) }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation }, { kind: ContextKind.BinOpModifier });\n                    // in  case the BinaryExpr is a comparison, we should autocomplete the `bool` keyword. But only if it is not present.\n                    // When the `bool` keyword is NOT present, then the expression looks like this:\n                    // \t\t\tBinaryExpr( Expr(...), Gtr , BinModifiers, Expr(...) )\n                    // When the `bool` keyword is present, then the expression looks like this:\n                    //      BinaryExpr( Expr(...), Gtr , BinModifiers(Bool), Expr(...) )\n                    // To know if it is not present, we just have to check if the Bool is not present as a child of the BinModifiers.\n                    if (containsAtLeastOneChild(parent, Eql, Gte, Gtr, Lte, Lss, Neq) && !walkThrough(parent, BinModifiers, Bool)) {\n                        result.push({ kind: ContextKind.Bool });\n                    }\n                }\n                else if (parent.type.id !== BinaryExpr || (parent.type.id === BinaryExpr && containsAtLeastOneChild(parent, 0))) {\n                    result.push({ kind: ContextKind.BinOp }, { kind: ContextKind.Offset });\n                }\n            }\n            else {\n                result.push({ kind: ContextKind.MetricName, metricName: state.sliceDoc(node.from, node.to) }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation });\n            }\n            break;\n        case PromQL:\n            if (!node.firstChild) {\n                // this situation can happen when there is nothing in the text area and the user is explicitly triggering the autocompletion (with ctrl + space)\n                result.push({ kind: ContextKind.MetricName, metricName: '' }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation });\n            }\n            break;\n        case GroupingLabels:\n            // In this case we are in the given situation:\n            //      sum by ()\n            // So we have to autocomplete any labelName\n            result.push({ kind: ContextKind.LabelName });\n            break;\n        case LabelMatchers:\n            // In that case we are in the given situation:\n            //       metric_name{} or {}\n            // so we have or to autocomplete any kind of labelName or to autocomplete only the labelName associated to the metric\n            result.push({ kind: ContextKind.LabelName, metricName: getMetricNameInVectorSelector(node, state) });\n            break;\n        case LabelName:\n            if (((_m = node.parent) === null || _m === void 0 ? void 0 : _m.type.id) === GroupingLabel) {\n                // In this case we are in the given situation:\n                //      sum by (myL)\n                // So we have to continue to autocomplete any kind of labelName\n                result.push({ kind: ContextKind.LabelName });\n            }\n            else if (((_o = node.parent) === null || _o === void 0 ? void 0 : _o.type.id) === LabelMatcher) {\n                // In that case we are in the given situation:\n                //       metric_name{myL} or {myL}\n                // so we have or to continue to autocomplete any kind of labelName or\n                // to continue to autocomplete only the labelName associated to the metric\n                result.push({ kind: ContextKind.LabelName, metricName: getMetricNameInVectorSelector(node, state) });\n            }\n            break;\n        case StringLiteral:\n            if (((_p = node.parent) === null || _p === void 0 ? void 0 : _p.type.id) === LabelMatcher) {\n                // In this case we are in the given situation:\n                //      metric_name{labelName=\"\"}\n                // So we can autocomplete the labelValue\n                // Get the labelName.\n                // By definition it's the firstChild: https://github.com/promlabs/lezer-promql/blob/0ef65e196a8db6a989ff3877d57fd0447d70e971/src/promql.grammar#L250\n                let labelName = '';\n                if (((_q = node.parent.firstChild) === null || _q === void 0 ? void 0 : _q.type.id) === LabelName) {\n                    labelName = state.sliceDoc(node.parent.firstChild.from, node.parent.firstChild.to);\n                }\n                // then find the metricName if it exists\n                const metricName = getMetricNameInVectorSelector(node, state);\n                // finally get the full matcher available\n                const labelMatchers = buildLabelMatchers(retrieveAllRecursiveNodes(walkBackward(node, LabelMatchList), LabelMatchList, LabelMatcher), state);\n                result.push({ kind: ContextKind.LabelValue, metricName: metricName, labelName: labelName, matchers: labelMatchers });\n            }\n            break;\n        case NumberLiteral:\n            if (((_r = node.parent) === null || _r === void 0 ? void 0 : _r.type.id) === 0 && ((_s = node.parent.parent) === null || _s === void 0 ? void 0 : _s.type.id) === SubqueryExpr) {\n                // Here we are likely in this situation:\n                //     `go[5d:4]`\n                // and we have the given tree:\n                // Expr( SubqueryExpr(\n                // \t\tExpr(VectorSelector(MetricIdentifier(Identifier))),\n                // \t\tDuration, Duration, ⚠(NumberLiteral)\n                // ))\n                // So we should continue to autocomplete a duration\n                result.push({ kind: ContextKind.Duration });\n            }\n            break;\n        case Duration:\n        case OffsetExpr:\n            result.push({ kind: ContextKind.Duration });\n            break;\n        case FunctionCallBody:\n            // In this case we are in the given situation:\n            //       sum() or in rate()\n            // with the cursor between the bracket. So we can autocomplete the metric, the function and the aggregation.\n            result.push({ kind: ContextKind.MetricName, metricName: '' }, { kind: ContextKind.Function }, { kind: ContextKind.Aggregation });\n            break;\n        case Neq:\n            if (((_t = node.parent) === null || _t === void 0 ? void 0 : _t.type.id) === MatchOp) {\n                result.push({ kind: ContextKind.MatchOp });\n            }\n            else if (((_u = node.parent) === null || _u === void 0 ? void 0 : _u.type.id) === BinaryExpr) {\n                result.push({ kind: ContextKind.BinOp });\n            }\n            break;\n        case EqlSingle:\n        case EqlRegex:\n        case NeqRegex:\n        case MatchOp:\n            result.push({ kind: ContextKind.MatchOp });\n            break;\n        case Pow:\n        case Mul:\n        case Div:\n        case Mod:\n        case Add:\n        case Sub:\n        case Eql:\n        case Gte:\n        case Gtr:\n        case Lte:\n        case Lss:\n        case And:\n        case Unless:\n        case Or:\n        case BinaryExpr:\n            result.push({ kind: ContextKind.BinOp });\n            break;\n    }\n    return result;\n}\n// HybridComplete provides a full completion result with or without a remote prometheus.\nexport class HybridComplete {\n    constructor(prometheusClient, maxMetricsMetadata = 10000) {\n        this.prometheusClient = prometheusClient;\n        this.maxMetricsMetadata = maxMetricsMetadata;\n    }\n    getPrometheusClient() {\n        return this.prometheusClient;\n    }\n    promQL(context) {\n        const { state, pos } = context;\n        const tree = syntaxTree(state).resolve(pos, -1);\n        const contexts = analyzeCompletion(state, tree);\n        let asyncResult = Promise.resolve([]);\n        let completeSnippet = false;\n        let span = true;\n        for (const context of contexts) {\n            switch (context.kind) {\n                case ContextKind.Aggregation:\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat(autocompleteNodes.aggregateOp);\n                    });\n                    break;\n                case ContextKind.Function:\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat(autocompleteNodes.functionIdentifier);\n                    });\n                    break;\n                case ContextKind.BinOpModifier:\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat(autocompleteNodes.binOpModifier);\n                    });\n                    break;\n                case ContextKind.BinOp:\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat(autocompleteNodes.binOp);\n                    });\n                    break;\n                case ContextKind.MatchOp:\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat(autocompleteNodes.matchOp);\n                    });\n                    break;\n                case ContextKind.AggregateOpModifier:\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat(autocompleteNodes.aggregateOpModifier);\n                    });\n                    break;\n                case ContextKind.Duration:\n                    span = false;\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat(autocompleteNodes.duration);\n                    });\n                    break;\n                case ContextKind.Offset:\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat([{ label: 'offset' }]);\n                    });\n                    break;\n                case ContextKind.Bool:\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat([{ label: 'bool' }]);\n                    });\n                    break;\n                case ContextKind.AtModifiers:\n                    asyncResult = asyncResult.then((result) => {\n                        return result.concat(autocompleteNodes.atModifier);\n                    });\n                    break;\n                case ContextKind.MetricName:\n                    asyncResult = asyncResult.then((result) => {\n                        completeSnippet = true;\n                        return this.autocompleteMetricName(result, context);\n                    });\n                    break;\n                case ContextKind.LabelName:\n                    asyncResult = asyncResult.then((result) => {\n                        return this.autocompleteLabelName(result, context);\n                    });\n                    break;\n                case ContextKind.LabelValue:\n                    asyncResult = asyncResult.then((result) => {\n                        return this.autocompleteLabelValue(result, context);\n                    });\n            }\n        }\n        return asyncResult.then((result) => {\n            return arrayToCompletionResult(result, computeStartCompletePosition(tree, pos), pos, completeSnippet, span);\n        });\n    }\n    autocompleteMetricName(result, context) {\n        if (!this.prometheusClient) {\n            return result;\n        }\n        const metricCompletion = new Map();\n        return this.prometheusClient\n            .metricNames(context.metricName)\n            .then((metricNames) => {\n            var _a;\n            for (const metricName of metricNames) {\n                metricCompletion.set(metricName, { label: metricName, type: 'constant' });\n            }\n            // avoid to get all metric metadata if the prometheus server is too big\n            if (metricNames.length <= this.maxMetricsMetadata) {\n                // in order to enrich the completion list of the metric,\n                // we are trying to find the associated metadata\n                return (_a = this.prometheusClient) === null || _a === void 0 ? void 0 : _a.metricMetadata();\n            }\n        })\n            .then((metricMetadata) => {\n            if (metricMetadata) {\n                for (const [metricName, node] of metricCompletion) {\n                    // For histograms and summaries, the metadata is only exposed for the base metric name,\n                    // not separately for the _count, _sum, and _bucket time series.\n                    const metadata = metricMetadata[metricName.replace(/(_count|_sum|_bucket)$/, '')];\n                    if (metadata) {\n                        if (metadata.length > 1) {\n                            // it means the metricName has different possible helper and type\n                            for (const m of metadata) {\n                                if (node.detail === '') {\n                                    node.detail = m.type;\n                                }\n                                else if (node.detail !== m.type) {\n                                    node.detail = 'unknown';\n                                    node.info = 'multiple different definitions for this metric';\n                                }\n                                if (node.info === '') {\n                                    node.info = m.help;\n                                }\n                                else if (node.info !== m.help) {\n                                    node.info = 'multiple different definitions for this metric';\n                                }\n                            }\n                        }\n                        else if (metadata.length === 1) {\n                            let { type, help } = metadata[0];\n                            if (type === 'histogram' || type === 'summary') {\n                                if (metricName.endsWith('_count')) {\n                                    type = 'counter';\n                                    help = `The total number of observations for: ${help}`;\n                                }\n                                if (metricName.endsWith('_sum')) {\n                                    type = 'counter';\n                                    help = `The total sum of observations for: ${help}`;\n                                }\n                                if (metricName.endsWith('_bucket')) {\n                                    type = 'counter';\n                                    help = `The total count of observations for a bucket in the histogram: ${help}`;\n                                }\n                            }\n                            node.detail = type;\n                            node.info = help;\n                        }\n                    }\n                }\n            }\n            return result.concat(Array.from(metricCompletion.values()));\n        });\n    }\n    autocompleteLabelName(result, context) {\n        if (!this.prometheusClient) {\n            return result;\n        }\n        return this.prometheusClient.labelNames(context.metricName).then((labelNames) => {\n            return result.concat(labelNames.map((value) => ({ label: value, type: 'constant' })));\n        });\n    }\n    autocompleteLabelValue(result, context) {\n        if (!this.prometheusClient || !context.labelName) {\n            return result;\n        }\n        return this.prometheusClient.labelValues(context.labelName, context.metricName, context.matchers).then((labelValues) => {\n            return result.concat(labelValues.map((value) => ({ label: value, type: 'text' })));\n        });\n    }\n}\n//# sourceMappingURL=hybrid.js.map"]},"metadata":{},"sourceType":"module"}