{"ast":null,"code":"import _toConsumableArray from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Facet, combineConfig, StateEffect, StateField, Transaction, Text, EditorSelection, Prec, CharCategory } from '@codemirror/state';\nimport { EditorView, Direction, logException, ViewPlugin, Decoration, WidgetType, keymap } from '@codemirror/view';\nimport { showTooltip } from '@codemirror/tooltip';\nimport { syntaxTree, indentUnit } from '@codemirror/language';\nimport { codePointAt, codePointSize, fromCodePoint } from '@codemirror/text';\n/**\nAn instance of this is passed to completion source functions.\n*/\n\nvar CompletionContext = /*#__PURE__*/function () {\n  /**\n  Create a new completion context. (Mostly useful for testing\n  completion sources—in the editor, the extension will create\n  these for you.)\n  */\n  function CompletionContext(\n  /**\n  The editor state that the completion happens in.\n  */\n  state,\n  /**\n  The position at which the completion is happening.\n  */\n  pos,\n  /**\n  Indicates whether completion was activated explicitly, or\n  implicitly by typing. The usual way to respond to this is to\n  only return completions when either there is part of a\n  completable entity before the cursor, or `explicit` is true.\n  */\n  explicit) {\n    _classCallCheck(this, CompletionContext);\n\n    this.state = state;\n    this.pos = pos;\n    this.explicit = explicit;\n    /**\n    @internal\n    */\n\n    this.abortListeners = [];\n  }\n  /**\n  Get the extent, content, and (if there is a token) type of the\n  token before `this.pos`.\n  */\n\n\n  _createClass(CompletionContext, [{\n    key: \"tokenBefore\",\n    value: function tokenBefore(types) {\n      var token = syntaxTree(this.state).resolve(this.pos, -1);\n\n      while (token && types.indexOf(token.name) < 0) {\n        token = token.parent;\n      }\n\n      return token ? {\n        from: token.from,\n        to: this.pos,\n        text: this.state.sliceDoc(token.from, this.pos),\n        type: token.type\n      } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */\n\n  }, {\n    key: \"matchBefore\",\n    value: function matchBefore(expr) {\n      var line = this.state.doc.lineAt(this.pos);\n      var start = Math.max(line.from, this.pos - 250);\n      var str = line.text.slice(start - line.from, this.pos - line.from);\n      var found = str.search(ensureAnchor(expr, false));\n      return found < 0 ? null : {\n        from: start + found,\n        to: this.pos,\n        text: str.slice(found)\n      };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */\n\n  }, {\n    key: \"aborted\",\n    get: function get() {\n      return this.abortListeners == null;\n    }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */\n\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener) {\n      if (type == \"abort\" && this.abortListeners) this.abortListeners.push(listener);\n    }\n  }]);\n\n  return CompletionContext;\n}();\n\nfunction toSet(chars) {\n  var flat = Object.keys(chars).join(\"\");\n  var words = /\\w/.test(flat);\n  if (words) flat = flat.replace(/\\w/g, \"\");\n  return \"[\".concat(words ? \"\\\\w\" : \"\").concat(flat.replace(/[^\\w\\s]/g, \"\\\\$&\"), \"]\");\n}\n\nfunction prefixMatch(options) {\n  var first = Object.create(null),\n      rest = Object.create(null);\n\n  var _iterator = _createForOfIteratorHelper(options),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var label = _step.value.label;\n      first[label[0]] = true;\n\n      for (var i = 1; i < label.length; i++) {\n        rest[label[i]] = true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var source = toSet(first) + toSet(rest) + \"*$\";\n  return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\n\n\nfunction completeFromList(list) {\n  var options = list.map(function (o) {\n    return typeof o == \"string\" ? {\n      label: o\n    } : o;\n  });\n\n  var _ref = options.every(function (o) {\n    return /^\\w+$/.test(o.label);\n  }) ? [/\\w*$/, /\\w+$/] : prefixMatch(options),\n      _ref2 = _slicedToArray(_ref, 2),\n      span = _ref2[0],\n      match = _ref2[1];\n\n  return function (context) {\n    var token = context.matchBefore(match);\n    return token || context.explicit ? {\n      from: token ? token.from : context.pos,\n      options: options,\n      span: span\n    } : null;\n  };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\n\n\nfunction ifNotIn(nodes, source) {\n  return function (context) {\n    for (var pos = syntaxTree(context.state).resolve(context.pos, -1); pos; pos = pos.parent) {\n      if (nodes.indexOf(pos.name) > -1) return null;\n    }\n\n    return source(context);\n  };\n}\n\nvar Option = function Option(completion, source, match) {\n  _classCallCheck(this, Option);\n\n  this.completion = completion;\n  this.source = source;\n  this.match = match;\n};\n\nfunction cur(state) {\n  return state.selection.main.head;\n} // Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\n\n\nfunction ensureAnchor(expr, start) {\n  var _a;\n\n  var source = expr.source;\n  var addStart = start && source[0] != \"^\",\n      addEnd = source[source.length - 1] != \"$\";\n  if (!addStart && !addEnd) return expr;\n  return new RegExp(\"\".concat(addStart ? \"^\" : \"\", \"(?:\").concat(source, \")\").concat(addEnd ? \"$\" : \"\"), (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n\nfunction applyCompletion(view, option) {\n  var apply = option.completion.apply || option.completion.label;\n  var result = option.source;\n\n  if (typeof apply == \"string\") {\n    view.dispatch({\n      changes: {\n        from: result.from,\n        to: result.to,\n        insert: apply\n      },\n      selection: {\n        anchor: result.from + apply.length\n      }\n    });\n  } else {\n    apply(view, option.completion, result.from, result.to);\n  }\n}\n\nvar SourceCache = /*@__PURE__*/new WeakMap();\n\nfunction asSource(source) {\n  if (!Array.isArray(source)) return source;\n  var known = SourceCache.get(source);\n  if (!known) SourceCache.set(source, known = completeFromList(source));\n  return known;\n} // A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\n\n\nvar FuzzyMatcher = /*#__PURE__*/function () {\n  function FuzzyMatcher(pattern) {\n    _classCallCheck(this, FuzzyMatcher);\n\n    this.pattern = pattern;\n    this.chars = [];\n    this.folded = []; // Buffers reused by calls to `match` to track matched character\n    // positions.\n\n    this.any = [];\n    this.precise = [];\n    this.byWord = [];\n\n    for (var p = 0; p < pattern.length;) {\n      var char = codePointAt(pattern, p),\n          size = codePointSize(char);\n      this.chars.push(char);\n      var part = pattern.slice(p, p + size),\n          upper = part.toUpperCase();\n      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n      p += size;\n    }\n\n    this.astral = pattern.length != this.chars.length;\n  } // Matches a given word (completion) against the pattern (input).\n  // Will return null for no match, and otherwise an array that starts\n  // with the match score, followed by any number of `from, to` pairs\n  // indicating the matched parts of `word`.\n  //\n  // The score is a number that is more negative the worse the match\n  // is. See `Penalty` above.\n\n\n  _createClass(FuzzyMatcher, [{\n    key: \"match\",\n    value: function match(word) {\n      if (this.pattern.length == 0) return [0];\n      if (word.length < this.pattern.length) return null;\n      var chars = this.chars,\n          folded = this.folded,\n          any = this.any,\n          precise = this.precise,\n          byWord = this.byWord; // For single-character queries, only match when they occur right\n      // at the start\n\n      if (chars.length == 1) {\n        var first = codePointAt(word, 0);\n        return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200\n        /* CaseFold */\n        , 0, codePointSize(first)] : null;\n      }\n\n      var direct = word.indexOf(this.pattern);\n      if (direct == 0) return [0, 0, this.pattern.length];\n      var len = chars.length,\n          anyTo = 0;\n\n      if (direct < 0) {\n        for (var i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n          var next = codePointAt(word, i);\n          if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n          i += codePointSize(next);\n        } // No match, exit immediately\n\n\n        if (anyTo < len) return null;\n      } // This tracks the extent of the precise (non-folded, not\n      // necessarily adjacent) match\n\n\n      var preciseTo = 0; // Tracks whether there is a match that hits only characters that\n      // appear to be starting words. `byWordFolded` is set to true when\n      // a case folded character is encountered in such a match\n\n      var byWordTo = 0,\n          byWordFolded = false; // If we've found a partial adjacent match, these track its state\n\n      var adjacentTo = 0,\n          adjacentStart = -1,\n          adjacentEnd = -1;\n      var hasLower = /[a-z]/.test(word); // Go over the option's text, scanning for the various kinds of matches\n\n      for (var _i = 0, _e = Math.min(word.length, 200), prevType = 0\n      /* NonWord */\n      ; _i < _e && byWordTo < len;) {\n        var _next = codePointAt(word, _i);\n\n        if (direct < 0) {\n          if (preciseTo < len && _next == chars[preciseTo]) precise[preciseTo++] = _i;\n\n          if (adjacentTo < len) {\n            if (_next == chars[adjacentTo] || _next == folded[adjacentTo]) {\n              if (adjacentTo == 0) adjacentStart = _i;\n              adjacentEnd = _i;\n              adjacentTo++;\n            } else {\n              adjacentTo = 0;\n            }\n          }\n        }\n\n        var ch = void 0,\n            type = _next < 0xff ? _next >= 48 && _next <= 57 || _next >= 97 && _next <= 122 ? 2\n        /* Lower */\n        : _next >= 65 && _next <= 90 ? 1\n        /* Upper */\n        : 0\n        /* NonWord */\n        : (ch = fromCodePoint(_next)) != ch.toLowerCase() ? 1\n        /* Upper */\n        : ch != ch.toUpperCase() ? 2\n        /* Lower */\n        : 0\n        /* NonWord */\n        ;\n        if ((type == 1\n        /* Upper */\n        && hasLower || prevType == 0\n        /* NonWord */\n        && type != 0\n        /* NonWord */\n        ) && (chars[byWordTo] == _next || folded[byWordTo] == _next && (byWordFolded = true))) byWord[byWordTo++] = _i;\n        prevType = type;\n        _i += codePointSize(_next);\n      }\n\n      if (byWordTo == len && byWord[0] == 0) return this.result(-100\n      /* ByWord */\n      + (byWordFolded ? -200\n      /* CaseFold */\n      : 0), byWord, word);\n      if (adjacentTo == len && adjacentStart == 0) return [-200\n      /* CaseFold */\n      , 0, adjacentEnd];\n      if (direct > -1) return [-700\n      /* NotStart */\n      , direct, direct + this.pattern.length];\n      if (adjacentTo == len) return [-200\n      /* CaseFold */\n      + -700\n      /* NotStart */\n      , adjacentStart, adjacentEnd];\n      if (byWordTo == len) return this.result(-100\n      /* ByWord */\n      + (byWordFolded ? -200\n      /* CaseFold */\n      : 0) + -700\n      /* NotStart */\n      , byWord, word);\n      return chars.length == 2 ? null : this.result((any[0] ? -700\n      /* NotStart */\n      : 0) + -200\n      /* CaseFold */\n      + -1100\n      /* Gap */\n      , any, word);\n    }\n  }, {\n    key: \"result\",\n    value: function result(score, positions, word) {\n      var result = [score],\n          i = 1;\n\n      var _iterator2 = _createForOfIteratorHelper(positions),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var pos = _step2.value;\n          var to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);\n          if (i > 1 && result[i - 1] == pos) result[i - 1] = to;else {\n            result[i++] = pos;\n            result[i++] = to;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return result;\n    }\n  }]);\n\n  return FuzzyMatcher;\n}();\n\nvar completionConfig = /*@__PURE__*/Facet.define({\n  combine: function combine(configs) {\n    return combineConfig(configs, {\n      activateOnTyping: true,\n      override: null,\n      maxRenderedOptions: 100,\n      defaultKeymap: true\n    }, {\n      defaultKeymap: function defaultKeymap(a, b) {\n        return a && b;\n      }\n    });\n  }\n});\nvar MaxInfoWidth = 300;\nvar baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-tooltip.cm-tooltip-autocomplete\": {\n    \"& > ul\": {\n      fontFamily: \"monospace\",\n      whiteSpace: \"nowrap\",\n      overflow: \"auto\",\n      maxWidth_fallback: \"700px\",\n      maxWidth: \"min(700px, 95vw)\",\n      maxHeight: \"10em\",\n      listStyle: \"none\",\n      margin: 0,\n      padding: 0,\n      \"& > li\": {\n        cursor: \"pointer\",\n        padding: \"1px 1em 1px 3px\",\n        lineHeight: 1.2\n      },\n      \"& > li[aria-selected]\": {\n        background_fallback: \"#bdf\",\n        backgroundColor: \"Highlight\",\n        color_fallback: \"white\",\n        color: \"HighlightText\"\n      }\n    }\n  },\n  \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n    content: '\"···\"',\n    opacity: 0.5,\n    display: \"block\",\n    textAlign: \"center\"\n  },\n  \".cm-tooltip.cm-completionInfo\": {\n    position: \"absolute\",\n    padding: \"3px 9px\",\n    width: \"max-content\",\n    maxWidth: MaxInfoWidth + \"px\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left\": {\n    right: \"100%\"\n  },\n  \".cm-completionInfo.cm-completionInfo-right\": {\n    left: \"100%\"\n  },\n  \"&light .cm-snippetField\": {\n    backgroundColor: \"#00000022\"\n  },\n  \"&dark .cm-snippetField\": {\n    backgroundColor: \"#ffffff22\"\n  },\n  \".cm-snippetFieldPosition\": {\n    verticalAlign: \"text-top\",\n    width: 0,\n    height: \"1.15em\",\n    margin: \"0 -0.7px -.7em\",\n    borderLeft: \"1.4px dotted #888\"\n  },\n  \".cm-completionMatchedText\": {\n    textDecoration: \"underline\"\n  },\n  \".cm-completionDetail\": {\n    marginLeft: \"0.5em\",\n    fontStyle: \"italic\"\n  },\n  \".cm-completionIcon\": {\n    fontSize: \"90%\",\n    width: \".8em\",\n    display: \"inline-block\",\n    textAlign: \"center\",\n    paddingRight: \".6em\",\n    opacity: \"0.6\"\n  },\n  \".cm-completionIcon-function, .cm-completionIcon-method\": {\n    \"&:after\": {\n      content: \"'ƒ'\"\n    }\n  },\n  \".cm-completionIcon-class\": {\n    \"&:after\": {\n      content: \"'○'\"\n    }\n  },\n  \".cm-completionIcon-interface\": {\n    \"&:after\": {\n      content: \"'◌'\"\n    }\n  },\n  \".cm-completionIcon-variable\": {\n    \"&:after\": {\n      content: \"'𝑥'\"\n    }\n  },\n  \".cm-completionIcon-constant\": {\n    \"&:after\": {\n      content: \"'𝐶'\"\n    }\n  },\n  \".cm-completionIcon-type\": {\n    \"&:after\": {\n      content: \"'𝑡'\"\n    }\n  },\n  \".cm-completionIcon-enum\": {\n    \"&:after\": {\n      content: \"'∪'\"\n    }\n  },\n  \".cm-completionIcon-property\": {\n    \"&:after\": {\n      content: \"'□'\"\n    }\n  },\n  \".cm-completionIcon-keyword\": {\n    \"&:after\": {\n      content: \"'\\uD83D\\uDD11\\uFE0E'\"\n    } // Disable emoji rendering\n\n  },\n  \".cm-completionIcon-namespace\": {\n    \"&:after\": {\n      content: \"'▢'\"\n    }\n  },\n  \".cm-completionIcon-text\": {\n    \"&:after\": {\n      content: \"'abc'\",\n      fontSize: \"50%\",\n      verticalAlign: \"middle\"\n    }\n  }\n});\n\nfunction createListBox(options, id, range) {\n  var ul = document.createElement(\"ul\");\n  ul.id = id;\n  ul.setAttribute(\"role\", \"listbox\");\n  ul.setAttribute(\"aria-expanded\", \"true\");\n\n  for (var i = range.from; i < range.to; i++) {\n    var _options$i = options[i],\n        completion = _options$i.completion,\n        match = _options$i.match;\n    var li = ul.appendChild(document.createElement(\"li\"));\n    li.id = id + \"-\" + i;\n    var icon = li.appendChild(document.createElement(\"div\"));\n    icon.classList.add(\"cm-completionIcon\");\n    if (completion.type) icon.classList.add(\"cm-completionIcon-\" + completion.type);\n    icon.setAttribute(\"aria-hidden\", \"true\");\n    var labelElt = li.appendChild(document.createElement(\"span\"));\n    labelElt.className = \"cm-completionLabel\";\n    var label = completion.label,\n        detail = completion.detail,\n        off = 0;\n\n    for (var j = 1; j < match.length;) {\n      var from = match[j++],\n          to = match[j++];\n      if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n      var span = labelElt.appendChild(document.createElement(\"span\"));\n      span.appendChild(document.createTextNode(label.slice(from, to)));\n      span.className = \"cm-completionMatchedText\";\n      off = to;\n    }\n\n    if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n\n    if (detail) {\n      var detailElt = li.appendChild(document.createElement(\"span\"));\n      detailElt.className = \"cm-completionDetail\";\n      detailElt.textContent = detail;\n    }\n\n    li.setAttribute(\"role\", \"option\");\n  }\n\n  if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n  if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n  return ul;\n}\n\nfunction createInfoDialog(option, view) {\n  var dom = document.createElement(\"div\");\n  dom.className = \"cm-tooltip cm-completionInfo\";\n  var info = option.completion.info;\n\n  if (typeof info == \"string\") {\n    dom.textContent = info;\n  } else {\n    var content = info(option.completion);\n    if (content.then) content.then(function (node) {\n      return dom.appendChild(node);\n    }, function (e) {\n      return logException(view.state, e, \"completion info\");\n    });else dom.appendChild(content);\n  }\n\n  return dom;\n}\n\nfunction rangeAroundSelected(total, selected, max) {\n  if (total <= max) return {\n    from: 0,\n    to: total\n  };\n\n  if (selected <= total >> 1) {\n    var _off = Math.floor(selected / max);\n\n    return {\n      from: _off * max,\n      to: (_off + 1) * max\n    };\n  }\n\n  var off = Math.floor((total - selected) / max);\n  return {\n    from: total - (off + 1) * max,\n    to: total - off * max\n  };\n}\n\nvar CompletionTooltip = /*#__PURE__*/function () {\n  function CompletionTooltip(view, stateField) {\n    var _this = this;\n\n    _classCallCheck(this, CompletionTooltip);\n\n    this.view = view;\n    this.stateField = stateField;\n    this.info = null;\n    this.placeInfo = {\n      read: function read() {\n        return _this.measureInfo();\n      },\n      write: function write(pos) {\n        return _this.positionInfo(pos);\n      },\n      key: this\n    };\n    var cState = view.state.field(stateField);\n    var _cState$open = cState.open,\n        options = _cState$open.options,\n        selected = _cState$open.selected;\n    var config = view.state.facet(completionConfig);\n    this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-tooltip-autocomplete\";\n    this.dom.addEventListener(\"mousedown\", function (e) {\n      for (var dom = e.target, match; dom && dom != _this.dom; dom = dom.parentNode) {\n        if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n          applyCompletion(view, options[+match[1]]);\n          e.preventDefault();\n          return;\n        }\n      }\n    });\n    this.list = this.dom.appendChild(createListBox(options, cState.id, this.range));\n    this.list.addEventListener(\"scroll\", function () {\n      if (_this.info) _this.view.requestMeasure(_this.placeInfo);\n    });\n  }\n\n  _createClass(CompletionTooltip, [{\n    key: \"mount\",\n    value: function mount() {\n      this.updateSel();\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update) {\n      if (_update.state.field(this.stateField) != _update.startState.field(this.stateField)) this.updateSel();\n    }\n  }, {\n    key: \"positioned\",\n    value: function positioned() {\n      if (this.info) this.view.requestMeasure(this.placeInfo);\n    }\n  }, {\n    key: \"updateSel\",\n    value: function updateSel() {\n      var _this2 = this;\n\n      var cState = this.view.state.field(this.stateField),\n          open = cState.open;\n\n      if (open.selected < this.range.from || open.selected >= this.range.to) {\n        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n        this.list.remove();\n        this.list = this.dom.appendChild(createListBox(open.options, cState.id, this.range));\n        this.list.addEventListener(\"scroll\", function () {\n          if (_this2.info) _this2.view.requestMeasure(_this2.placeInfo);\n        });\n      }\n\n      if (this.updateSelectedOption(open.selected)) {\n        if (this.info) {\n          this.info.remove();\n          this.info = null;\n        }\n\n        var option = open.options[open.selected];\n\n        if (option.completion.info) {\n          this.info = this.dom.appendChild(createInfoDialog(option, this.view));\n          this.view.requestMeasure(this.placeInfo);\n        }\n      }\n    }\n  }, {\n    key: \"updateSelectedOption\",\n    value: function updateSelectedOption(selected) {\n      var set = null;\n\n      for (var opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n        if (i == selected) {\n          if (!opt.hasAttribute(\"aria-selected\")) {\n            opt.setAttribute(\"aria-selected\", \"true\");\n            set = opt;\n          }\n        } else {\n          if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n        }\n      }\n\n      if (set) scrollIntoView(this.list, set);\n      return set;\n    }\n  }, {\n    key: \"measureInfo\",\n    value: function measureInfo() {\n      var sel = this.dom.querySelector(\"[aria-selected]\");\n      if (!sel) return null;\n      var rect = this.dom.getBoundingClientRect();\n      var top = sel.getBoundingClientRect().top - rect.top;\n      if (top < 0 || top > this.list.clientHeight - 10) return null;\n      var left = this.view.textDirection == Direction.RTL;\n      var spaceLeft = rect.left,\n          spaceRight = innerWidth - rect.right;\n      if (left && spaceLeft < Math.min(MaxInfoWidth, spaceRight)) left = false;else if (!left && spaceRight < Math.min(MaxInfoWidth, spaceLeft)) left = true;\n      return {\n        top: top,\n        left: left\n      };\n    }\n  }, {\n    key: \"positionInfo\",\n    value: function positionInfo(pos) {\n      if (this.info && pos) {\n        this.info.style.top = pos.top + \"px\";\n        this.info.classList.toggle(\"cm-completionInfo-left\", pos.left);\n        this.info.classList.toggle(\"cm-completionInfo-right\", !pos.left);\n      }\n    }\n  }]);\n\n  return CompletionTooltip;\n}(); // We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\n\n\nfunction completionTooltip(stateField) {\n  return function (view) {\n    return new CompletionTooltip(view, stateField);\n  };\n}\n\nfunction scrollIntoView(container, element) {\n  var parent = container.getBoundingClientRect();\n  var self = element.getBoundingClientRect();\n  if (self.top < parent.top) container.scrollTop -= parent.top - self.top;else if (self.bottom > parent.bottom) container.scrollTop += self.bottom - parent.bottom;\n}\n\nvar MaxOptions = 300; // Used to pick a preferred option when two options with the same\n// label occur in the result.\n\nfunction score(option) {\n  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\n\nfunction sortOptions(active, state) {\n  var options = [];\n\n  var _iterator3 = _createForOfIteratorHelper(active),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var a = _step3.value;\n\n      if (a.hasResult()) {\n        var matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)),\n            match = void 0;\n\n        var _iterator5 = _createForOfIteratorHelper(a.result.options),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var option = _step5.value;\n\n            if (match = matcher.match(option.label)) {\n              if (option.boost != null) match[0] += option.boost;\n              options.push(new Option(option, a, match));\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  options.sort(cmpOption);\n  var result = [],\n      prev = null;\n\n  var _iterator4 = _createForOfIteratorHelper(options.sort(cmpOption)),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var opt = _step4.value;\n      if (result.length == MaxOptions) break;\n      if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail) result.push(opt);else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n      prev = opt.completion;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return result;\n}\n\nvar CompletionDialog = /*#__PURE__*/function () {\n  function CompletionDialog(options, attrs, tooltip, timestamp, selected) {\n    _classCallCheck(this, CompletionDialog);\n\n    this.options = options;\n    this.attrs = attrs;\n    this.tooltip = tooltip;\n    this.timestamp = timestamp;\n    this.selected = selected;\n  }\n\n  _createClass(CompletionDialog, [{\n    key: \"setSelected\",\n    value: function setSelected(selected, id) {\n      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);\n    }\n  }, {\n    key: \"map\",\n    value: function map(changes) {\n      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n        pos: changes.mapPos(this.tooltip.pos)\n      }), this.timestamp, this.selected);\n    }\n  }], [{\n    key: \"build\",\n    value: function build(active, state, id, prev) {\n      var options = sortOptions(active, state);\n      if (!options.length) return null;\n      var selected = 0;\n\n      if (prev && prev.selected) {\n        var selectedValue = prev.options[prev.selected].completion;\n\n        for (var i = 0; i < options.length && !selected; i++) {\n          if (options[i].completion == selectedValue) selected = i;\n        }\n      }\n\n      return new CompletionDialog(options, makeAttrs(id, selected), {\n        pos: active.reduce(function (a, b) {\n          return b.hasResult() ? Math.min(a, b.from) : a;\n        }, 1e8),\n        create: completionTooltip(completionState)\n      }, prev ? prev.timestamp : Date.now(), selected);\n    }\n  }]);\n\n  return CompletionDialog;\n}();\n\nvar CompletionState = /*#__PURE__*/function () {\n  function CompletionState(active, id, open) {\n    _classCallCheck(this, CompletionState);\n\n    this.active = active;\n    this.id = id;\n    this.open = open;\n  }\n\n  _createClass(CompletionState, [{\n    key: \"update\",\n    value: function update(tr) {\n      var _this3 = this;\n\n      var state = tr.state,\n          conf = state.facet(completionConfig);\n      var sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n      var active = sources.map(function (source) {\n        var value = _this3.active.find(function (s) {\n          return s.source == source;\n        }) || new ActiveSource(source, 0\n        /* Inactive */\n        , false);\n        return value.update(tr, conf);\n      });\n      if (active.length == this.active.length && active.every(function (a, i) {\n        return a == _this3.active[i];\n      })) active = this.active;\n      var open = tr.selection || active.some(function (a) {\n        return a.hasResult() && tr.changes.touchesRange(a.from, a.to);\n      }) || !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;\n      if (!open && active.every(function (a) {\n        return a.state != 1;\n      }\n      /* Pending */\n      ) && active.some(function (a) {\n        return a.hasResult();\n      })) active = active.map(function (a) {\n        return a.hasResult() ? new ActiveSource(a.source, 0\n        /* Inactive */\n        , false) : a;\n      });\n\n      var _iterator6 = _createForOfIteratorHelper(tr.effects),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var effect = _step6.value;\n          if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n  }, {\n    key: \"tooltip\",\n    get: function get() {\n      return this.open ? this.open.tooltip : null;\n    }\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      return this.open ? this.open.attrs : baseAttrs;\n    }\n  }], [{\n    key: \"start\",\n    value: function start() {\n      return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n  }]);\n\n  return CompletionState;\n}();\n\nfunction sameResults(a, b) {\n  if (a == b) return true;\n\n  for (var iA = 0, iB = 0;;) {\n    while (iA < a.length && !a[iA].hasResult) {\n      iA++;\n    }\n\n    while (iB < b.length && !b[iB].hasResult) {\n      iB++;\n    }\n\n    var endA = iA == a.length,\n        endB = iB == b.length;\n    if (endA || endB) return endA == endB;\n    if (a[iA++].result != b[iB++].result) return false;\n  }\n}\n\nfunction makeAttrs(id, selected) {\n  return {\n    \"aria-autocomplete\": \"list\",\n    \"aria-activedescendant\": id + \"-\" + selected,\n    \"aria-owns\": id\n  };\n}\n\nvar baseAttrs = {\n  \"aria-autocomplete\": \"list\"\n},\n    none = [];\n\nfunction cmpOption(a, b) {\n  var dScore = b.match[0] - a.match[0];\n  if (dScore) return dScore;\n  var lA = a.completion.label,\n      lB = b.completion.label;\n  return lA < lB ? -1 : lA == lB ? 0 : 1;\n}\n\nvar ActiveSource = /*#__PURE__*/function () {\n  function ActiveSource(source, state, explicit) {\n    _classCallCheck(this, ActiveSource);\n\n    this.source = source;\n    this.state = state;\n    this.explicit = explicit;\n  }\n\n  _createClass(ActiveSource, [{\n    key: \"hasResult\",\n    value: function hasResult() {\n      return false;\n    }\n  }, {\n    key: \"update\",\n    value: function update(tr, conf) {\n      var event = tr.annotation(Transaction.userEvent),\n          value = this;\n      if (event == \"input\" || event == \"delete\") value = value.handleUserEvent(tr, event, conf);else if (tr.docChanged) value = value.handleChange(tr);else if (tr.selection && value.state != 0\n      /* Inactive */\n      ) value = new ActiveSource(value.source, 0\n        /* Inactive */\n        , false);\n\n      var _iterator7 = _createForOfIteratorHelper(tr.effects),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var effect = _step7.value;\n          if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1\n          /* Pending */\n          , effect.value);else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0\n          /* Inactive */\n          , false);else if (effect.is(setActiveEffect)) {\n            var _iterator8 = _createForOfIteratorHelper(effect.value),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var active = _step8.value;\n                if (active.source == value.source) value = active;\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"handleUserEvent\",\n    value: function handleUserEvent(_tr, type, conf) {\n      return type == \"delete\" || !conf.activateOnTyping ? this : new ActiveSource(this.source, 1\n      /* Pending */\n      , false);\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(tr) {\n      return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0\n      /* Inactive */\n      , false) : this;\n    }\n  }]);\n\n  return ActiveSource;\n}();\n\nvar ActiveResult = /*#__PURE__*/function (_ActiveSource) {\n  _inherits(ActiveResult, _ActiveSource);\n\n  var _super = _createSuper(ActiveResult);\n\n  function ActiveResult(source, explicit, result, from, to, span) {\n    var _this4;\n\n    _classCallCheck(this, ActiveResult);\n\n    _this4 = _super.call(this, source, 2\n    /* Result */\n    , explicit);\n    _this4.result = result;\n    _this4.from = from;\n    _this4.to = to;\n    _this4.span = span;\n    return _this4;\n  }\n\n  _createClass(ActiveResult, [{\n    key: \"hasResult\",\n    value: function hasResult() {\n      return true;\n    }\n  }, {\n    key: \"handleUserEvent\",\n    value: function handleUserEvent(tr, type, conf) {\n      var from = tr.changes.mapPos(this.from),\n          to = tr.changes.mapPos(this.to, 1);\n      var pos = cur(tr.state);\n      if ((this.explicit ? pos < from : pos <= from) || pos > to) return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1\n      /* Pending */\n      : 0\n      /* Inactive */\n      , false);\n      if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to)))) return new ActiveResult(this.source, this.explicit, this.result, from, to, this.span);\n      return new ActiveSource(this.source, 1\n      /* Pending */\n      , this.explicit);\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(tr) {\n      return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0\n      /* Inactive */\n      , false) : new ActiveResult(this.source, this.explicit, this.result, tr.changes.mapPos(this.from), tr.changes.mapPos(this.to, 1), this.span);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      return new ActiveResult(this.source, this.explicit, this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);\n    }\n  }]);\n\n  return ActiveResult;\n}(ActiveSource);\n\nvar startCompletionEffect = /*@__PURE__*/StateEffect.define();\nvar closeCompletionEffect = /*@__PURE__*/StateEffect.define();\nvar setActiveEffect = /*@__PURE__*/StateEffect.define({\n  map: function map(sources, mapping) {\n    return sources.map(function (s) {\n      return s.hasResult() && !mapping.empty ? s.map(mapping) : s;\n    });\n  }\n});\nvar setSelectedEffect = /*@__PURE__*/StateEffect.define();\nvar completionState = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return CompletionState.start();\n  },\n  update: function update(value, tr) {\n    return value.update(tr);\n  },\n  provide: function provide(f) {\n    return [showTooltip.from(f, function (val) {\n      return val.tooltip;\n    }), EditorView.contentAttributes.from(f, function (state) {\n      return state.attrs;\n    })];\n  }\n});\nvar CompletionInteractMargin = 75;\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\n\nfunction moveCompletionSelection(forward) {\n  var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"option\";\n  return function (view) {\n    var cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;\n    var step = 1,\n        tooltip;\n    if (by == \"page\" && (tooltip = view.dom.querySelector(\".cm-tooltip-autocomplete\"))) step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));\n    var selected = cState.open.selected + step * (forward ? 1 : -1),\n        length = cState.open.options.length;\n    if (selected < 0) selected = by == \"page\" ? 0 : length - 1;else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n    view.dispatch({\n      effects: setSelectedEffect.of(selected)\n    });\n    return true;\n  };\n}\n/**\nAccept the current completion.\n*/\n\n\nvar acceptCompletion = function acceptCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;\n  applyCompletion(view, cState.open.options[cState.open.selected]);\n  return true;\n};\n/**\nExplicitly start autocompletion.\n*/\n\n\nvar startCompletion = function startCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (!cState) return false;\n  view.dispatch({\n    effects: startCompletionEffect.of(true)\n  });\n  return true;\n};\n/**\nClose the currently active completion.\n*/\n\n\nvar closeCompletion = function closeCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (!cState || !cState.active.some(function (a) {\n    return a.state != 0;\n  }\n  /* Inactive */\n  )) return false;\n  view.dispatch({\n    effects: closeCompletionEffect.of(null)\n  });\n  return true;\n};\n\nvar RunningQuery = function RunningQuery(source, context) {\n  _classCallCheck(this, RunningQuery);\n\n  this.source = source;\n  this.context = context;\n  this.time = Date.now();\n  this.updates = []; // Note that 'undefined' means 'not done yet', whereas 'null' means\n  // 'query returned null'.\n\n  this.done = undefined;\n};\n\nvar DebounceTime = 50,\n    MaxUpdateCount = 50,\n    MinAbortTime = 1000;\nvar completionPlugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.view = view;\n    this.debounceUpdate = -1;\n    this.running = [];\n    this.debounceAccept = -1;\n    this.composing = 0\n    /* None */\n    ;\n\n    var _iterator9 = _createForOfIteratorHelper(view.state.field(completionState).active),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var active = _step9.value;\n        if (active.state == 1\n        /* Pending */\n        ) this.startQuery(active);\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update2) {\n      var _this5 = this;\n\n      var cState = _update2.state.field(completionState);\n\n      if (!_update2.selectionSet && !_update2.docChanged && _update2.startState.field(completionState) == cState) return;\n\n      var doesReset = _update2.transactions.some(function (tr) {\n        var event = tr.annotation(Transaction.userEvent);\n        return (tr.selection || tr.docChanged) && event != \"input\" && event != \"delete\";\n      });\n\n      for (var i = 0; i < this.running.length; i++) {\n        var query = this.running[i];\n\n        if (doesReset || query.updates.length + _update2.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {\n          var _iterator10 = _createForOfIteratorHelper(query.context.abortListeners),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var handler = _step10.value;\n\n              try {\n                handler();\n              } catch (e) {\n                logException(this.view.state, e);\n              }\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n\n          query.context.abortListeners = null;\n          this.running.splice(i--, 1);\n        } else {\n          var _query$updates;\n\n          (_query$updates = query.updates).push.apply(_query$updates, _toConsumableArray(_update2.transactions));\n        }\n      }\n\n      if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n      this.debounceUpdate = cState.active.some(function (a) {\n        return a.state == 1\n        /* Pending */\n        && !_this5.running.some(function (q) {\n          return q.source == a.source;\n        });\n      }) ? setTimeout(function () {\n        return _this5.startUpdate();\n      }, DebounceTime) : -1;\n\n      if (this.composing != 0\n      /* None */\n      ) {\n        var _iterator11 = _createForOfIteratorHelper(_update2.transactions),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var tr = _step11.value;\n            if (tr.annotation(Transaction.userEvent) == \"input\") this.composing = 2\n            /* Changed */\n            ;else if (this.composing == 2\n            /* Changed */\n            && tr.selection) this.composing = 3\n            /* ChangedAndMoved */\n            ;\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      }\n    }\n  }, {\n    key: \"startUpdate\",\n    value: function startUpdate() {\n      var _this6 = this;\n\n      this.debounceUpdate = -1;\n      var state = this.view.state,\n          cState = state.field(completionState);\n\n      var _iterator12 = _createForOfIteratorHelper(cState.active),\n          _step12;\n\n      try {\n        var _loop = function _loop() {\n          var active = _step12.value;\n          if (active.state == 1\n          /* Pending */\n          && !_this6.running.some(function (r) {\n            return r.source == active.source;\n          })) _this6.startQuery(active);\n        };\n\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  }, {\n    key: \"startQuery\",\n    value: function startQuery(active) {\n      var _this7 = this;\n\n      var state = this.view.state,\n          pos = cur(state);\n      var context = new CompletionContext(state, pos, active.explicit);\n      var pending = new RunningQuery(active.source, context);\n      this.running.push(pending);\n      Promise.resolve(active.source(context)).then(function (result) {\n        if (!pending.context.aborted) {\n          pending.done = result || null;\n\n          _this7.scheduleAccept();\n        }\n      }, function (err) {\n        _this7.view.dispatch({\n          effects: closeCompletionEffect.of(null)\n        });\n\n        logException(_this7.view.state, err);\n      });\n    }\n  }, {\n    key: \"scheduleAccept\",\n    value: function scheduleAccept() {\n      var _this8 = this;\n\n      if (this.running.every(function (q) {\n        return q.done !== undefined;\n      })) this.accept();else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(function () {\n        return _this8.accept();\n      }, DebounceTime);\n    } // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n\n  }, {\n    key: \"accept\",\n    value: function accept() {\n      var _this9 = this;\n\n      var _a;\n\n      if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n      this.debounceAccept = -1;\n      var updated = [];\n      var conf = this.view.state.facet(completionConfig);\n\n      var _loop2 = function _loop2(_i2) {\n        var query = _this9.running[_i2];\n\n        if (query.done === undefined) {\n          i = _i2;\n          return \"continue\";\n        }\n\n        _this9.running.splice(_i2--, 1);\n\n        if (query.done) {\n          var active = new ActiveResult(query.source, query.context.explicit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : _this9.view.state), query.done.span ? ensureAnchor(query.done.span, true) : null); // Replay the transactions that happened since the start of\n          // the request and see if that preserves the result\n\n          var _iterator13 = _createForOfIteratorHelper(query.updates),\n              _step13;\n\n          try {\n            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n              var tr = _step13.value;\n              active = active.update(tr, conf);\n            }\n          } catch (err) {\n            _iterator13.e(err);\n          } finally {\n            _iterator13.f();\n          }\n\n          if (active.hasResult()) {\n            updated.push(active);\n            i = _i2;\n            return \"continue\";\n          }\n        }\n\n        var current = _this9.view.state.field(completionState).active.find(function (a) {\n          return a.source == query.source;\n        });\n\n        if (current && current.state == 1\n        /* Pending */\n        ) {\n            if (query.done == null) {\n              // Explicitly failed. Should clear the pending status if it\n              // hasn't been re-set in the meantime.\n              var _active = new ActiveSource(query.source, 0\n              /* Inactive */\n              , false);\n\n              var _iterator14 = _createForOfIteratorHelper(query.updates),\n                  _step14;\n\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var _tr2 = _step14.value;\n                  _active = _active.update(_tr2, conf);\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n\n              if (_active.state != 1\n              /* Pending */\n              ) updated.push(_active);\n            } else {\n              // Cleared by subsequent transactions. Restart.\n              _this9.startQuery(current);\n            }\n          }\n\n        i = _i2;\n      };\n\n      for (var i = 0; i < this.running.length; i++) {\n        var _ret = _loop2(i);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      if (updated.length) this.view.dispatch({\n        effects: setActiveEffect.of(updated)\n      });\n    }\n  }]);\n\n  return _class;\n}(), {\n  eventHandlers: {\n    compositionstart: function compositionstart() {\n      this.composing = 1\n      /* Started */\n      ;\n    },\n    compositionend: function compositionend() {\n      var _this10 = this;\n\n      if (this.composing == 3\n      /* ChangedAndMoved */\n      ) {\n          // Safari fires compositionend events synchronously, possibly\n          // from inside an update, so dispatch asynchronously to avoid reentrancy\n          setTimeout(function () {\n            return _this10.view.dispatch({\n              effects: startCompletionEffect.of(false)\n            });\n          }, 20);\n        }\n\n      this.composing = 0\n      /* None */\n      ;\n    }\n  }\n});\n\nvar FieldPos = function FieldPos(field, line, from, to) {\n  _classCallCheck(this, FieldPos);\n\n  this.field = field;\n  this.line = line;\n  this.from = from;\n  this.to = to;\n};\n\nvar FieldRange = /*#__PURE__*/function () {\n  function FieldRange(field, from, to) {\n    _classCallCheck(this, FieldRange);\n\n    this.field = field;\n    this.from = from;\n    this.to = to;\n  }\n\n  _createClass(FieldRange, [{\n    key: \"map\",\n    value: function map(changes) {\n      return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));\n    }\n  }]);\n\n  return FieldRange;\n}();\n\nvar Snippet = /*#__PURE__*/function () {\n  function Snippet(lines, fieldPositions) {\n    _classCallCheck(this, Snippet);\n\n    this.lines = lines;\n    this.fieldPositions = fieldPositions;\n  }\n\n  _createClass(Snippet, [{\n    key: \"instantiate\",\n    value: function instantiate(state, pos) {\n      var text = [],\n          lineStart = [pos];\n      var lineObj = state.doc.lineAt(pos),\n          baseIndent = /^\\s*/.exec(lineObj.text)[0];\n\n      var _iterator15 = _createForOfIteratorHelper(this.lines),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var line = _step15.value;\n\n          if (text.length) {\n            var indent = baseIndent,\n                tabs = /^\\t*/.exec(line)[0].length;\n\n            for (var _i3 = 0; _i3 < tabs; _i3++) {\n              indent += state.facet(indentUnit);\n            }\n\n            lineStart.push(pos + indent.length - tabs);\n            line = indent + line.slice(tabs);\n          }\n\n          text.push(line);\n          pos += line.length + 1;\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      var ranges = this.fieldPositions.map(function (pos) {\n        return new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to);\n      });\n      return {\n        text: text,\n        ranges: ranges\n      };\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(template) {\n      var fields = [];\n      var lines = [],\n          positions = [],\n          m;\n\n      var _iterator16 = _createForOfIteratorHelper(template.split(/\\r\\n?|\\n/)),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var line = _step16.value;\n\n          while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n            var seq = m[1] ? +m[1] : null,\n                name = m[2] || m[3],\n                found = -1;\n\n            for (var _i4 = 0; _i4 < fields.length; _i4++) {\n              if (seq != null ? fields[_i4].seq == seq : name ? fields[_i4].name == name : false) found = _i4;\n            }\n\n            if (found < 0) {\n              var _i5 = 0;\n\n              while (_i5 < fields.length && (seq == null || fields[_i5].seq != null && fields[_i5].seq < seq)) {\n                _i5++;\n              }\n\n              fields.splice(_i5, 0, {\n                seq: seq,\n                name: name || null\n              });\n              found = _i5;\n\n              var _iterator17 = _createForOfIteratorHelper(positions),\n                  _step17;\n\n              try {\n                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                  var pos = _step17.value;\n                  if (pos.field >= found) pos.field++;\n                }\n              } catch (err) {\n                _iterator17.e(err);\n              } finally {\n                _iterator17.f();\n              }\n            }\n\n            positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n            line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n          }\n\n          lines.push(line);\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n\n      return new Snippet(lines, positions);\n    }\n  }]);\n\n  return Snippet;\n}();\n\nvar fieldMarker = /*@__PURE__*/Decoration.widget({\n  widget: /*@__PURE__*/new ( /*#__PURE__*/function (_WidgetType) {\n    _inherits(_class2, _WidgetType);\n\n    var _super2 = _createSuper(_class2);\n\n    function _class2() {\n      _classCallCheck(this, _class2);\n\n      return _super2.apply(this, arguments);\n    }\n\n    _createClass(_class2, [{\n      key: \"toDOM\",\n      value: function toDOM() {\n        var span = document.createElement(\"span\");\n        span.className = \"cm-snippetFieldPosition\";\n        return span;\n      }\n    }, {\n      key: \"ignoreEvent\",\n      value: function ignoreEvent() {\n        return false;\n      }\n    }]);\n\n    return _class2;\n  }(WidgetType))()\n});\nvar fieldRange = /*@__PURE__*/Decoration.mark({\n  class: \"cm-snippetField\"\n});\n\nvar ActiveSnippet = /*#__PURE__*/function () {\n  function ActiveSnippet(ranges, active) {\n    _classCallCheck(this, ActiveSnippet);\n\n    this.ranges = ranges;\n    this.active = active;\n    this.deco = Decoration.set(ranges.map(function (r) {\n      return (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to);\n    }));\n  }\n\n  _createClass(ActiveSnippet, [{\n    key: \"map\",\n    value: function map(changes) {\n      return new ActiveSnippet(this.ranges.map(function (r) {\n        return r.map(changes);\n      }), this.active);\n    }\n  }, {\n    key: \"selectionInsideField\",\n    value: function selectionInsideField(sel) {\n      var _this11 = this;\n\n      return sel.ranges.every(function (range) {\n        return _this11.ranges.some(function (r) {\n          return r.field == _this11.active && r.from <= range.from && r.to >= range.to;\n        });\n      });\n    }\n  }]);\n\n  return ActiveSnippet;\n}();\n\nvar setActive = /*@__PURE__*/StateEffect.define({\n  map: function map(value, changes) {\n    return value && value.map(changes);\n  }\n});\nvar moveToField = /*@__PURE__*/StateEffect.define();\nvar snippetState = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return null;\n  },\n  update: function update(value, tr) {\n    var _iterator18 = _createForOfIteratorHelper(tr.effects),\n        _step18;\n\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var effect = _step18.value;\n        if (effect.is(setActive)) return effect.value;\n        if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n\n    if (value && tr.docChanged) value = value.map(tr.changes);\n    if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n    return value;\n  },\n  provide: function provide(f) {\n    return EditorView.decorations.from(f, function (val) {\n      return val ? val.deco : Decoration.none;\n    });\n  }\n});\n\nfunction fieldSelection(ranges, field) {\n  return EditorSelection.create(ranges.filter(function (r) {\n    return r.field == field;\n  }).map(function (r) {\n    return EditorSelection.range(r.from, r.to);\n  }));\n}\n/**\nConvert a snippet template to a function that can apply it.\nSnippets are written using syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n*/\n\n\nfunction snippet(template) {\n  var snippet = Snippet.parse(template);\n  return function (editor, _completion, from, to) {\n    var _snippet$instantiate = snippet.instantiate(editor.state, from),\n        text = _snippet$instantiate.text,\n        ranges = _snippet$instantiate.ranges;\n\n    var spec = {\n      changes: {\n        from: from,\n        to: to,\n        insert: Text.of(text)\n      }\n    };\n    if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n\n    if (ranges.length > 1) {\n      var active = new ActiveSnippet(ranges, 0);\n      var effects = spec.effects = [setActive.of(active)];\n      if (editor.state.field(snippetState, false) === undefined) effects.push(StateEffect.appendConfig.of([snippetState.init(function () {\n        return active;\n      }), addSnippetKeymap, snippetPointerHandler, baseTheme]));\n    }\n\n    editor.dispatch(editor.state.update(spec));\n  };\n}\n\nfunction moveField(dir) {\n  return function (_ref3) {\n    var state = _ref3.state,\n        dispatch = _ref3.dispatch;\n    var active = state.field(snippetState, false);\n    if (!active || dir < 0 && active.active == 0) return false;\n    var next = active.active + dir,\n        last = dir > 0 && !active.ranges.some(function (r) {\n      return r.field == next + dir;\n    });\n    dispatch(state.update({\n      selection: fieldSelection(active.ranges, next),\n      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n    }));\n    return true;\n  };\n}\n/**\nA command that clears the active snippet, if any.\n*/\n\n\nvar clearSnippet = function clearSnippet(_ref4) {\n  var state = _ref4.state,\n      dispatch = _ref4.dispatch;\n  var active = state.field(snippetState, false);\n  if (!active) return false;\n  dispatch(state.update({\n    effects: setActive.of(null)\n  }));\n  return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\n\n\nvar nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\n\nvar prevSnippetField = /*@__PURE__*/moveField(-1);\nvar defaultSnippetKeymap = [{\n  key: \"Tab\",\n  run: nextSnippetField,\n  shift: prevSnippetField\n}, {\n  key: \"Escape\",\n  run: clearSnippet\n}];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\n\nvar snippetKeymap = /*@__PURE__*/Facet.define({\n  combine: function combine(maps) {\n    return maps.length ? maps[0] : defaultSnippetKeymap;\n  }\n});\nvar addSnippetKeymap = /*@__PURE__*/Prec.override( /*@__PURE__*/keymap.compute([snippetKeymap], function (state) {\n  return state.facet(snippetKeymap);\n}));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\n\nfunction snippetCompletion(template, completion) {\n  return Object.assign(Object.assign({}, completion), {\n    apply: snippet(template)\n  });\n}\n\nvar snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({\n  mousedown: function mousedown(event, view) {\n    var active = view.state.field(snippetState, false),\n        pos;\n    if (!active || (pos = view.posAtCoords({\n      x: event.clientX,\n      y: event.clientY\n    })) == null) return false;\n    var match = active.ranges.find(function (r) {\n      return r.from <= pos && r.to >= pos;\n    });\n    if (!match || match.field == active.active) return false;\n    view.dispatch({\n      selection: fieldSelection(active.ranges, match.field),\n      effects: setActive.of(active.ranges.some(function (r) {\n        return r.field > match.field;\n      }) ? new ActiveSnippet(active.ranges, match.field) : null)\n    });\n    return true;\n  }\n});\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\n\nvar completeAnyWord = function completeAnyWord(context) {\n  var options = [],\n      seen = Object.create(null);\n  var cat = context.state.charCategorizer(context.pos);\n  var start = Math.max(0, context.pos - 50000\n  /* Range */\n  ),\n      end = Math.min(context.state.doc.length, start + 50000\n  /* Range */\n  * 2);\n  var from = context.pos;\n\n  for (var _cur = context.state.doc.iterRange(start, end), pos = start; !_cur.next().done;) {\n    var value = _cur.value,\n        _start = -1;\n\n    for (var _i6 = 0;; _i6++) {\n      if (_i6 < value.length && cat(value[_i6]) == CharCategory.Word) {\n        if (_start < 0) _start = _i6;\n      } else if (_start > -1) {\n        if (pos + _start <= context.pos && pos + _i6 >= context.pos) {\n          from = pos + _start;\n        } else {\n          var word = value.slice(_start, _i6);\n\n          if (!seen[word]) {\n            options.push({\n              type: \"text\",\n              label: word\n            });\n            seen[word] = true;\n          }\n        }\n\n        _start = -1;\n      }\n\n      if (_i6 == value.length) break;\n    }\n\n    pos += value.length;\n  }\n\n  return {\n    from: from,\n    options: options,\n    span: /^\\w*/\n  };\n};\n/**\nReturns an extension that enables autocompletion.\n*/\n\n\nfunction autocompletion() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\n\n\nvar completionKeymap = [{\n  key: \"Ctrl-Space\",\n  run: startCompletion\n}, {\n  key: \"Escape\",\n  run: closeCompletion\n}, {\n  key: \"ArrowDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true)\n}, {\n  key: \"ArrowUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false)\n}, {\n  key: \"PageDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true, \"page\")\n}, {\n  key: \"PageUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false, \"page\")\n}, {\n  key: \"Enter\",\n  run: acceptCompletion\n}];\nvar completionKeymapExt = /*@__PURE__*/Prec.override( /*@__PURE__*/keymap.computeN([completionConfig], function (state) {\n  return state.facet(completionConfig).defaultKeymap ? [completionKeymap] : [];\n}));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\n\nfunction completionStatus(state) {\n  var cState = state.field(completionState, false);\n  return cState && cState.active.some(function (a) {\n    return a.state == 1;\n  }\n  /* Pending */\n  ) ? \"pending\" : cState && cState.active.some(function (a) {\n    return a.state != 0;\n  }\n  /* Inactive */\n  ) ? \"active\" : null;\n}\n/**\nReturns the available completions as an array.\n*/\n\n\nfunction currentCompletions(state) {\n  var _a;\n\n  var open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open ? open.options.map(function (o) {\n    return o.completion;\n  }) : [];\n}\n\nexport { CompletionContext, acceptCompletion, autocompletion, clearSnippet, closeCompletion, completeAnyWord, completeFromList, completionKeymap, completionStatus, currentCompletions, ifNotIn, moveCompletionSelection, nextSnippetField, prevSnippetField, snippet, snippetCompletion, snippetKeymap, startCompletion };","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/@codemirror/autocomplete/dist/index.js"],"names":["Facet","combineConfig","StateEffect","StateField","Transaction","Text","EditorSelection","Prec","CharCategory","EditorView","Direction","logException","ViewPlugin","Decoration","WidgetType","keymap","showTooltip","syntaxTree","indentUnit","codePointAt","codePointSize","fromCodePoint","CompletionContext","state","pos","explicit","abortListeners","types","token","resolve","indexOf","name","parent","from","to","text","sliceDoc","type","expr","line","doc","lineAt","start","Math","max","str","slice","found","search","ensureAnchor","listener","push","toSet","chars","flat","Object","keys","join","words","test","replace","prefixMatch","options","first","create","rest","label","i","length","source","RegExp","completeFromList","list","map","o","every","span","match","context","matchBefore","ifNotIn","nodes","Option","completion","cur","selection","main","head","_a","addStart","addEnd","flags","ignoreCase","applyCompletion","view","option","apply","result","dispatch","changes","insert","anchor","SourceCache","WeakMap","asSource","Array","isArray","known","get","set","FuzzyMatcher","pattern","folded","any","precise","byWord","p","char","size","part","upper","toUpperCase","toLowerCase","astral","word","direct","len","anyTo","e","min","next","preciseTo","byWordTo","byWordFolded","adjacentTo","adjacentStart","adjacentEnd","hasLower","prevType","ch","score","positions","completionConfig","define","combine","configs","activateOnTyping","override","maxRenderedOptions","defaultKeymap","a","b","MaxInfoWidth","baseTheme","fontFamily","whiteSpace","overflow","maxWidth_fallback","maxWidth","maxHeight","listStyle","margin","padding","cursor","lineHeight","background_fallback","backgroundColor","color_fallback","color","content","opacity","display","textAlign","position","width","right","left","verticalAlign","height","borderLeft","textDecoration","marginLeft","fontStyle","fontSize","paddingRight","createListBox","id","range","ul","document","createElement","setAttribute","li","appendChild","icon","classList","add","labelElt","className","detail","off","j","createTextNode","detailElt","textContent","createInfoDialog","dom","info","then","node","rangeAroundSelected","total","selected","floor","CompletionTooltip","stateField","placeInfo","read","measureInfo","write","positionInfo","key","cState","field","open","config","facet","addEventListener","target","parentNode","nodeName","exec","preventDefault","requestMeasure","updateSel","update","startState","remove","updateSelectedOption","opt","firstChild","nextSibling","hasAttribute","removeAttribute","scrollIntoView","sel","querySelector","rect","getBoundingClientRect","top","clientHeight","textDirection","RTL","spaceLeft","spaceRight","innerWidth","style","toggle","completionTooltip","container","element","self","scrollTop","bottom","MaxOptions","boost","sortOptions","active","hasResult","matcher","sort","cmpOption","prev","CompletionDialog","attrs","tooltip","timestamp","makeAttrs","assign","mapPos","selectedValue","reduce","completionState","Date","now","CompletionState","tr","conf","sources","languageDataAt","value","find","s","ActiveSource","some","touchesRange","sameResults","build","docChanged","effects","effect","is","setSelectedEffect","setSelected","baseAttrs","none","random","toString","iA","iB","endA","endB","dScore","lA","lB","event","annotation","userEvent","handleUserEvent","handleChange","startCompletionEffect","closeCompletionEffect","setActiveEffect","_tr","ActiveResult","mapping","empty","provide","f","val","contentAttributes","CompletionInteractMargin","moveCompletionSelection","forward","by","step","offsetHeight","of","acceptCompletion","startCompletion","closeCompletion","RunningQuery","time","updates","done","undefined","DebounceTime","MaxUpdateCount","MinAbortTime","completionPlugin","fromClass","debounceUpdate","running","debounceAccept","composing","startQuery","selectionSet","doesReset","transactions","query","handler","splice","clearTimeout","q","setTimeout","startUpdate","r","pending","Promise","aborted","scheduleAccept","err","accept","updated","current","eventHandlers","compositionstart","compositionend","FieldPos","FieldRange","Snippet","lines","fieldPositions","lineStart","lineObj","baseIndent","indent","tabs","ranges","template","fields","m","split","seq","index","fieldMarker","widget","fieldRange","mark","class","ActiveSnippet","deco","setActive","moveToField","snippetState","selectionInsideField","decorations","fieldSelection","filter","snippet","parse","editor","_completion","instantiate","spec","appendConfig","init","addSnippetKeymap","snippetPointerHandler","moveField","dir","last","clearSnippet","nextSnippetField","prevSnippetField","defaultSnippetKeymap","run","shift","snippetKeymap","maps","compute","snippetCompletion","domEventHandlers","mousedown","posAtCoords","x","clientX","y","clientY","completeAnyWord","seen","cat","charCategorizer","end","iterRange","Word","autocompletion","completionKeymapExt","completionKeymap","computeN","completionStatus","currentCompletions"],"mappings":"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","sourcesContent":["import { Facet, combineConfig, StateEffect, StateField, Transaction, Text, EditorSelection, Prec, CharCategory } from '@codemirror/state';\nimport { EditorView, Direction, logException, ViewPlugin, Decoration, WidgetType, keymap } from '@codemirror/view';\nimport { showTooltip } from '@codemirror/tooltip';\nimport { syntaxTree, indentUnit } from '@codemirror/language';\nimport { codePointAt, codePointSize, fromCodePoint } from '@codemirror/text';\n\n/**\nAn instance of this is passed to completion source functions.\n*/\nclass CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sources—in the editor, the extension will create\n    these for you.)\n    */\n    constructor(\n    /**\n    The editor state that the completion happens in.\n    */\n    state, \n    /**\n    The position at which the completion is happening.\n    */\n    pos, \n    /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */\n    explicit) {\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        /**\n        @internal\n        */\n        this.abortListeners = [];\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */\n    tokenBefore(types) {\n        let token = syntaxTree(this.state).resolve(this.pos, -1);\n        while (token && types.indexOf(token.name) < 0)\n            token = token.parent;\n        return token ? { from: token.from, to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */\n    matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */\n    get aborted() { return this.abortListeners == null; }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */\n    addEventListener(type, listener) {\n        if (type == \"abort\" && this.abortListeners)\n            this.abortListeners.push(listener);\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words)\n        flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options) {\n        first[label[0]] = true;\n        for (let i = 1; i < label.length; i++)\n            rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\nfunction completeFromList(list) {\n    let options = list.map(o => typeof o == \"string\" ? { label: o } : o);\n    let [span, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n    return (context) => {\n        let token = context.matchBefore(match);\n        return token || context.explicit ? { from: token ? token.from : context.pos, options, span } : null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifNotIn(nodes, source) {\n    return (context) => {\n        for (let pos = syntaxTree(context.state).resolve(context.pos, -1); pos; pos = pos.parent)\n            if (nodes.indexOf(pos.name) > -1)\n                return null;\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match) {\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n    }\n}\nfunction cur(state) { return state.selection.main.head; }\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd)\n        return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? \"i\" : \"\"));\n}\nfunction applyCompletion(view, option) {\n    let apply = option.completion.apply || option.completion.label;\n    let result = option.source;\n    if (typeof apply == \"string\") {\n        view.dispatch({\n            changes: { from: result.from, to: result.to, insert: apply },\n            selection: { anchor: result.from + apply.length }\n        });\n    }\n    else {\n        apply(view, option.completion, result.from, result.to);\n    }\n}\nconst SourceCache = /*@__PURE__*/new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source))\n        return source;\n    let known = SourceCache.get(source);\n    if (!known)\n        SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\n\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern) {\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        for (let p = 0; p < pattern.length;) {\n            let char = codePointAt(pattern, p), size = codePointSize(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return null for no match, and otherwise an array that starts\n    // with the match score, followed by any number of `from, to` pairs\n    // indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0)\n            return [0];\n        if (word.length < this.pattern.length)\n            return null;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = codePointAt(word, 0);\n            return first == chars[0] ? [0, 0, codePointSize(first)]\n                : first == folded[0] ? [-200 /* CaseFold */, 0, codePointSize(first)] : null;\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0)\n            return [0, 0, this.pattern.length];\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n                let next = codePointAt(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo])\n                    any[anyTo++] = i;\n                i += codePointSize(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len)\n                return null;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word);\n        // Go over the option's text, scanning for the various kinds of matches\n        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* NonWord */; i < e && byWordTo < len;) {\n            let next = codePointAt(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo])\n                    precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0)\n                            adjacentStart = i;\n                        adjacentEnd = i;\n                        adjacentTo++;\n                    }\n                    else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff\n                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Lower */ : next >= 65 && next <= 90 ? 1 /* Upper */ : 0 /* NonWord */)\n                : ((ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Upper */ : ch != ch.toUpperCase() ? 2 /* Lower */ : 0 /* NonWord */);\n            if ((type == 1 /* Upper */ && hasLower || prevType == 0 /* NonWord */ && type != 0 /* NonWord */) &&\n                (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true))))\n                byWord[byWordTo++] = i;\n            prevType = type;\n            i += codePointSize(next);\n        }\n        if (byWordTo == len && byWord[0] == 0)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0)\n            return [-200 /* CaseFold */, 0, adjacentEnd];\n        if (direct > -1)\n            return [-700 /* NotStart */, direct, direct + this.pattern.length];\n        if (adjacentTo == len)\n            return [-200 /* CaseFold */ + -700 /* NotStart */, adjacentStart, adjacentEnd];\n        if (byWordTo == len)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0) + -700 /* NotStart */, byWord, word);\n        return chars.length == 2 ? null : this.result((any[0] ? -700 /* NotStart */ : 0) + -200 /* CaseFold */ + -1100 /* Gap */, any, word);\n    }\n    result(score, positions, word) {\n        let result = [score], i = 1;\n        for (let pos of positions) {\n            let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);\n            if (i > 1 && result[i - 1] == pos)\n                result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return result;\n    }\n}\n\nconst completionConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            activateOnTyping: true,\n            override: null,\n            maxRenderedOptions: 100,\n            defaultKeymap: true\n        }, {\n            defaultKeymap: (a, b) => a && b\n        });\n    }\n});\n\nconst MaxInfoWidth = 300;\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            maxHeight: \"10em\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li\": {\n                cursor: \"pointer\",\n                padding: \"1px 1em 1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li[aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            }\n        }\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"···\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: MaxInfoWidth + \"px\",\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": { right: \"100%\" },\n    \".cm-completionInfo.cm-completionInfo-right\": { left: \"100%\" },\n    \"&light .cm-snippetField\": { backgroundColor: \"#00000022\" },\n    \"&dark .cm-snippetField\": { backgroundColor: \"#ffffff22\" },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": { content: \"'ƒ'\" }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": { content: \"'○'\" }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": { content: \"'◌'\" }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": { content: \"'𝑥'\" }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": { content: \"'𝐶'\" }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": { content: \"'𝑡'\" }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": { content: \"'∪'\" }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": { content: \"'□'\" }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": { content: \"'🔑\\uFE0E'\" } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": { content: \"'▢'\" }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": { content: \"'abc'\", fontSize: \"50%\", verticalAlign: \"middle\" }\n    }\n});\n\nfunction createListBox(options, id, range) {\n    const ul = document.createElement(\"ul\");\n    ul.id = id;\n    ul.setAttribute(\"role\", \"listbox\");\n    ul.setAttribute(\"aria-expanded\", \"true\");\n    for (let i = range.from; i < range.to; i++) {\n        let { completion, match } = options[i];\n        const li = ul.appendChild(document.createElement(\"li\"));\n        li.id = id + \"-\" + i;\n        let icon = li.appendChild(document.createElement(\"div\"));\n        icon.classList.add(\"cm-completionIcon\");\n        if (completion.type)\n            icon.classList.add(\"cm-completionIcon-\" + completion.type);\n        icon.setAttribute(\"aria-hidden\", \"true\");\n        let labelElt = li.appendChild(document.createElement(\"span\"));\n        labelElt.className = \"cm-completionLabel\";\n        let { label, detail } = completion, off = 0;\n        for (let j = 1; j < match.length;) {\n            let from = match[j++], to = match[j++];\n            if (from > off)\n                labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n            let span = labelElt.appendChild(document.createElement(\"span\"));\n            span.appendChild(document.createTextNode(label.slice(from, to)));\n            span.className = \"cm-completionMatchedText\";\n            off = to;\n        }\n        if (off < label.length)\n            labelElt.appendChild(document.createTextNode(label.slice(off)));\n        if (detail) {\n            let detailElt = li.appendChild(document.createElement(\"span\"));\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = detail;\n        }\n        li.setAttribute(\"role\", \"option\");\n    }\n    if (range.from)\n        ul.classList.add(\"cm-completionListIncompleteTop\");\n    if (range.to < options.length)\n        ul.classList.add(\"cm-completionListIncompleteBottom\");\n    return ul;\n}\nfunction createInfoDialog(option, view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-tooltip cm-completionInfo\";\n    let { info } = option.completion;\n    if (typeof info == \"string\") {\n        dom.textContent = info;\n    }\n    else {\n        let content = info(option.completion);\n        if (content.then)\n            content.then(node => dom.appendChild(node), e => logException(view.state, e, \"completion info\"));\n        else\n            dom.appendChild(content);\n    }\n    return dom;\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max)\n        return { from: 0, to: total };\n    if (selected <= (total >> 1)) {\n        let off = Math.floor(selected / max);\n        return { from: off * max, to: (off + 1) * max };\n    }\n    let off = Math.floor((total - selected) / max);\n    return { from: total - (off + 1) * max, to: total - off * max };\n}\nclass CompletionTooltip {\n    constructor(view, stateField) {\n        this.view = view;\n        this.stateField = stateField;\n        this.info = null;\n        this.placeInfo = {\n            read: () => this.measureInfo(),\n            write: (pos) => this.positionInfo(pos),\n            key: this\n        };\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.dom.addEventListener(\"mousedown\", (e) => {\n            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.list = this.dom.appendChild(createListBox(options, cState.id, this.range));\n        this.list.addEventListener(\"scroll\", () => {\n            if (this.info)\n                this.view.requestMeasure(this.placeInfo);\n        });\n    }\n    mount() { this.updateSel(); }\n    update(update) {\n        if (update.state.field(this.stateField) != update.startState.field(this.stateField))\n            this.updateSel();\n    }\n    positioned() {\n        if (this.info)\n            this.view.requestMeasure(this.placeInfo);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.list.remove();\n            this.list = this.dom.appendChild(createListBox(open.options, cState.id, this.range));\n            this.list.addEventListener(\"scroll\", () => {\n                if (this.info)\n                    this.view.requestMeasure(this.placeInfo);\n            });\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            if (this.info) {\n                this.info.remove();\n                this.info = null;\n            }\n            let option = open.options[open.selected];\n            if (option.completion.info) {\n                this.info = this.dom.appendChild(createInfoDialog(option, this.view));\n                this.view.requestMeasure(this.placeInfo);\n            }\n        }\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n            if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            }\n            else {\n                if (opt.hasAttribute(\"aria-selected\"))\n                    opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set)\n            scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel)\n            return null;\n        let rect = this.dom.getBoundingClientRect();\n        let top = sel.getBoundingClientRect().top - rect.top;\n        if (top < 0 || top > this.list.clientHeight - 10)\n            return null;\n        let left = this.view.textDirection == Direction.RTL;\n        let spaceLeft = rect.left, spaceRight = innerWidth - rect.right;\n        if (left && spaceLeft < Math.min(MaxInfoWidth, spaceRight))\n            left = false;\n        else if (!left && spaceRight < Math.min(MaxInfoWidth, spaceLeft))\n            left = true;\n        return { top, left };\n    }\n    positionInfo(pos) {\n        if (this.info && pos) {\n            this.info.style.top = pos.top + \"px\";\n            this.info.classList.toggle(\"cm-completionInfo-left\", pos.left);\n            this.info.classList.toggle(\"cm-completionInfo-right\", !pos.left);\n        }\n    }\n}\n// We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\nfunction completionTooltip(stateField) {\n    return (view) => new CompletionTooltip(view, stateField);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    if (self.top < parent.top)\n        container.scrollTop -= parent.top - self.top;\n    else if (self.bottom > parent.bottom)\n        container.scrollTop += self.bottom - parent.bottom;\n}\n\nconst MaxOptions = 300;\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +\n        (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    for (let a of active)\n        if (a.hasResult()) {\n            let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;\n            for (let option of a.result.options)\n                if (match = matcher.match(option.label)) {\n                    if (option.boost != null)\n                        match[0] += option.boost;\n                    options.push(new Option(option, a, match));\n                }\n        }\n    options.sort(cmpOption);\n    let result = [], prev = null;\n    for (let opt of options.sort(cmpOption)) {\n        if (result.length == MaxOptions)\n            break;\n        if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail)\n            result.push(opt);\n        else if (score(opt.completion) > score(prev))\n            result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected) {\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this\n            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);\n    }\n    static build(active, state, id, prev) {\n        let options = sortOptions(active, state);\n        if (!options.length)\n            return null;\n        let selected = 0;\n        if (prev && prev.selected) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for (let i = 0; i < options.length && !selected; i++) {\n                if (options[i].completion == selectedValue)\n                    selected = i;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: completionTooltip(completionState)\n        }, prev ? prev.timestamp : Date.now(), selected);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open) {\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override ||\n            state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map(source => {\n            let value = this.active.find(s => s.source == source) || new ActiveSource(source, 0 /* Inactive */, false);\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))\n            active = this.active;\n        let open = tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||\n            !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open)\n            : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;\n        if (!open && active.every(a => a.state != 1 /* Pending */) && active.some(a => a.hasResult()))\n            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* Inactive */, false) : a);\n        for (let effect of tr.effects)\n            if (effect.is(setSelectedEffect))\n                open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() { return this.open ? this.open.tooltip : null; }\n    get attrs() { return this.open ? this.open.attrs : baseAttrs; }\n}\nfunction sameResults(a, b) {\n    if (a == b)\n        return true;\n    for (let iA = 0, iB = 0;;) {\n        while (iA < a.length && !a[iA].hasResult)\n            iA++;\n        while (iB < b.length && !b[iB].hasResult)\n            iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB)\n            return endA == endB;\n        if (a[iA++].result != b[iB++].result)\n            return false;\n    }\n}\nfunction makeAttrs(id, selected) {\n    return {\n        \"aria-autocomplete\": \"list\",\n        \"aria-activedescendant\": id + \"-\" + selected,\n        \"aria-owns\": id\n    };\n}\nconst baseAttrs = { \"aria-autocomplete\": \"list\" }, none = [];\nfunction cmpOption(a, b) {\n    let dScore = b.match[0] - a.match[0];\n    if (dScore)\n        return dScore;\n    let lA = a.completion.label, lB = b.completion.label;\n    return lA < lB ? -1 : lA == lB ? 0 : 1;\n}\nclass ActiveSource {\n    constructor(source, state, explicit) {\n        this.source = source;\n        this.state = state;\n        this.explicit = explicit;\n    }\n    hasResult() { return false; }\n    update(tr, conf) {\n        let event = tr.annotation(Transaction.userEvent), value = this;\n        if (event == \"input\" || event == \"delete\")\n            value = value.handleUserEvent(tr, event, conf);\n        else if (tr.docChanged)\n            value = value.handleChange(tr);\n        else if (tr.selection && value.state != 0 /* Inactive */)\n            value = new ActiveSource(value.source, 0 /* Inactive */, false);\n        for (let effect of tr.effects) {\n            if (effect.is(startCompletionEffect))\n                value = new ActiveSource(value.source, 1 /* Pending */, effect.value);\n            else if (effect.is(closeCompletionEffect))\n                value = new ActiveSource(value.source, 0 /* Inactive */, false);\n            else if (effect.is(setActiveEffect))\n                for (let active of effect.value)\n                    if (active.source == value.source)\n                        value = active;\n        }\n        return value;\n    }\n    handleUserEvent(_tr, type, conf) {\n        return type == \"delete\" || !conf.activateOnTyping ? this : new ActiveSource(this.source, 1 /* Pending */, false);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* Inactive */, false) : this;\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicit, result, from, to, span) {\n        super(source, 2 /* Result */, explicit);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n        this.span = span;\n    }\n    hasResult() { return true; }\n    handleUserEvent(tr, type, conf) {\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicit ? pos < from : pos <= from) || pos > to)\n            return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* Pending */ : 0 /* Inactive */, false);\n        if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to))))\n            return new ActiveResult(this.source, this.explicit, this.result, from, to, this.span);\n        return new ActiveSource(this.source, 1 /* Pending */, this.explicit);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(this.from, this.to)\n            ? new ActiveSource(this.source, 0 /* Inactive */, false)\n            : new ActiveResult(this.source, this.explicit, this.result, tr.changes.mapPos(this.from), tr.changes.mapPos(this.to, 1), this.span);\n    }\n    map(mapping) {\n        return new ActiveResult(this.source, this.explicit, this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);\n    }\n}\nconst startCompletionEffect = /*@__PURE__*/StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/StateEffect.define();\nconst setActiveEffect = /*@__PURE__*/StateEffect.define({\n    map(sources, mapping) { return sources.map(s => s.hasResult() && !mapping.empty ? s.map(mapping) : s); }\n});\nconst setSelectedEffect = /*@__PURE__*/StateEffect.define();\nconst completionState = /*@__PURE__*/StateField.define({\n    create() { return CompletionState.start(); },\n    update(value, tr) { return value.update(tr); },\n    provide: f => [\n        showTooltip.from(f, val => val.tooltip),\n        EditorView.contentAttributes.from(f, state => state.attrs)\n    ]\n});\n\nconst CompletionInteractMargin = 75;\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\nfunction moveCompletionSelection(forward, by = \"option\") {\n    return (view) => {\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)\n            return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = view.dom.querySelector(\".cm-tooltip-autocomplete\")))\n            step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));\n        let selected = cState.open.selected + step * (forward ? 1 : -1), { length } = cState.open.options;\n        if (selected < 0)\n            selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length)\n            selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({ effects: setSelectedEffect.of(selected) });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/\nconst acceptCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)\n        return false;\n    applyCompletion(view, cState.open.options[cState.open.selected]);\n    return true;\n};\n/**\nExplicitly start autocompletion.\n*/\nconst startCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState)\n        return false;\n    view.dispatch({ effects: startCompletionEffect.of(true) });\n    return true;\n};\n/**\nClose the currently active completion.\n*/\nconst closeCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some(a => a.state != 0 /* Inactive */))\n        return false;\n    view.dispatch({ effects: closeCompletionEffect.of(null) });\n    return true;\n};\nclass RunningQuery {\n    constructor(source, context) {\n        this.source = source;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.composing = 0 /* None */;\n        for (let active of view.state.field(completionState).active)\n            if (active.state == 1 /* Pending */)\n                this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)\n            return;\n        let doesReset = update.transactions.some(tr => {\n            let event = tr.annotation(Transaction.userEvent);\n            return (tr.selection || tr.docChanged) && event != \"input\" && event != \"delete\";\n        });\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (doesReset ||\n                query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {\n                for (let handler of query.context.abortListeners) {\n                    try {\n                        handler();\n                    }\n                    catch (e) {\n                        logException(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            }\n            else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1)\n            clearTimeout(this.debounceUpdate);\n        this.debounceUpdate = cState.active.some(a => a.state == 1 /* Pending */ && !this.running.some(q => q.source == a.source))\n            ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\n        if (this.composing != 0 /* None */)\n            for (let tr of update.transactions) {\n                if (tr.annotation(Transaction.userEvent) == \"input\")\n                    this.composing = 2 /* Changed */;\n                else if (this.composing == 2 /* Changed */ && tr.selection)\n                    this.composing = 3 /* ChangedAndMoved */;\n            }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active) {\n            if (active.state == 1 /* Pending */ && !this.running.some(r => r.source == active.source))\n                this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicit);\n        let pending = new RunningQuery(active.source, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then(result => {\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, err => {\n            this.view.dispatch({ effects: closeCompletionEffect.of(null) });\n            logException(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every(q => q.done !== undefined))\n            this.accept();\n        else if (this.debounceAccept < 0)\n            this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1)\n            clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (query.done === undefined)\n                continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.source, query.context.explicit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span ? ensureAnchor(query.done.span, true) : null);\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)\n                    active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find(a => a.source == query.source);\n            if (current && current.state == 1 /* Pending */) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.source, 0 /* Inactive */, false);\n                    for (let tr of query.updates)\n                        active = active.update(tr, conf);\n                    if (active.state != 1 /* Pending */)\n                        updated.push(active);\n                }\n                else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length)\n            this.view.dispatch({ effects: setActiveEffect.of(updated) });\n    }\n}, {\n    eventHandlers: {\n        compositionstart() {\n            this.composing = 1 /* Started */;\n        },\n        compositionend() {\n            if (this.composing == 3 /* ChangedAndMoved */) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);\n            }\n            this.composing = 0 /* None */;\n        }\n    }\n});\n\nclass FieldPos {\n    constructor(field, line, from, to) {\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to) {\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions) {\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [pos];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines) {\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for (let i = 0; i < tabs; i++)\n                    indent += state.facet(indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return { text, ranges };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)) {\n            while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3], found = -1;\n                for (let i = 0; i < fields.length; i++) {\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)\n                        found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))\n                        i++;\n                    fields.splice(i, 0, { seq, name: name || null });\n                    found = i;\n                    for (let pos of positions)\n                        if (pos.field >= found)\n                            pos.field++;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n            }\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/Decoration.widget({ widget: /*@__PURE__*/new class extends WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() { return false; }\n    } });\nlet fieldRange = /*@__PURE__*/Decoration.mark({ class: \"cm-snippetField\" });\nclass ActiveSnippet {\n    constructor(ranges, active) {\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        return new ActiveSnippet(this.ranges.map(r => r.map(changes)), this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/StateEffect.define({\n    map(value, changes) { return value && value.map(changes); }\n});\nconst moveToField = /*@__PURE__*/StateEffect.define();\nconst snippetState = /*@__PURE__*/StateField.define({\n    create() { return null; },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setActive))\n                return effect.value;\n            if (effect.is(moveToField) && value)\n                return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged)\n            value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection))\n            value = null;\n        return value;\n    },\n    provide: f => EditorView.decorations.from(f, val => val ? val.deco : Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return EditorSelection.create(ranges.filter(r => r.field == field).map(r => EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can apply it.\nSnippets are written using syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n*/\nfunction snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, _completion, from, to) => {\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = { changes: { from, to, insert: Text.of(text) } };\n        if (ranges.length)\n            spec.selection = fieldSelection(ranges, 0);\n        if (ranges.length > 1) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [setActive.of(active)];\n            if (editor.state.field(snippetState, false) === undefined)\n                effects.push(StateEffect.appendConfig.of([snippetState.init(() => active), addSnippetKeymap,\n                    snippetPointerHandler, baseTheme]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch }) => {\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0)\n            return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/\nconst clearSnippet = ({ state, dispatch }) => {\n    let active = state.field(snippetState, false);\n    if (!active)\n        return false;\n    dispatch(state.update({ effects: setActive.of(null) }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\nconst nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\nconst prevSnippetField = /*@__PURE__*/moveField(-1);\nconst defaultSnippetKeymap = [\n    { key: \"Tab\", run: nextSnippetField, shift: prevSnippetField },\n    { key: \"Escape\", run: clearSnippet }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\nconst snippetKeymap = /*@__PURE__*/Facet.define({\n    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }\n});\nconst addSnippetKeymap = /*@__PURE__*/Prec.override(/*@__PURE__*/keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\nfunction snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });\n}\nconst snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({\n    mousedown(event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)\n            return false;\n        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active)\n            return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)\n        });\n        return true;\n    }\n});\n\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\nconst completeAnyWord = context => {\n    let options = [], seen = Object.create(null);\n    let cat = context.state.charCategorizer(context.pos);\n    let start = Math.max(0, context.pos - 50000 /* Range */), end = Math.min(context.state.doc.length, start + 50000 /* Range */ * 2);\n    let from = context.pos;\n    for (let cur = context.state.doc.iterRange(start, end), pos = start; !(cur.next()).done;) {\n        let { value } = cur, start = -1;\n        for (let i = 0;; i++) {\n            if (i < value.length && cat(value[i]) == CharCategory.Word) {\n                if (start < 0)\n                    start = i;\n            }\n            else if (start > -1) {\n                if (pos + start <= context.pos && pos + i >= context.pos) {\n                    from = pos + start;\n                }\n                else {\n                    let word = value.slice(start, i);\n                    if (!seen[word]) {\n                        options.push({ type: \"text\", label: word });\n                        seen[word] = true;\n                    }\n                }\n                start = -1;\n            }\n            if (i == value.length)\n                break;\n        }\n        pos += value.length;\n    }\n    return { from, options, span: /^\\w*/ };\n};\n\n/**\nReturns an extension that enables autocompletion.\n*/\nfunction autocompletion(config = {}) {\n    return [\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\nconst completionKeymap = [\n    { key: \"Ctrl-Space\", run: startCompletion },\n    { key: \"Escape\", run: closeCompletion },\n    { key: \"ArrowDown\", run: /*@__PURE__*/moveCompletionSelection(true) },\n    { key: \"ArrowUp\", run: /*@__PURE__*/moveCompletionSelection(false) },\n    { key: \"PageDown\", run: /*@__PURE__*/moveCompletionSelection(true, \"page\") },\n    { key: \"PageUp\", run: /*@__PURE__*/moveCompletionSelection(false, \"page\") },\n    { key: \"Enter\", run: acceptCompletion }\n];\nconst completionKeymapExt = /*@__PURE__*/Prec.override(/*@__PURE__*/keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\nfunction completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some(a => a.state == 1 /* Pending */) ? \"pending\"\n        : cState && cState.active.some(a => a.state != 0 /* Inactive */) ? \"active\" : null;\n}\n/**\nReturns the available completions as an array.\n*/\nfunction currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open ? open.options.map(o => o.completion) : [];\n}\n\nexport { CompletionContext, acceptCompletion, autocompletion, clearSnippet, closeCompletion, completeAnyWord, completeFromList, completionKeymap, completionStatus, currentCompletions, ifNotIn, moveCompletionSelection, nextSnippetField, prevSnippetField, snippet, snippetCompletion, snippetKeymap, startCompletion };\n"]},"metadata":{},"sourceType":"module"}