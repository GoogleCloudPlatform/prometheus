{"ast":null,"code":"import _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { EqlRegex, EqlSingle, LabelName, MatchOp, Neq, NeqRegex, StringLiteral } from 'lezer-promql';\nimport { Matcher } from '../types';\n\nfunction createMatcher(labelMatcher, state) {\n  var matcher = new Matcher(0, '', '');\n  var cursor = labelMatcher.cursor;\n\n  if (!cursor.next()) {\n    // weird case, that would mean the labelMatcher doesn't have any child.\n    return matcher;\n  }\n\n  do {\n    switch (cursor.type.id) {\n      case LabelName:\n        matcher.name = state.sliceDoc(cursor.from, cursor.to);\n        break;\n\n      case MatchOp:\n        var ope = cursor.node.firstChild;\n\n        if (ope) {\n          matcher.type = ope.type.id;\n        }\n\n        break;\n\n      case StringLiteral:\n        matcher.value = state.sliceDoc(cursor.from, cursor.to).slice(1, -1);\n        break;\n    }\n  } while (cursor.nextSibling());\n\n  return matcher;\n}\n\nexport function buildLabelMatchers(labelMatchers, state) {\n  var matchers = [];\n  labelMatchers.forEach(function (value) {\n    matchers.push(createMatcher(value, state));\n  });\n  return matchers;\n}\nexport function labelMatchersToString(metricName, matchers, labelName) {\n  if (!matchers || matchers.length === 0) {\n    return metricName;\n  }\n\n  var matchersAsString = '';\n\n  var _iterator = _createForOfIteratorHelper(matchers),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var matcher = _step.value;\n\n      if (matcher.name === labelName || matcher.value === '') {\n        continue;\n      }\n\n      var type = '';\n\n      switch (matcher.type) {\n        case EqlSingle:\n          type = '=';\n          break;\n\n        case Neq:\n          type = '!=';\n          break;\n\n        case NeqRegex:\n          type = '!~';\n          break;\n\n        case EqlRegex:\n          type = '=~';\n          break;\n\n        default:\n          type = '=';\n      }\n\n      var m = \"\".concat(matcher.name).concat(type, \"\\\"\").concat(matcher.value, \"\\\"\");\n\n      if (matchersAsString === '') {\n        matchersAsString = m;\n      } else {\n        matchersAsString = \"\".concat(matchersAsString, \",\").concat(m);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return \"\".concat(metricName, \"{\").concat(matchersAsString, \"}\");\n}","map":{"version":3,"sources":["../../../src/lang-promql/parser/matcher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { EqlRegex, EqlSingle, LabelName, MatchOp, Neq, NeqRegex, StringLiteral } from 'lezer-promql';\nimport { Matcher } from '../types';\nfunction createMatcher(labelMatcher, state) {\n    const matcher = new Matcher(0, '', '');\n    const cursor = labelMatcher.cursor;\n    if (!cursor.next()) {\n        // weird case, that would mean the labelMatcher doesn't have any child.\n        return matcher;\n    }\n    do {\n        switch (cursor.type.id) {\n            case LabelName:\n                matcher.name = state.sliceDoc(cursor.from, cursor.to);\n                break;\n            case MatchOp:\n                const ope = cursor.node.firstChild;\n                if (ope) {\n                    matcher.type = ope.type.id;\n                }\n                break;\n            case StringLiteral:\n                matcher.value = state.sliceDoc(cursor.from, cursor.to).slice(1, -1);\n                break;\n        }\n    } while (cursor.nextSibling());\n    return matcher;\n}\nexport function buildLabelMatchers(labelMatchers, state) {\n    const matchers = [];\n    labelMatchers.forEach((value) => {\n        matchers.push(createMatcher(value, state));\n    });\n    return matchers;\n}\nexport function labelMatchersToString(metricName, matchers, labelName) {\n    if (!matchers || matchers.length === 0) {\n        return metricName;\n    }\n    let matchersAsString = '';\n    for (const matcher of matchers) {\n        if (matcher.name === labelName || matcher.value === '') {\n            continue;\n        }\n        let type = '';\n        switch (matcher.type) {\n            case EqlSingle:\n                type = '=';\n                break;\n            case Neq:\n                type = '!=';\n                break;\n            case NeqRegex:\n                type = '!~';\n                break;\n            case EqlRegex:\n                type = '=~';\n                break;\n            default:\n                type = '=';\n        }\n        const m = `${matcher.name}${type}\"${matcher.value}\"`;\n        if (matchersAsString === '') {\n            matchersAsString = m;\n        }\n        else {\n            matchersAsString = `${matchersAsString},${m}`;\n        }\n    }\n    return `${metricName}{${matchersAsString}}`;\n}\n//# sourceMappingURL=matcher.js.map"]},"metadata":{},"sourceType":"module"}