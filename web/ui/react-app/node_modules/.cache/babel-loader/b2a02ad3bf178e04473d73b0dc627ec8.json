{"ast":null,"code":"import _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Annotation, Facet, combineConfig, StateField, Transaction, ChangeSet, ChangeDesc, EditorSelection, StateEffect } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nvar fromHistory = Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\n\nvar isolateHistory = Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\n\nvar invertedEffects = Facet.define();\nvar historyConfig = Facet.define({\n  combine: function combine(configs) {\n    return combineConfig(configs, {\n      minDepth: 100,\n      newGroupDelay: 500\n    }, {\n      minDepth: Math.max,\n      newGroupDelay: Math.min\n    });\n  }\n});\nvar historyField_ = StateField.define({\n  create: function create() {\n    return HistoryState.empty;\n  },\n  update: function update(state, tr) {\n    var config = tr.state.facet(historyConfig);\n    var fromHist = tr.annotation(fromHistory);\n\n    if (fromHist) {\n      var item = HistEvent.fromTransaction(tr),\n          from = fromHist.side;\n      var other = from == 0\n      /* Done */\n      ? state.undone : state.done;\n      if (item) other = updateBranch(other, other.length, config.minDepth, item);else other = _addSelection(other, tr.startState.selection);\n      return new HistoryState(from == 0\n      /* Done */\n      ? fromHist.rest : other, from == 0\n      /* Done */\n      ? other : fromHist.rest);\n    }\n\n    var isolate = tr.annotation(isolateHistory);\n    if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n    if (tr.annotation(Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n    var event = HistEvent.fromTransaction(tr);\n    var time = tr.annotation(Transaction.time),\n        userEvent = tr.annotation(Transaction.userEvent);\n    if (event) state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n    if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n    return state;\n  },\n  toJSON: function toJSON(value) {\n    return {\n      done: value.done.map(function (e) {\n        return e.toJSON();\n      }),\n      undone: value.undone.map(function (e) {\n        return e.toJSON();\n      })\n    };\n  },\n  fromJSON: function fromJSON(json) {\n    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n  }\n});\n/**\nCreate a history extension with the given configuration.\n*/\n\nfunction history() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [historyField_, historyConfig.of(config), EditorView.domEventHandlers({\n    beforeinput: function beforeinput(e, view) {\n      if (e.inputType == \"historyUndo\") return undo(view);\n      if (e.inputType == \"historyRedo\") return redo(view);\n      return false;\n    }\n  })];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\n\n\nvar historyField = historyField_;\n\nfunction cmd(side, selection) {\n  return function (_ref) {\n    var state = _ref.state,\n        dispatch = _ref.dispatch;\n    var historyState = state.field(historyField_, false);\n    if (!historyState) return false;\n    var tr = historyState.pop(side, state, selection);\n    if (!tr) return false;\n    dispatch(tr);\n    return true;\n  };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\n\n\nvar undo = cmd(0\n/* Done */\n, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\n\nvar redo = cmd(1\n/* Undone */\n, false);\n/**\nUndo a selection change.\n*/\n\nvar undoSelection = cmd(0\n/* Done */\n, true);\n/**\nRedo a selection change.\n*/\n\nvar redoSelection = cmd(1\n/* Undone */\n, true);\n\nfunction depth(side) {\n  return function (state) {\n    var histState = state.field(historyField_, false);\n    if (!histState) return 0;\n    var branch = side == 0\n    /* Done */\n    ? histState.done : histState.undone;\n    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n  };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\n\n\nvar undoDepth = depth(0\n/* Done */\n);\n/**\nThe amount of redoable change events available in a given state.\n*/\n\nvar redoDepth = depth(1\n/* Undone */\n); // History events store groups of changes or effects that need to be\n// undone/redone together.\n\nvar HistEvent = /*#__PURE__*/function () {\n  function HistEvent( // The changes in this event. Normal events hold at least one\n  // change or effect. But it may be necessary to store selection\n  // events before the first change, in which case a special type of\n  // instance is created which doesn't hold any changes, with\n  // changes == startSelection == undefined\n  changes, // The effects associated with this event\n  effects, mapped, // The selection before this event\n  startSelection, // Stores selection changes after this event, to be used for\n  // selection undo/redo.\n  selectionsAfter) {\n    _classCallCheck(this, HistEvent);\n\n    this.changes = changes;\n    this.effects = effects;\n    this.mapped = mapped;\n    this.startSelection = startSelection;\n    this.selectionsAfter = selectionsAfter;\n  }\n\n  _createClass(HistEvent, [{\n    key: \"setSelAfter\",\n    value: function setSelAfter(after) {\n      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _a, _b, _c;\n\n      return {\n        changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n        selectionsAfter: this.selectionsAfter.map(function (s) {\n          return s.toJSON();\n        })\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));\n    } // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n\n  }, {\n    key: \"fromTransaction\",\n    value: function fromTransaction(tr) {\n      var effects = none;\n\n      var _iterator = _createForOfIteratorHelper(tr.startState.facet(invertedEffects)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var invert = _step.value;\n          var result = invert(tr);\n          if (result.length) effects = effects.concat(result);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (!effects.length && tr.changes.empty) return null;\n      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, tr.startState.selection, none);\n    }\n  }, {\n    key: \"selection\",\n    value: function selection(selections) {\n      return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n  }]);\n\n  return HistEvent;\n}();\n\nfunction updateBranch(branch, to, maxLen, newEvent) {\n  var start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n  var newBranch = branch.slice(start, to);\n  newBranch.push(newEvent);\n  return newBranch;\n}\n\nfunction isAdjacent(a, b) {\n  var ranges = [],\n      isAdjacent = false;\n  a.iterChangedRanges(function (f, t) {\n    return ranges.push(f, t);\n  });\n  b.iterChangedRanges(function (_f, _t, f, t) {\n    for (var i = 0; i < ranges.length;) {\n      var from = ranges[i++],\n          to = ranges[i++];\n      if (t >= from && f <= to) isAdjacent = true;\n    }\n  });\n  return isAdjacent;\n}\n\nfunction eqSelectionShape(a, b) {\n  return a.ranges.length == b.ranges.length && a.ranges.filter(function (r, i) {\n    return r.empty != b.ranges[i].empty;\n  }).length === 0;\n}\n\nfunction conc(a, b) {\n  return !a.length ? b : !b.length ? a : a.concat(b);\n}\n\nvar none = [];\nvar MaxSelectionsPerEvent = 200;\n\nfunction _addSelection(branch, selection) {\n  if (!branch.length) {\n    return [HistEvent.selection([selection])];\n  } else {\n    var lastEvent = branch[branch.length - 1];\n    var sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n    if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n    sels.push(selection);\n    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n  }\n} // Assumes the top item has one or more selectionAfter values\n\n\nfunction popSelection(branch) {\n  var last = branch[branch.length - 1];\n  var newBranch = branch.slice();\n  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n  return newBranch;\n} // Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\n\n\nfunction addMappingToBranch(branch, mapping) {\n  if (!branch.length) return branch;\n  var length = branch.length,\n      selections = none;\n\n  while (length) {\n    var event = mapEvent(branch[length - 1], mapping, selections);\n\n    if (event.changes && !event.changes.empty || event.effects.length) {\n      // Event survived mapping\n      var result = branch.slice(0, length);\n      result[length - 1] = event;\n      return result;\n    } else {\n      // Drop this event, since there's no changes or effects left\n      mapping = event.mapped;\n      length--;\n      selections = event.selectionsAfter;\n    }\n  }\n\n  return selections.length ? [HistEvent.selection(selections)] : none;\n}\n\nfunction mapEvent(event, mapping, extraSelections) {\n  var selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(function (s) {\n    return s.map(mapping);\n  }) : none, extraSelections); // Change-less events don't store mappings (they are always the last event in a branch)\n\n  if (!event.changes) return HistEvent.selection(selections);\n  var mappedChanges = event.changes.map(mapping),\n      before = mapping.mapDesc(event.changes, true);\n  var fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\n\nvar HistoryState = /*#__PURE__*/function () {\n  function HistoryState(done, undone) {\n    var prevTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var prevUserEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n    _classCallCheck(this, HistoryState);\n\n    this.done = done;\n    this.undone = undone;\n    this.prevTime = prevTime;\n    this.prevUserEvent = prevUserEvent;\n  }\n\n  _createClass(HistoryState, [{\n    key: \"isolate\",\n    value: function isolate() {\n      return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n  }, {\n    key: \"addChanges\",\n    value: function addChanges(event, time, userEvent, newGroupDelay, maxLen) {\n      var done = this.done,\n          lastEvent = done[done.length - 1];\n\n      if (lastEvent && lastEvent.changes && time - this.prevTime < newGroupDelay && !lastEvent.selectionsAfter.length && !lastEvent.changes.empty && event.changes && isAdjacent(lastEvent.changes, event.changes)) {\n        done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n      } else {\n        done = updateBranch(done, done.length, maxLen, event);\n      }\n\n      return new HistoryState(done, none, time, userEvent);\n    }\n  }, {\n    key: \"addSelection\",\n    value: function addSelection(selection, time, userEvent, newGroupDelay) {\n      var last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == \"keyboardselection\" && this.prevUserEvent == userEvent && eqSelectionShape(last[last.length - 1], selection)) return this;\n      return new HistoryState(_addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n  }, {\n    key: \"addMapping\",\n    value: function addMapping(mapping) {\n      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(side, state, selection) {\n      var branch = side == 0\n      /* Done */\n      ? this.done : this.undone;\n      if (branch.length == 0) return null;\n      var event = branch[branch.length - 1];\n\n      if (selection && event.selectionsAfter.length) {\n        return state.update({\n          selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n          annotations: fromHistory.of({\n            side: side,\n            rest: popSelection(branch)\n          })\n        });\n      } else if (!event.changes) {\n        return null;\n      } else {\n        var rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n        if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n        return state.update({\n          changes: event.changes,\n          selection: event.startSelection,\n          effects: event.effects,\n          annotations: fromHistory.of({\n            side: side,\n            rest: rest\n          }),\n          filter: false\n        });\n      }\n    }\n  }]);\n\n  return HistoryState;\n}();\n\nHistoryState.empty = new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#history.undo).\n- Mod-y (Mod-Shift-z on macOS): [`redo`](https://codemirror.net/6/docs/ref/#history.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#history.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#history.redoSelection).\n*/\n\nvar historyKeymap = [{\n  key: \"Mod-z\",\n  run: undo,\n  preventDefault: true\n}, {\n  key: \"Mod-y\",\n  mac: \"Mod-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  key: \"Mod-u\",\n  run: undoSelection,\n  preventDefault: true\n}, {\n  key: \"Alt-u\",\n  mac: \"Mod-Shift-u\",\n  run: redoSelection,\n  preventDefault: true\n}];\nexport { history, historyField, historyKeymap, invertedEffects, isolateHistory, redo, redoDepth, redoSelection, undo, undoDepth, undoSelection };","map":{"version":3,"sources":["/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/@codemirror/history/dist/index.js"],"names":["Annotation","Facet","combineConfig","StateField","Transaction","ChangeSet","ChangeDesc","EditorSelection","StateEffect","EditorView","fromHistory","define","isolateHistory","invertedEffects","historyConfig","combine","configs","minDepth","newGroupDelay","Math","max","min","historyField_","create","HistoryState","empty","update","state","tr","config","facet","fromHist","annotation","item","HistEvent","fromTransaction","from","side","other","undone","done","updateBranch","length","addSelection","startState","selection","rest","isolate","addToHistory","changes","addMapping","desc","event","time","userEvent","addChanges","toJSON","value","map","e","fromJSON","json","history","of","domEventHandlers","beforeinput","view","inputType","undo","redo","historyField","cmd","dispatch","historyState","field","pop","undoSelection","redoSelection","depth","histState","branch","undoDepth","redoDepth","effects","mapped","startSelection","selectionsAfter","after","_a","_b","_c","s","none","invert","result","concat","doc","undefined","selections","to","maxLen","newEvent","start","newBranch","slice","push","isAdjacent","a","b","ranges","iterChangedRanges","f","t","_f","_t","i","eqSelectionShape","filter","r","conc","MaxSelectionsPerEvent","lastEvent","sels","eq","setSelAfter","popSelection","last","addMappingToBranch","mapping","mapEvent","extraSelections","mappedChanges","before","mapDesc","fullMapping","composeDesc","mapEffects","prevTime","prevUserEvent","compose","annotations","historyKeymap","key","run","preventDefault","mac"],"mappings":";;;AAAA,SAASA,UAAT,EAAqBC,KAArB,EAA4BC,aAA5B,EAA2CC,UAA3C,EAAuDC,WAAvD,EAAoEC,SAApE,EAA+EC,UAA/E,EAA2FC,eAA3F,EAA4GC,WAA5G,QAA+H,mBAA/H;AACA,SAASC,UAAT,QAA2B,kBAA3B;AAEA,IAAMC,WAAW,GAAGV,UAAU,CAACW,MAAX,EAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,cAAc,GAAGZ,UAAU,CAACW,MAAX,EAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAME,eAAe,GAAGZ,KAAK,CAACU,MAAN,EAAxB;AACA,IAAMG,aAAa,GAAGb,KAAK,CAACU,MAAN,CAAa;AAC/BI,EAAAA,OAD+B,mBACvBC,OADuB,EACd;AACb,WAAOd,aAAa,CAACc,OAAD,EAAU;AAC1BC,MAAAA,QAAQ,EAAE,GADgB;AAE1BC,MAAAA,aAAa,EAAE;AAFW,KAAV,EAGjB;AAAED,MAAAA,QAAQ,EAAEE,IAAI,CAACC,GAAjB;AAAsBF,MAAAA,aAAa,EAAEC,IAAI,CAACE;AAA1C,KAHiB,CAApB;AAIH;AAN8B,CAAb,CAAtB;AAQA,IAAMC,aAAa,GAAGnB,UAAU,CAACQ,MAAX,CAAkB;AACpCY,EAAAA,MADoC,oBAC3B;AACL,WAAOC,YAAY,CAACC,KAApB;AACH,GAHmC;AAIpCC,EAAAA,MAJoC,kBAI7BC,KAJ6B,EAItBC,EAJsB,EAIlB;AACd,QAAIC,MAAM,GAAGD,EAAE,CAACD,KAAH,CAASG,KAAT,CAAehB,aAAf,CAAb;AACA,QAAIiB,QAAQ,GAAGH,EAAE,CAACI,UAAH,CAActB,WAAd,CAAf;;AACA,QAAIqB,QAAJ,EAAc;AACV,UAAIE,IAAI,GAAGC,SAAS,CAACC,eAAV,CAA0BP,EAA1B,CAAX;AAAA,UAA0CQ,IAAI,GAAGL,QAAQ,CAACM,IAA1D;AACA,UAAIC,KAAK,GAAGF,IAAI,IAAI;AAAE;AAAV,QAAuBT,KAAK,CAACY,MAA7B,GAAsCZ,KAAK,CAACa,IAAxD;AACA,UAAIP,IAAJ,EACIK,KAAK,GAAGG,YAAY,CAACH,KAAD,EAAQA,KAAK,CAACI,MAAd,EAAsBb,MAAM,CAACZ,QAA7B,EAAuCgB,IAAvC,CAApB,CADJ,KAGIK,KAAK,GAAGK,aAAY,CAACL,KAAD,EAAQV,EAAE,CAACgB,UAAH,CAAcC,SAAtB,CAApB;AACJ,aAAO,IAAIrB,YAAJ,CAAiBY,IAAI,IAAI;AAAE;AAAV,QAAuBL,QAAQ,CAACe,IAAhC,GAAuCR,KAAxD,EAA+DF,IAAI,IAAI;AAAE;AAAV,QAAuBE,KAAvB,GAA+BP,QAAQ,CAACe,IAAvG,CAAP;AACH;;AACD,QAAIC,OAAO,GAAGnB,EAAE,CAACI,UAAH,CAAcpB,cAAd,CAAd;AACA,QAAImC,OAAO,IAAI,MAAX,IAAqBA,OAAO,IAAI,QAApC,EACIpB,KAAK,GAAGA,KAAK,CAACoB,OAAN,EAAR;AACJ,QAAInB,EAAE,CAACI,UAAH,CAAc5B,WAAW,CAAC4C,YAA1B,MAA4C,KAAhD,EACI,OAAO,CAACpB,EAAE,CAACqB,OAAH,CAAWxB,KAAZ,GAAoBE,KAAK,CAACuB,UAAN,CAAiBtB,EAAE,CAACqB,OAAH,CAAWE,IAA5B,CAApB,GAAwDxB,KAA/D;AACJ,QAAIyB,KAAK,GAAGlB,SAAS,CAACC,eAAV,CAA0BP,EAA1B,CAAZ;AACA,QAAIyB,IAAI,GAAGzB,EAAE,CAACI,UAAH,CAAc5B,WAAW,CAACiD,IAA1B,CAAX;AAAA,QAA4CC,SAAS,GAAG1B,EAAE,CAACI,UAAH,CAAc5B,WAAW,CAACkD,SAA1B,CAAxD;AACA,QAAIF,KAAJ,EACIzB,KAAK,GAAGA,KAAK,CAAC4B,UAAN,CAAiBH,KAAjB,EAAwBC,IAAxB,EAA8BC,SAA9B,EAAyCzB,MAAM,CAACX,aAAhD,EAA+DW,MAAM,CAACZ,QAAtE,CAAR,CADJ,KAEK,IAAIW,EAAE,CAACiB,SAAP,EACDlB,KAAK,GAAGA,KAAK,CAACgB,YAAN,CAAmBf,EAAE,CAACgB,UAAH,CAAcC,SAAjC,EAA4CQ,IAA5C,EAAkDC,SAAlD,EAA6DzB,MAAM,CAACX,aAApE,CAAR;AACJ,QAAI6B,OAAO,IAAI,MAAX,IAAqBA,OAAO,IAAI,OAApC,EACIpB,KAAK,GAAGA,KAAK,CAACoB,OAAN,EAAR;AACJ,WAAOpB,KAAP;AACH,GA9BmC;AA+BpC6B,EAAAA,MA/BoC,kBA+B7BC,KA/B6B,EA+BtB;AACV,WAAO;AAAEjB,MAAAA,IAAI,EAAEiB,KAAK,CAACjB,IAAN,CAAWkB,GAAX,CAAe,UAAAC,CAAC;AAAA,eAAIA,CAAC,CAACH,MAAF,EAAJ;AAAA,OAAhB,CAAR;AAAyCjB,MAAAA,MAAM,EAAEkB,KAAK,CAAClB,MAAN,CAAamB,GAAb,CAAiB,UAAAC,CAAC;AAAA,eAAIA,CAAC,CAACH,MAAF,EAAJ;AAAA,OAAlB;AAAjD,KAAP;AACH,GAjCmC;AAkCpCI,EAAAA,QAlCoC,oBAkC3BC,IAlC2B,EAkCrB;AACX,WAAO,IAAIrC,YAAJ,CAAiBqC,IAAI,CAACrB,IAAL,CAAUkB,GAAV,CAAcxB,SAAS,CAAC0B,QAAxB,CAAjB,EAAoDC,IAAI,CAACtB,MAAL,CAAYmB,GAAZ,CAAgBxB,SAAS,CAAC0B,QAA1B,CAApD,CAAP;AACH;AApCmC,CAAlB,CAAtB;AAsCA;AACA;AACA;;AACA,SAASE,OAAT,GAA8B;AAAA,MAAbjC,MAAa,uEAAJ,EAAI;AAC1B,SAAO,CACHP,aADG,EAEHR,aAAa,CAACiD,EAAd,CAAiBlC,MAAjB,CAFG,EAGHpB,UAAU,CAACuD,gBAAX,CAA4B;AACxBC,IAAAA,WADwB,uBACZN,CADY,EACTO,IADS,EACH;AACjB,UAAIP,CAAC,CAACQ,SAAF,IAAe,aAAnB,EACI,OAAOC,IAAI,CAACF,IAAD,CAAX;AACJ,UAAIP,CAAC,CAACQ,SAAF,IAAe,aAAnB,EACI,OAAOE,IAAI,CAACH,IAAD,CAAX;AACJ,aAAO,KAAP;AACH;AAPuB,GAA5B,CAHG,CAAP;AAaH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMI,YAAY,GAAGhD,aAArB;;AACA,SAASiD,GAAT,CAAalC,IAAb,EAAmBQ,SAAnB,EAA8B;AAC1B,SAAO,gBAA+B;AAAA,QAAnBlB,KAAmB,QAAnBA,KAAmB;AAAA,QAAZ6C,QAAY,QAAZA,QAAY;AAClC,QAAIC,YAAY,GAAG9C,KAAK,CAAC+C,KAAN,CAAYpD,aAAZ,EAA2B,KAA3B,CAAnB;AACA,QAAI,CAACmD,YAAL,EACI,OAAO,KAAP;AACJ,QAAI7C,EAAE,GAAG6C,YAAY,CAACE,GAAb,CAAiBtC,IAAjB,EAAuBV,KAAvB,EAA8BkB,SAA9B,CAAT;AACA,QAAI,CAACjB,EAAL,EACI,OAAO,KAAP;AACJ4C,IAAAA,QAAQ,CAAC5C,EAAD,CAAR;AACA,WAAO,IAAP;AACH,GATD;AAUH;AACD;AACA;AACA;AACA;;;AACA,IAAMwC,IAAI,GAAGG,GAAG,CAAC;AAAE;AAAH,EAAe,KAAf,CAAhB;AACA;AACA;AACA;AACA;;AACA,IAAMF,IAAI,GAAGE,GAAG,CAAC;AAAE;AAAH,EAAiB,KAAjB,CAAhB;AACA;AACA;AACA;;AACA,IAAMK,aAAa,GAAGL,GAAG,CAAC;AAAE;AAAH,EAAe,IAAf,CAAzB;AACA;AACA;AACA;;AACA,IAAMM,aAAa,GAAGN,GAAG,CAAC;AAAE;AAAH,EAAiB,IAAjB,CAAzB;;AACA,SAASO,KAAT,CAAezC,IAAf,EAAqB;AACjB,SAAO,UAAUV,KAAV,EAAiB;AACpB,QAAIoD,SAAS,GAAGpD,KAAK,CAAC+C,KAAN,CAAYpD,aAAZ,EAA2B,KAA3B,CAAhB;AACA,QAAI,CAACyD,SAAL,EACI,OAAO,CAAP;AACJ,QAAIC,MAAM,GAAG3C,IAAI,IAAI;AAAE;AAAV,MAAuB0C,SAAS,CAACvC,IAAjC,GAAwCuC,SAAS,CAACxC,MAA/D;AACA,WAAOyC,MAAM,CAACtC,MAAP,IAAiBsC,MAAM,CAACtC,MAAP,IAAiB,CAACsC,MAAM,CAAC,CAAD,CAAN,CAAU/B,OAA5B,GAAsC,CAAtC,GAA0C,CAA3D,CAAP;AACH,GAND;AAOH;AACD;AACA;AACA;;;AACA,IAAMgC,SAAS,GAAGH,KAAK,CAAC;AAAE;AAAH,CAAvB;AACA;AACA;AACA;;AACA,IAAMI,SAAS,GAAGJ,KAAK,CAAC;AAAE;AAAH,CAAvB,C,CACA;AACA;;IACM5C,S;AACF,sBACA;AACA;AACA;AACA;AACA;AACAe,EAAAA,OANA,EAOA;AACAkC,EAAAA,OARA,EAQSC,MART,EASA;AACAC,EAAAA,cAVA,EAWA;AACA;AACAC,EAAAA,eAbA,EAaiB;AAAA;;AACb,SAAKrC,OAAL,GAAeA,OAAf;AACA,SAAKkC,OAAL,GAAeA,OAAf;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACH;;;;WACD,qBAAYC,KAAZ,EAAmB;AACf,aAAO,IAAIrD,SAAJ,CAAc,KAAKe,OAAnB,EAA4B,KAAKkC,OAAjC,EAA0C,KAAKC,MAA/C,EAAuD,KAAKC,cAA5D,EAA4EE,KAA5E,CAAP;AACH;;;WACD,kBAAS;AACL,UAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ;;AACA,aAAO;AACHzC,QAAAA,OAAO,EAAE,CAACuC,EAAE,GAAG,KAAKvC,OAAX,MAAwB,IAAxB,IAAgCuC,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAAChC,MAAH,EAD/D;AAEH4B,QAAAA,MAAM,EAAE,CAACK,EAAE,GAAG,KAAKL,MAAX,MAAuB,IAAvB,IAA+BK,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAACjC,MAAH,EAF7D;AAGH6B,QAAAA,cAAc,EAAE,CAACK,EAAE,GAAG,KAAKL,cAAX,MAA+B,IAA/B,IAAuCK,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAAClC,MAAH,EAH7E;AAIH8B,QAAAA,eAAe,EAAE,KAAKA,eAAL,CAAqB5B,GAArB,CAAyB,UAAAiC,CAAC;AAAA,iBAAIA,CAAC,CAACnC,MAAF,EAAJ;AAAA,SAA1B;AAJd,OAAP;AAMH;;;WACD,kBAAgBK,IAAhB,EAAsB;AAClB,aAAO,IAAI3B,SAAJ,CAAc2B,IAAI,CAACZ,OAAL,IAAgB5C,SAAS,CAACuD,QAAV,CAAmBC,IAAI,CAACZ,OAAxB,CAA9B,EAAgE,EAAhE,EAAoEY,IAAI,CAACuB,MAAL,IAAe9E,UAAU,CAACsD,QAAX,CAAoBC,IAAI,CAACuB,MAAzB,CAAnF,EAAqHvB,IAAI,CAACwB,cAAL,IAAuB9E,eAAe,CAACqD,QAAhB,CAAyBC,IAAI,CAACwB,cAA9B,CAA5I,EAA2LxB,IAAI,CAACyB,eAAL,CAAqB5B,GAArB,CAAyBnD,eAAe,CAACqD,QAAzC,CAA3L,CAAP;AACH,K,CACD;AACA;AACA;;;;WACA,yBAAuBhC,EAAvB,EAA2B;AACvB,UAAIuD,OAAO,GAAGS,IAAd;;AADuB,iDAEJhE,EAAE,CAACgB,UAAH,CAAcd,KAAd,CAAoBjB,eAApB,CAFI;AAAA;;AAAA;AAEvB,4DAAyD;AAAA,cAAhDgF,MAAgD;AACrD,cAAIC,MAAM,GAAGD,MAAM,CAACjE,EAAD,CAAnB;AACA,cAAIkE,MAAM,CAACpD,MAAX,EACIyC,OAAO,GAAGA,OAAO,CAACY,MAAR,CAAeD,MAAf,CAAV;AACP;AANsB;AAAA;AAAA;AAAA;AAAA;;AAOvB,UAAI,CAACX,OAAO,CAACzC,MAAT,IAAmBd,EAAE,CAACqB,OAAH,CAAWxB,KAAlC,EACI,OAAO,IAAP;AACJ,aAAO,IAAIS,SAAJ,CAAcN,EAAE,CAACqB,OAAH,CAAW4C,MAAX,CAAkBjE,EAAE,CAACgB,UAAH,CAAcoD,GAAhC,CAAd,EAAoDb,OAApD,EAA6Dc,SAA7D,EAAwErE,EAAE,CAACgB,UAAH,CAAcC,SAAtF,EAAiG+C,IAAjG,CAAP;AACH;;;WACD,mBAAiBM,UAAjB,EAA6B;AACzB,aAAO,IAAIhE,SAAJ,CAAc+D,SAAd,EAAyBL,IAAzB,EAA+BK,SAA/B,EAA0CA,SAA1C,EAAqDC,UAArD,CAAP;AACH;;;;;;AAEL,SAASzD,YAAT,CAAsBuC,MAAtB,EAA8BmB,EAA9B,EAAkCC,MAAlC,EAA0CC,QAA1C,EAAoD;AAChD,MAAIC,KAAK,GAAGH,EAAE,GAAG,CAAL,GAASC,MAAM,GAAG,EAAlB,GAAuBD,EAAE,GAAGC,MAAL,GAAc,CAArC,GAAyC,CAArD;AACA,MAAIG,SAAS,GAAGvB,MAAM,CAACwB,KAAP,CAAaF,KAAb,EAAoBH,EAApB,CAAhB;AACAI,EAAAA,SAAS,CAACE,IAAV,CAAeJ,QAAf;AACA,SAAOE,SAAP;AACH;;AACD,SAASG,UAAT,CAAoBC,CAApB,EAAuBC,CAAvB,EAA0B;AACtB,MAAIC,MAAM,GAAG,EAAb;AAAA,MAAiBH,UAAU,GAAG,KAA9B;AACAC,EAAAA,CAAC,CAACG,iBAAF,CAAoB,UAACC,CAAD,EAAIC,CAAJ;AAAA,WAAUH,MAAM,CAACJ,IAAP,CAAYM,CAAZ,EAAeC,CAAf,CAAV;AAAA,GAApB;AACAJ,EAAAA,CAAC,CAACE,iBAAF,CAAoB,UAACG,EAAD,EAAKC,EAAL,EAASH,CAAT,EAAYC,CAAZ,EAAkB;AAClC,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,MAAM,CAACnE,MAA3B,GAAoC;AAChC,UAAIN,IAAI,GAAGyE,MAAM,CAACM,CAAC,EAAF,CAAjB;AAAA,UAAwBhB,EAAE,GAAGU,MAAM,CAACM,CAAC,EAAF,CAAnC;AACA,UAAIH,CAAC,IAAI5E,IAAL,IAAa2E,CAAC,IAAIZ,EAAtB,EACIO,UAAU,GAAG,IAAb;AACP;AACJ,GAND;AAOA,SAAOA,UAAP;AACH;;AACD,SAASU,gBAAT,CAA0BT,CAA1B,EAA6BC,CAA7B,EAAgC;AAC5B,SAAOD,CAAC,CAACE,MAAF,CAASnE,MAAT,IAAmBkE,CAAC,CAACC,MAAF,CAASnE,MAA5B,IACHiE,CAAC,CAACE,MAAF,CAASQ,MAAT,CAAgB,UAACC,CAAD,EAAIH,CAAJ;AAAA,WAAUG,CAAC,CAAC7F,KAAF,IAAWmF,CAAC,CAACC,MAAF,CAASM,CAAT,EAAY1F,KAAjC;AAAA,GAAhB,EAAwDiB,MAAxD,KAAmE,CADvE;AAEH;;AACD,SAAS6E,IAAT,CAAcZ,CAAd,EAAiBC,CAAjB,EAAoB;AAChB,SAAO,CAACD,CAAC,CAACjE,MAAH,GAAYkE,CAAZ,GAAgB,CAACA,CAAC,CAAClE,MAAH,GAAYiE,CAAZ,GAAgBA,CAAC,CAACZ,MAAF,CAASa,CAAT,CAAvC;AACH;;AACD,IAAMhB,IAAI,GAAG,EAAb;AACA,IAAM4B,qBAAqB,GAAG,GAA9B;;AACA,SAAS7E,aAAT,CAAsBqC,MAAtB,EAA8BnC,SAA9B,EAAyC;AACrC,MAAI,CAACmC,MAAM,CAACtC,MAAZ,EAAoB;AAChB,WAAO,CAACR,SAAS,CAACW,SAAV,CAAoB,CAACA,SAAD,CAApB,CAAD,CAAP;AACH,GAFD,MAGK;AACD,QAAI4E,SAAS,GAAGzC,MAAM,CAACA,MAAM,CAACtC,MAAP,GAAgB,CAAjB,CAAtB;AACA,QAAIgF,IAAI,GAAGD,SAAS,CAACnC,eAAV,CAA0BkB,KAA1B,CAAgCrF,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYqG,SAAS,CAACnC,eAAV,CAA0B5C,MAA1B,GAAmC8E,qBAA/C,CAAhC,CAAX;AACA,QAAIE,IAAI,CAAChF,MAAL,IAAegF,IAAI,CAACA,IAAI,CAAChF,MAAL,GAAc,CAAf,CAAJ,CAAsBiF,EAAtB,CAAyB9E,SAAzB,CAAnB,EACI,OAAOmC,MAAP;AACJ0C,IAAAA,IAAI,CAACjB,IAAL,CAAU5D,SAAV;AACA,WAAOJ,YAAY,CAACuC,MAAD,EAASA,MAAM,CAACtC,MAAP,GAAgB,CAAzB,EAA4B,GAA5B,EAAiC+E,SAAS,CAACG,WAAV,CAAsBF,IAAtB,CAAjC,CAAnB;AACH;AACJ,C,CACD;;;AACA,SAASG,YAAT,CAAsB7C,MAAtB,EAA8B;AAC1B,MAAI8C,IAAI,GAAG9C,MAAM,CAACA,MAAM,CAACtC,MAAP,GAAgB,CAAjB,CAAjB;AACA,MAAI6D,SAAS,GAAGvB,MAAM,CAACwB,KAAP,EAAhB;AACAD,EAAAA,SAAS,CAACvB,MAAM,CAACtC,MAAP,GAAgB,CAAjB,CAAT,GAA+BoF,IAAI,CAACF,WAAL,CAAiBE,IAAI,CAACxC,eAAL,CAAqBkB,KAArB,CAA2B,CAA3B,EAA8BsB,IAAI,CAACxC,eAAL,CAAqB5C,MAArB,GAA8B,CAA5D,CAAjB,CAA/B;AACA,SAAO6D,SAAP;AACH,C,CACD;AACA;AACA;;;AACA,SAASwB,kBAAT,CAA4B/C,MAA5B,EAAoCgD,OAApC,EAA6C;AACzC,MAAI,CAAChD,MAAM,CAACtC,MAAZ,EACI,OAAOsC,MAAP;AACJ,MAAItC,MAAM,GAAGsC,MAAM,CAACtC,MAApB;AAAA,MAA4BwD,UAAU,GAAGN,IAAzC;;AACA,SAAOlD,MAAP,EAAe;AACX,QAAIU,KAAK,GAAG6E,QAAQ,CAACjD,MAAM,CAACtC,MAAM,GAAG,CAAV,CAAP,EAAqBsF,OAArB,EAA8B9B,UAA9B,CAApB;;AACA,QAAI9C,KAAK,CAACH,OAAN,IAAiB,CAACG,KAAK,CAACH,OAAN,CAAcxB,KAAhC,IAAyC2B,KAAK,CAAC+B,OAAN,CAAczC,MAA3D,EAAmE;AAAE;AACjE,UAAIoD,MAAM,GAAGd,MAAM,CAACwB,KAAP,CAAa,CAAb,EAAgB9D,MAAhB,CAAb;AACAoD,MAAAA,MAAM,CAACpD,MAAM,GAAG,CAAV,CAAN,GAAqBU,KAArB;AACA,aAAO0C,MAAP;AACH,KAJD,MAKK;AAAE;AACHkC,MAAAA,OAAO,GAAG5E,KAAK,CAACgC,MAAhB;AACA1C,MAAAA,MAAM;AACNwD,MAAAA,UAAU,GAAG9C,KAAK,CAACkC,eAAnB;AACH;AACJ;;AACD,SAAOY,UAAU,CAACxD,MAAX,GAAoB,CAACR,SAAS,CAACW,SAAV,CAAoBqD,UAApB,CAAD,CAApB,GAAwDN,IAA/D;AACH;;AACD,SAASqC,QAAT,CAAkB7E,KAAlB,EAAyB4E,OAAzB,EAAkCE,eAAlC,EAAmD;AAC/C,MAAIhC,UAAU,GAAGqB,IAAI,CAACnE,KAAK,CAACkC,eAAN,CAAsB5C,MAAtB,GAA+BU,KAAK,CAACkC,eAAN,CAAsB5B,GAAtB,CAA0B,UAAAiC,CAAC;AAAA,WAAIA,CAAC,CAACjC,GAAF,CAAMsE,OAAN,CAAJ;AAAA,GAA3B,CAA/B,GAAgFpC,IAAjF,EAAuFsC,eAAvF,CAArB,CAD+C,CAE/C;;AACA,MAAI,CAAC9E,KAAK,CAACH,OAAX,EACI,OAAOf,SAAS,CAACW,SAAV,CAAoBqD,UAApB,CAAP;AACJ,MAAIiC,aAAa,GAAG/E,KAAK,CAACH,OAAN,CAAcS,GAAd,CAAkBsE,OAAlB,CAApB;AAAA,MAAgDI,MAAM,GAAGJ,OAAO,CAACK,OAAR,CAAgBjF,KAAK,CAACH,OAAtB,EAA+B,IAA/B,CAAzD;AACA,MAAIqF,WAAW,GAAGlF,KAAK,CAACgC,MAAN,GAAehC,KAAK,CAACgC,MAAN,CAAamD,WAAb,CAAyBH,MAAzB,CAAf,GAAkDA,MAApE;AACA,SAAO,IAAIlG,SAAJ,CAAciG,aAAd,EAA6B3H,WAAW,CAACgI,UAAZ,CAAuBpF,KAAK,CAAC+B,OAA7B,EAAsC6C,OAAtC,CAA7B,EAA6EM,WAA7E,EAA0FlF,KAAK,CAACiC,cAAN,CAAqB3B,GAArB,CAAyB0E,MAAzB,CAA1F,EAA4HlC,UAA5H,CAAP;AACH;;IACK1E,Y;AACF,wBAAYgB,IAAZ,EAAkBD,MAAlB,EAAmE;AAAA,QAAzCkG,QAAyC,uEAA9B,CAA8B;AAAA,QAA3BC,aAA2B,uEAAXzC,SAAW;;AAAA;;AAC/D,SAAKzD,IAAL,GAAYA,IAAZ;AACA,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKkG,QAAL,GAAgBA,QAAhB;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACH;;;;WACD,mBAAU;AACN,aAAO,KAAKD,QAAL,GAAgB,IAAIjH,YAAJ,CAAiB,KAAKgB,IAAtB,EAA4B,KAAKD,MAAjC,CAAhB,GAA2D,IAAlE;AACH;;;WACD,oBAAWa,KAAX,EAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCpC,aAAnC,EAAkDkF,MAAlD,EAA0D;AACtD,UAAI5D,IAAI,GAAG,KAAKA,IAAhB;AAAA,UAAsBiF,SAAS,GAAGjF,IAAI,CAACA,IAAI,CAACE,MAAL,GAAc,CAAf,CAAtC;;AACA,UAAI+E,SAAS,IAAIA,SAAS,CAACxE,OAAvB,IACAI,IAAI,GAAG,KAAKoF,QAAZ,GAAuBvH,aADvB,IAEA,CAACuG,SAAS,CAACnC,eAAV,CAA0B5C,MAF3B,IAGA,CAAC+E,SAAS,CAACxE,OAAV,CAAkBxB,KAHnB,IAG4B2B,KAAK,CAACH,OAHlC,IAIAyD,UAAU,CAACe,SAAS,CAACxE,OAAX,EAAoBG,KAAK,CAACH,OAA1B,CAJd,EAIkD;AAC9CT,QAAAA,IAAI,GAAGC,YAAY,CAACD,IAAD,EAAOA,IAAI,CAACE,MAAL,GAAc,CAArB,EAAwB0D,MAAxB,EAAgC,IAAIlE,SAAJ,CAAckB,KAAK,CAACH,OAAN,CAAc0F,OAAd,CAAsBlB,SAAS,CAACxE,OAAhC,CAAd,EAAwDsE,IAAI,CAACnE,KAAK,CAAC+B,OAAP,EAAgBsC,SAAS,CAACtC,OAA1B,CAA5D,EAAgGsC,SAAS,CAACrC,MAA1G,EAAkHqC,SAAS,CAACpC,cAA5H,EAA4IO,IAA5I,CAAhC,CAAnB;AACH,OAND,MAOK;AACDpD,QAAAA,IAAI,GAAGC,YAAY,CAACD,IAAD,EAAOA,IAAI,CAACE,MAAZ,EAAoB0D,MAApB,EAA4BhD,KAA5B,CAAnB;AACH;;AACD,aAAO,IAAI5B,YAAJ,CAAiBgB,IAAjB,EAAuBoD,IAAvB,EAA6BvC,IAA7B,EAAmCC,SAAnC,CAAP;AACH;;;WACD,sBAAaT,SAAb,EAAwBQ,IAAxB,EAA8BC,SAA9B,EAAyCpC,aAAzC,EAAwD;AACpD,UAAI4G,IAAI,GAAG,KAAKtF,IAAL,CAAUE,MAAV,GAAmB,KAAKF,IAAL,CAAU,KAAKA,IAAL,CAAUE,MAAV,GAAmB,CAA7B,EAAgC4C,eAAnD,GAAqEM,IAAhF;AACA,UAAIkC,IAAI,CAACpF,MAAL,GAAc,CAAd,IACAW,IAAI,GAAG,KAAKoF,QAAZ,GAAuBvH,aADvB,IAEAoC,SAAS,IAAI,mBAFb,IAEoC,KAAKoF,aAAL,IAAsBpF,SAF1D,IAGA8D,gBAAgB,CAACU,IAAI,CAACA,IAAI,CAACpF,MAAL,GAAc,CAAf,CAAL,EAAwBG,SAAxB,CAHpB,EAII,OAAO,IAAP;AACJ,aAAO,IAAIrB,YAAJ,CAAiBmB,aAAY,CAAC,KAAKH,IAAN,EAAYK,SAAZ,CAA7B,EAAqD,KAAKN,MAA1D,EAAkEc,IAAlE,EAAwEC,SAAxE,CAAP;AACH;;;WACD,oBAAW0E,OAAX,EAAoB;AAChB,aAAO,IAAIxG,YAAJ,CAAiBuG,kBAAkB,CAAC,KAAKvF,IAAN,EAAYwF,OAAZ,CAAnC,EAAyDD,kBAAkB,CAAC,KAAKxF,MAAN,EAAcyF,OAAd,CAA3E,EAAmG,KAAKS,QAAxG,EAAkH,KAAKC,aAAvH,CAAP;AACH;;;WACD,aAAIrG,IAAJ,EAAUV,KAAV,EAAiBkB,SAAjB,EAA4B;AACxB,UAAImC,MAAM,GAAG3C,IAAI,IAAI;AAAE;AAAV,QAAuB,KAAKG,IAA5B,GAAmC,KAAKD,MAArD;AACA,UAAIyC,MAAM,CAACtC,MAAP,IAAiB,CAArB,EACI,OAAO,IAAP;AACJ,UAAIU,KAAK,GAAG4B,MAAM,CAACA,MAAM,CAACtC,MAAP,GAAgB,CAAjB,CAAlB;;AACA,UAAIG,SAAS,IAAIO,KAAK,CAACkC,eAAN,CAAsB5C,MAAvC,EAA+C;AAC3C,eAAOf,KAAK,CAACD,MAAN,CAAa;AAChBmB,UAAAA,SAAS,EAAEO,KAAK,CAACkC,eAAN,CAAsBlC,KAAK,CAACkC,eAAN,CAAsB5C,MAAtB,GAA+B,CAArD,CADK;AAEhBkG,UAAAA,WAAW,EAAElI,WAAW,CAACqD,EAAZ,CAAe;AAAE1B,YAAAA,IAAI,EAAJA,IAAF;AAAQS,YAAAA,IAAI,EAAE+E,YAAY,CAAC7C,MAAD;AAA1B,WAAf;AAFG,SAAb,CAAP;AAIH,OALD,MAMK,IAAI,CAAC5B,KAAK,CAACH,OAAX,EAAoB;AACrB,eAAO,IAAP;AACH,OAFI,MAGA;AACD,YAAIH,IAAI,GAAGkC,MAAM,CAACtC,MAAP,IAAiB,CAAjB,GAAqBkD,IAArB,GAA4BZ,MAAM,CAACwB,KAAP,CAAa,CAAb,EAAgBxB,MAAM,CAACtC,MAAP,GAAgB,CAAhC,CAAvC;AACA,YAAIU,KAAK,CAACgC,MAAV,EACItC,IAAI,GAAGiF,kBAAkB,CAACjF,IAAD,EAAOM,KAAK,CAACgC,MAAb,CAAzB;AACJ,eAAOzD,KAAK,CAACD,MAAN,CAAa;AAChBuB,UAAAA,OAAO,EAAEG,KAAK,CAACH,OADC;AAEhBJ,UAAAA,SAAS,EAAEO,KAAK,CAACiC,cAFD;AAGhBF,UAAAA,OAAO,EAAE/B,KAAK,CAAC+B,OAHC;AAIhByD,UAAAA,WAAW,EAAElI,WAAW,CAACqD,EAAZ,CAAe;AAAE1B,YAAAA,IAAI,EAAJA,IAAF;AAAQS,YAAAA,IAAI,EAAJA;AAAR,WAAf,CAJG;AAKhBuE,UAAAA,MAAM,EAAE;AALQ,SAAb,CAAP;AAOH;AACJ;;;;;;AAEL7F,YAAY,CAACC,KAAb,GAAqB,IAAID,YAAJ,CAAiBoE,IAAjB,EAAuBA,IAAvB,CAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMiD,aAAa,GAAG,CAClB;AAAEC,EAAAA,GAAG,EAAE,OAAP;AAAgBC,EAAAA,GAAG,EAAE3E,IAArB;AAA2B4E,EAAAA,cAAc,EAAE;AAA3C,CADkB,EAElB;AAAEF,EAAAA,GAAG,EAAE,OAAP;AAAgBG,EAAAA,GAAG,EAAE,aAArB;AAAoCF,EAAAA,GAAG,EAAE1E,IAAzC;AAA+C2E,EAAAA,cAAc,EAAE;AAA/D,CAFkB,EAGlB;AAAEF,EAAAA,GAAG,EAAE,OAAP;AAAgBC,EAAAA,GAAG,EAAEnE,aAArB;AAAoCoE,EAAAA,cAAc,EAAE;AAApD,CAHkB,EAIlB;AAAEF,EAAAA,GAAG,EAAE,OAAP;AAAgBG,EAAAA,GAAG,EAAE,aAArB;AAAoCF,EAAAA,GAAG,EAAElE,aAAzC;AAAwDmE,EAAAA,cAAc,EAAE;AAAxE,CAJkB,CAAtB;AAOA,SAASlF,OAAT,EAAkBQ,YAAlB,EAAgCuE,aAAhC,EAA+ChI,eAA/C,EAAgED,cAAhE,EAAgFyD,IAAhF,EAAsFa,SAAtF,EAAiGL,aAAjG,EAAgHT,IAAhH,EAAsHa,SAAtH,EAAiIL,aAAjI","sourcesContent":["import { Annotation, Facet, combineConfig, StateField, Transaction, ChangeSet, ChangeDesc, EditorSelection, StateEffect } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\n\nconst fromHistory = Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\nconst isolateHistory = Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\nconst invertedEffects = Facet.define();\nconst historyConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            minDepth: 100,\n            newGroupDelay: 500\n        }, { minDepth: Math.max, newGroupDelay: Math.min });\n    }\n});\nconst historyField_ = StateField.define({\n    create() {\n        return HistoryState.empty;\n    },\n    update(state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr), from = fromHist.side;\n            let other = from == 0 /* Done */ ? state.undone : state.done;\n            if (item)\n                other = updateBranch(other, other.length, config.minDepth, item);\n            else\n                other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* Done */ ? fromHist.rest : other, from == 0 /* Done */ ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\")\n            state = state.isolate();\n        if (tr.annotation(Transaction.addToHistory) === false)\n            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);\n        if (event)\n            state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);\n        else if (tr.selection)\n            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\")\n            state = state.isolate();\n        return state;\n    },\n    toJSON(value) {\n        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };\n    },\n    fromJSON(json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/\nfunction history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        EditorView.domEventHandlers({\n            beforeinput(e, view) {\n                if (e.inputType == \"historyUndo\")\n                    return undo(view);\n                if (e.inputType == \"historyRedo\")\n                    return redo(view);\n                return false;\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\nconst historyField = historyField_;\nfunction cmd(side, selection) {\n    return function ({ state, dispatch }) {\n        let historyState = state.field(historyField_, false);\n        if (!historyState)\n            return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr)\n            return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\nconst undo = cmd(0 /* Done */, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\nconst redo = cmd(1 /* Undone */, false);\n/**\nUndo a selection change.\n*/\nconst undoSelection = cmd(0 /* Done */, true);\n/**\nRedo a selection change.\n*/\nconst redoSelection = cmd(1 /* Undone */, true);\nfunction depth(side) {\n    return function (state) {\n        let histState = state.field(historyField_, false);\n        if (!histState)\n            return 0;\n        let branch = side == 0 /* Done */ ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\nconst undoDepth = depth(0 /* Done */);\n/**\nThe amount of redoable change events available in a given state.\n*/\nconst redoDepth = depth(1 /* Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(\n    // The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, \n    // The effects associated with this event\n    effects, mapped, \n    // The selection before this event\n    startSelection, \n    // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter) {\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)) {\n            let result = invert(tr);\n            if (result.length)\n                effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty)\n            return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t) => ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t) => {\n        for (let i = 0; i < ranges.length;) {\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to)\n                isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length &&\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [HistEvent.selection([selection])];\n    }\n    else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection))\n            return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length)\n        return branch;\n    let length = branch.length, selections = none;\n    while (length) {\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        }\n        else { // Drop this event, since there's no changes or effects left\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes)\n        return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, newGroupDelay, maxLen) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes &&\n            time - this.prevTime < newGroupDelay &&\n            !lastEvent.selectionsAfter.length &&\n            !lastEvent.changes.empty && event.changes &&\n            isAdjacent(lastEvent.changes, event.changes)) {\n            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        }\n        else {\n            done = updateBranch(done, done.length, maxLen, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 &&\n            time - this.prevTime < newGroupDelay &&\n            userEvent == \"keyboardselection\" && this.prevUserEvent == userEvent &&\n            eqSelectionShape(last[last.length - 1], selection))\n            return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, selection) {\n        let branch = side == 0 /* Done */ ? this.done : this.undone;\n        if (branch.length == 0)\n            return null;\n        let event = branch[branch.length - 1];\n        if (selection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({ side, rest: popSelection(branch) })\n            });\n        }\n        else if (!event.changes) {\n            return null;\n        }\n        else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped)\n                rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({ side, rest }),\n                filter: false\n            });\n        }\n    }\n}\nHistoryState.empty = new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#history.undo).\n- Mod-y (Mod-Shift-z on macOS): [`redo`](https://codemirror.net/6/docs/ref/#history.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#history.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#history.redoSelection).\n*/\nconst historyKeymap = [\n    { key: \"Mod-z\", run: undo, preventDefault: true },\n    { key: \"Mod-y\", mac: \"Mod-Shift-z\", run: redo, preventDefault: true },\n    { key: \"Mod-u\", run: undoSelection, preventDefault: true },\n    { key: \"Alt-u\", mac: \"Mod-Shift-u\", run: redoSelection, preventDefault: true }\n];\n\nexport { history, historyField, historyKeymap, invertedEffects, isolateHistory, redo, redoDepth, redoSelection, undo, undoDepth, undoSelection };\n"]},"metadata":{},"sourceType":"module"}