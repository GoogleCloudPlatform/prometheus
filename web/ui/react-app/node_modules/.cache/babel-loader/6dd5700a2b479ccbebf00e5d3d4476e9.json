{"ast":null,"code":"import _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n/// The default maximum length of a `TreeBuffer` node.\nvar DefaultBufferLength = 1024;\nvar nextPropID = 0;\nvar CachedNode = new WeakMap(); /// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\n\nvar NodeProp = /*#__PURE__*/function () {\n  /// Create a new node prop type. You can optionally pass a\n  /// `deserialize` function.\n  function NodeProp() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        deserialize = _ref.deserialize;\n\n    _classCallCheck(this, NodeProp);\n\n    this.id = nextPropID++;\n\n    this.deserialize = deserialize || function () {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    };\n  } /// Create a string-valued node prop whose deserialize function is\n  /// the identity function.\n\n\n  _createClass(NodeProp, [{\n    key: \"set\",\n    value: /// Store a value for this prop in the given object. This can be\n    /// useful when building up a prop object to pass to the\n    /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n    /// argument.\n    function set(propObj, value) {\n      propObj[this.id] = value;\n      return propObj;\n    } /// This is meant to be used with\n    /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n    /// values for each node type in the set. Takes a [match\n    /// object](#tree.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n\n  }, {\n    key: \"add\",\n    value: function add(match) {\n      var _this = this;\n\n      if (typeof match != \"function\") match = NodeType.match(match);\n      return function (type) {\n        var result = match(type);\n        return result === undefined ? null : [_this, result];\n      };\n    }\n  }], [{\n    key: \"string\",\n    value: function string() {\n      return new NodeProp({\n        deserialize: function deserialize(str) {\n          return str;\n        }\n      });\n    } /// Create a number-valued node prop whose deserialize function is\n    /// just `Number`.\n\n  }, {\n    key: \"number\",\n    value: function number() {\n      return new NodeProp({\n        deserialize: Number\n      });\n    } /// Creates a boolean-valued node prop whose deserialize function\n    /// returns true for any input.\n\n  }, {\n    key: \"flag\",\n    value: function flag() {\n      return new NodeProp({\n        deserialize: function deserialize() {\n          return true;\n        }\n      });\n    }\n  }]);\n\n  return NodeProp;\n}(); /// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\n\n\nNodeProp.closedBy = new NodeProp({\n  deserialize: function deserialize(str) {\n    return str.split(\" \");\n  }\n}); /// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\n\nNodeProp.openedBy = new NodeProp({\n  deserialize: function deserialize(str) {\n    return str.split(\" \");\n  }\n}); /// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\n\nNodeProp.group = new NodeProp({\n  deserialize: function deserialize(str) {\n    return str.split(\" \");\n  }\n});\nvar noProps = Object.create(null); /// Each node in a syntax tree has a node type associated with it.\n\nvar NodeType = /*#__PURE__*/function () {\n  /// @internal\n  function NodeType( /// The name of the node type. Not necessarily unique, but if the\n  /// grammar was written properly, different node types with the\n  /// same name within a node set should play the same semantic\n  /// role.\n  name, /// @internal\n  props, /// The id of this node in its set. Corresponds to the term ids\n  /// used in the parser.\n  id) {\n    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, NodeType);\n\n    this.name = name;\n    this.props = props;\n    this.id = id;\n    this.flags = flags;\n  }\n\n  _createClass(NodeType, [{\n    key: \"prop\",\n    value: /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    function prop(_prop) {\n      return this.props[_prop.id];\n    } /// True when this is the top node of a grammar.\n\n  }, {\n    key: \"isTop\",\n    get: function get() {\n      return (this.flags & 1\n      /* Top */\n      ) > 0;\n    } /// True when this node is produced by a skip rule.\n\n  }, {\n    key: \"isSkipped\",\n    get: function get() {\n      return (this.flags & 2\n      /* Skipped */\n      ) > 0;\n    } /// Indicates whether this is an error node.\n\n  }, {\n    key: \"isError\",\n    get: function get() {\n      return (this.flags & 4\n      /* Error */\n      ) > 0;\n    } /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n\n  }, {\n    key: \"isAnonymous\",\n    get: function get() {\n      return (this.flags & 8\n      /* Anonymous */\n      ) > 0;\n    } /// Returns true when this node's name or one of its\n    /// [groups](#tree.NodeProp^group) matches the given string.\n\n  }, {\n    key: \"is\",\n    value: function is(name) {\n      if (typeof name == 'string') {\n        if (this.name == name) return true;\n        var group = this.prop(NodeProp.group);\n        return group ? group.indexOf(name) > -1 : false;\n      }\n\n      return this.id == name;\n    } /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#tree.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n\n  }], [{\n    key: \"define\",\n    value: function define(spec) {\n      var props = spec.props && spec.props.length ? Object.create(null) : noProps;\n      var flags = (spec.top ? 1\n      /* Top */\n      : 0) | (spec.skipped ? 2\n      /* Skipped */\n      : 0) | (spec.error ? 4\n      /* Error */\n      : 0) | (spec.name == null ? 8\n      /* Anonymous */\n      : 0);\n      var type = new NodeType(spec.name || \"\", props, spec.id, flags);\n\n      if (spec.props) {\n        var _iterator = _createForOfIteratorHelper(spec.props),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var src = _step.value;\n            if (!Array.isArray(src)) src = src(type);\n            if (src) src[0].set(props, src[1]);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return type;\n    }\n  }, {\n    key: \"match\",\n    value: function match(map) {\n      var direct = Object.create(null);\n\n      for (var prop in map) {\n        var _iterator2 = _createForOfIteratorHelper(prop.split(\" \")),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var name = _step2.value;\n            direct[name] = map[prop];\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return function (node) {\n        for (var groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n          var found = direct[i < 0 ? node.name : groups[i]];\n          if (found) return found;\n        }\n      };\n    }\n  }]);\n\n  return NodeType;\n}(); /// An empty dummy node type to use when no actual type is available.\n\n\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8\n/* Anonymous */\n); /// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\n\nvar NodeSet = /*#__PURE__*/function () {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  function NodeSet( /// The node types in this set, by id.\n  types) {\n    _classCallCheck(this, NodeSet);\n\n    this.types = types;\n\n    for (var i = 0; i < types.length; i++) {\n      if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n  } /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#tree.NodeProp.add).\n\n\n  _createClass(NodeSet, [{\n    key: \"extend\",\n    value: function extend() {\n      var newTypes = [];\n\n      for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n        props[_key] = arguments[_key];\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(this.types),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var type = _step3.value;\n          var newProps = null;\n\n          var _iterator4 = _createForOfIteratorHelper(props),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var source = _step4.value;\n              var add = source(type);\n\n              if (add) {\n                if (!newProps) newProps = Object.assign({}, type.props);\n                add[0].set(newProps, add[1]);\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return new NodeSet(newTypes);\n    }\n  }]);\n\n  return NodeSet;\n}(); /// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\n\n\nvar Tree = /*#__PURE__*/function () {\n  /// Construct a new tree. You usually want to go through\n  /// [`Tree.build`](#tree.Tree^build) instead.\n  function Tree(type, /// The tree's child nodes. Children small enough to fit in a\n  /// `TreeBuffer will be represented as such, other children can be\n  /// further `Tree` instances with their own internal structure.\n  children, /// The positions (offsets relative to the start of this tree) of\n  /// the children.\n  positions, /// The total length of this tree\n  length) {\n    _classCallCheck(this, Tree);\n\n    this.type = type;\n    this.children = children;\n    this.positions = positions;\n    this.length = length;\n  } /// @internal\n\n\n  _createClass(Tree, [{\n    key: \"toString\",\n    value: function toString() {\n      var children = this.children.map(function (c) {\n        return c.toString();\n      }).join();\n      return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n    } /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n    /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n    /// to the given position and side.\n\n  }, {\n    key: \"cursor\",\n    value: function cursor(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var scope = pos != null && CachedNode.get(this) || this.topNode;\n      var cursor = new TreeCursor(scope);\n\n      if (pos != null) {\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n      }\n\n      return cursor;\n    } /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n    /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n    /// nodes.\n\n  }, {\n    key: \"fullCursor\",\n    value: function fullCursor() {\n      return new TreeCursor(this.topNode, true);\n    } /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n    /// tree.\n\n  }, {\n    key: \"topNode\",\n    get: function get() {\n      return new TreeNode(this, 0, 0, null);\n    } /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.cursor(pos, side).node;\n    } /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, the given node\n    /// will not have its children iterated over (or `leave` called).\n\n  }, {\n    key: \"iterate\",\n    value: function iterate(spec) {\n      var enter = spec.enter,\n          leave = spec.leave,\n          _spec$from = spec.from,\n          from = _spec$from === void 0 ? 0 : _spec$from,\n          _spec$to = spec.to,\n          to = _spec$to === void 0 ? this.length : _spec$to;\n\n      for (var c = this.cursor();;) {\n        var mustLeave = false;\n\n        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n          if (c.firstChild()) continue;\n          if (!c.type.isAnonymous) mustLeave = true;\n        }\n\n        for (;;) {\n          if (mustLeave && leave) leave(c.type, c.from, c.to);\n          mustLeave = c.type.isAnonymous;\n          if (c.nextSibling()) break;\n          if (!c.parent()) return;\n          mustLeave = true;\n        }\n      }\n    } /// Balance the direct children of this tree.\n\n  }, {\n    key: \"balance\",\n    value: function balance() {\n      var maxBufferLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultBufferLength;\n      return this.children.length <= BalanceBranchFactor ? this : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length, 0);\n    } /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n\n  }], [{\n    key: \"build\",\n    value: function build(data) {\n      return buildTree(data);\n    }\n  }]);\n\n  return Tree;\n}(); /// The empty tree\n\n\nTree.empty = new Tree(NodeType.none, [], [], 0); // For trees that need a context hash attached, we're using this\n// kludge which assigns an extra property directly after\n// initialization (creating a single new object shape).\n\nfunction withHash(tree, hash) {\n  if (hash) tree.contextHash = hash;\n  return tree;\n} /// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\n\n\nvar TreeBuffer = /*#__PURE__*/function () {\n  /// Create a tree buffer @internal\n  function TreeBuffer( /// @internal\n  buffer, // The total length of the group of nodes in the buffer.\n  length, /// @internal\n  set) {\n    var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NodeType.none;\n\n    _classCallCheck(this, TreeBuffer);\n\n    this.buffer = buffer;\n    this.length = length;\n    this.set = set;\n    this.type = type;\n  } /// @internal\n\n\n  _createClass(TreeBuffer, [{\n    key: \"toString\",\n    value: function toString() {\n      var result = [];\n\n      for (var index = 0; index < this.buffer.length;) {\n        result.push(this.childString(index));\n        index = this.buffer[index + 3];\n      }\n\n      return result.join(\",\");\n    } /// @internal\n\n  }, {\n    key: \"childString\",\n    value: function childString(index) {\n      var id = this.buffer[index],\n          endIndex = this.buffer[index + 3];\n      var type = this.set.types[id],\n          result = type.name;\n      if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n      index += 4;\n      if (endIndex == index) return result;\n      var children = [];\n\n      while (index < endIndex) {\n        children.push(this.childString(index));\n        index = this.buffer[index + 3];\n      }\n\n      return result + \"(\" + children.join(\",\") + \")\";\n    } /// @internal\n\n  }, {\n    key: \"findChild\",\n    value: function findChild(startIndex, endIndex, dir, after) {\n      var buffer = this.buffer,\n          pick = -1;\n\n      for (var i = startIndex; i != endIndex; i = buffer[i + 3]) {\n        if (after != -100000000\n        /* None */\n        ) {\n            var start = buffer[i + 1],\n                end = buffer[i + 2];\n\n            if (dir > 0) {\n              if (end > after) pick = i;\n              if (end > after) break;\n            } else {\n              if (start < after) pick = i;\n              if (end >= after) break;\n            }\n          } else {\n          pick = i;\n          if (dir > 0) break;\n        }\n      }\n\n      return pick;\n    }\n  }]);\n\n  return TreeBuffer;\n}();\n\nvar TreeNode = /*#__PURE__*/function () {\n  function TreeNode(node, from, index, _parent) {\n    _classCallCheck(this, TreeNode);\n\n    this.node = node;\n    this.from = from;\n    this.index = index;\n    this._parent = _parent;\n  }\n\n  _createClass(TreeNode, [{\n    key: \"type\",\n    get: function get() {\n      return this.node.type;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.node.type.name;\n    }\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.from + this.node.length;\n    }\n  }, {\n    key: \"nextChild\",\n    value: function nextChild(i, dir, after) {\n      var full = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      for (var parent = this;;) {\n        for (var _parent$node = parent.node, children = _parent$node.children, positions = _parent$node.positions, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n          var next = children[i],\n              start = positions[i] + parent.from;\n          if (after != -100000000\n          /* None */\n          && (dir < 0 ? start >= after : start + next.length <= after)) continue;\n\n          if (next instanceof TreeBuffer) {\n            var index = next.findChild(0, next.buffer.length, dir, after == -100000000\n            /* None */\n            ? -100000000\n            /* None */\n            : after - start);\n            if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n          } else if (full || !next.type.isAnonymous || hasChild(next)) {\n            var inner = new TreeNode(next, start, i, parent);\n            return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);\n          }\n        }\n\n        if (full || !parent.type.isAnonymous) return null;\n        i = parent.index + dir;\n        parent = parent._parent;\n        if (!parent) return null;\n      }\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.nextChild(0, 1, -100000000\n      /* None */\n      );\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.nextChild(this.node.children.length - 1, -1, -100000000\n      /* None */\n      );\n    }\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      return this.nextChild(0, 1, pos);\n    }\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      return this.nextChild(this.node.children.length - 1, -1, pos);\n    }\n  }, {\n    key: \"nextSignificantParent\",\n    value: function nextSignificantParent() {\n      var val = this;\n\n      while (val.type.isAnonymous && val._parent) {\n        val = val._parent;\n      }\n\n      return val;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;\n    }\n  }, {\n    key: \"prevSibling\",\n    get: function get() {\n      return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;\n    }\n  }, {\n    key: \"cursor\",\n    get: function get() {\n      return new TreeCursor(this);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.cursor.moveTo(pos, side).node;\n    }\n  }, {\n    key: \"getChild\",\n    value: function getChild(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var r = _getChildren(this, type, before, after);\n\n      return r.length ? r[0] : null;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return _getChildren(this, type, before, after);\n    } /// @internal\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.node.toString();\n    }\n  }]);\n\n  return TreeNode;\n}();\n\nfunction _getChildren(node, type, before, after) {\n  var cur = node.cursor,\n      result = [];\n  if (!cur.firstChild()) return result;\n  if (before != null) while (!cur.type.is(before)) {\n    if (!cur.nextSibling()) return result;\n  }\n\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result;\n    if (cur.type.is(type)) result.push(cur.node);\n    if (!cur.nextSibling()) return after == null ? result : [];\n  }\n}\n\nvar BufferContext = function BufferContext(parent, buffer, index, start) {\n  _classCallCheck(this, BufferContext);\n\n  this.parent = parent;\n  this.buffer = buffer;\n  this.index = index;\n  this.start = start;\n};\n\nvar BufferNode = /*#__PURE__*/function () {\n  function BufferNode(context, _parent, index) {\n    _classCallCheck(this, BufferNode);\n\n    this.context = context;\n    this._parent = _parent;\n    this.index = index;\n    this.type = context.buffer.set.types[context.buffer.buffer[index]];\n  }\n\n  _createClass(BufferNode, [{\n    key: \"name\",\n    get: function get() {\n      return this.type.name;\n    }\n  }, {\n    key: \"from\",\n    get: function get() {\n      return this.context.start + this.context.buffer.buffer[this.index + 1];\n    }\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.context.start + this.context.buffer.buffer[this.index + 2];\n    }\n  }, {\n    key: \"child\",\n    value: function child(dir, after) {\n      var buffer = this.context.buffer;\n      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000\n      /* None */\n      ? -100000000\n      /* None */\n      : after - this.context.start);\n      return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.child(1, -100000000\n      /* None */\n      );\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.child(-1, -100000000\n      /* None */\n      );\n    }\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      return this.child(1, pos);\n    }\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      return this.child(-1, pos);\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent || this.context.parent.nextSignificantParent();\n    }\n  }, {\n    key: \"externalSibling\",\n    value: function externalSibling(dir) {\n      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var buffer = this.context.buffer;\n      var after = buffer.buffer[this.index + 3];\n      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n      return this.externalSibling(1);\n    }\n  }, {\n    key: \"prevSibling\",\n    get: function get() {\n      var buffer = this.context.buffer;\n      var parentStart = this._parent ? this._parent.index + 4 : 0;\n      if (this.index == parentStart) return this.externalSibling(-1);\n      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000\n      /* None */\n      ));\n    }\n  }, {\n    key: \"cursor\",\n    get: function get() {\n      return new TreeCursor(this);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.cursor.moveTo(pos, side).node;\n    } /// @internal\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.context.buffer.childString(this.index);\n    }\n  }, {\n    key: \"getChild\",\n    value: function getChild(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var r = _getChildren(this, type, before, after);\n\n      return r.length ? r[0] : null;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(type) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return _getChildren(this, type, before, after);\n    }\n  }]);\n\n  return BufferNode;\n}(); /// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\n\n\nvar TreeCursor = /*#__PURE__*/function () {\n  /// @internal\n  function TreeCursor(node) {\n    var full = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _classCallCheck(this, TreeCursor);\n\n    this.full = full;\n    this.buffer = null;\n    this.stack = [];\n    this.index = 0;\n    this.bufferNode = null;\n\n    if (node instanceof TreeNode) {\n      this.yieldNode(node);\n    } else {\n      this._tree = node.context.parent;\n      this.buffer = node.context;\n\n      for (var n = node._parent; n; n = n._parent) {\n        this.stack.unshift(n.index);\n      }\n\n      this.bufferNode = node;\n      this.yieldBuf(node.index);\n    }\n  } /// Shorthand for `.type.name`.\n\n\n  _createClass(TreeCursor, [{\n    key: \"name\",\n    get: function get() {\n      return this.type.name;\n    }\n  }, {\n    key: \"yieldNode\",\n    value: function yieldNode(node) {\n      if (!node) return false;\n      this._tree = node;\n      this.type = node.type;\n      this.from = node.from;\n      this.to = node.to;\n      return true;\n    }\n  }, {\n    key: \"yieldBuf\",\n    value: function yieldBuf(index, type) {\n      this.index = index;\n      var _this$buffer = this.buffer,\n          start = _this$buffer.start,\n          buffer = _this$buffer.buffer;\n      this.type = type || buffer.set.types[buffer.buffer[index]];\n      this.from = start + buffer.buffer[index + 1];\n      this.to = start + buffer.buffer[index + 2];\n      return true;\n    }\n  }, {\n    key: \"yield\",\n    value: function _yield(node) {\n      if (!node) return false;\n\n      if (node instanceof TreeNode) {\n        this.buffer = null;\n        return this.yieldNode(node);\n      }\n\n      this.buffer = node.context;\n      return this.yieldBuf(node.index, node.type);\n    } /// @internal\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    } /// @internal\n\n  }, {\n    key: \"enter\",\n    value: function enter(dir, after) {\n      if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));\n      var buffer = this.buffer.buffer;\n      var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000\n      /* None */\n      ? -100000000\n      /* None */\n      : after - this.buffer.start);\n      if (index < 0) return false;\n      this.stack.push(this.index);\n      return this.yieldBuf(index);\n    } /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n\n  }, {\n    key: \"firstChild\",\n    value: function firstChild() {\n      return this.enter(1, -100000000\n      /* None */\n      );\n    } /// Move the cursor to this node's last child.\n\n  }, {\n    key: \"lastChild\",\n    value: function lastChild() {\n      return this.enter(-1, -100000000\n      /* None */\n      );\n    } /// Move the cursor to the first child that starts at or after `pos`.\n\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      return this.enter(1, pos);\n    } /// Move to the last child that ends at or before `pos`.\n\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      return this.enter(-1, pos);\n    } /// Move the node's parent node, if this isn't the top node.\n\n  }, {\n    key: \"parent\",\n    value: function parent() {\n      if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);\n      if (this.stack.length) return this.yieldBuf(this.stack.pop());\n      var parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n      this.buffer = null;\n      return this.yieldNode(parent);\n    } /// @internal\n\n  }, {\n    key: \"sibling\",\n    value: function sibling(dir) {\n      if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000\n      /* None */\n      , this.full));\n      var buffer = this.buffer.buffer,\n          d = this.stack.length - 1;\n\n      if (dir < 0) {\n        var parentStart = d < 0 ? 0 : this.stack[d] + 4;\n        if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000\n        /* None */\n        ));\n      } else {\n        var after = buffer.buffer[this.index + 3];\n        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n      }\n\n      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000\n      /* None */\n      , this.full)) : false;\n    } /// Move to this node's next sibling, if any.\n\n  }, {\n    key: \"nextSibling\",\n    value: function nextSibling() {\n      return this.sibling(1);\n    } /// Move to this node's previous sibling, if any.\n\n  }, {\n    key: \"prevSibling\",\n    value: function prevSibling() {\n      return this.sibling(-1);\n    }\n  }, {\n    key: \"atLastNode\",\n    value: function atLastNode(dir) {\n      var index,\n          parent,\n          buffer = this.buffer;\n\n      if (buffer) {\n        if (dir > 0) {\n          if (this.index < buffer.buffer.buffer.length) return false;\n        } else {\n          for (var i = 0; i < this.index; i++) {\n            if (buffer.buffer.buffer[i + 3] < this.index) return false;\n          }\n        }\n\n        index = buffer.index;\n        parent = buffer.parent;\n      } else {\n        var _this$_tree = this._tree;\n        index = _this$_tree.index;\n        parent = _this$_tree._parent;\n      }\n\n      for (; parent; _parent2 = parent, index = _parent2.index, parent = _parent2._parent, _parent2) {\n        var _parent2;\n\n        for (var _i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; _i != e; _i += dir) {\n          var child = parent.node.children[_i];\n          if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child)) return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"move\",\n    value: function move(dir) {\n      if (this.enter(dir, -100000000\n      /* None */\n      )) return true;\n\n      for (;;) {\n        if (this.sibling(dir)) return true;\n        if (this.atLastNode(dir) || !this.parent()) return false;\n      }\n    } /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty, its next sibling or the next sibling of\n    /// the first parent node that has one.\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      return this.move(1);\n    } /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by ist last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n\n  }, {\n    key: \"prev\",\n    value: function prev() {\n      return this.move(-1);\n    } /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      // Move up to a node that actually holds the position, if possible\n      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) {\n        if (!this.parent()) break;\n      } // Then scan down into child nodes as far as possible\n\n\n      for (;;) {\n        if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos)) break;\n\n        if (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) {\n          this.parent();\n          break;\n        }\n      }\n\n      return this;\n    } /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n    /// position.\n\n  }, {\n    key: \"node\",\n    get: function get() {\n      if (!this.buffer) return this._tree;\n      var cache = this.bufferNode,\n          result = null,\n          depth = 0;\n\n      if (cache && cache.context == this.buffer) {\n        scan: for (var index = this.index, d = this.stack.length; d >= 0;) {\n          for (var c = cache; c; c = c._parent) {\n            if (c.index == index) {\n              if (index == this.index) return c;\n              result = c;\n              depth = d + 1;\n              break scan;\n            }\n          }\n\n          index = this.stack[--d];\n        }\n      }\n\n      for (var i = depth; i < this.stack.length; i++) {\n        result = new BufferNode(this.buffer, result, this.stack[i]);\n      }\n\n      return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    } /// Get the [tree](#tree.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#tree.TreeBuffer).\n\n  }, {\n    key: \"tree\",\n    get: function get() {\n      return this.buffer ? null : this._tree.node;\n    }\n  }]);\n\n  return TreeCursor;\n}();\n\nfunction hasChild(tree) {\n  return tree.children.some(function (ch) {\n    return !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch);\n  });\n}\n\nvar FlatBufferCursor = /*#__PURE__*/function () {\n  function FlatBufferCursor(buffer, index) {\n    _classCallCheck(this, FlatBufferCursor);\n\n    this.buffer = buffer;\n    this.index = index;\n  }\n\n  _createClass(FlatBufferCursor, [{\n    key: \"id\",\n    get: function get() {\n      return this.buffer[this.index - 4];\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      return this.buffer[this.index - 3];\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.buffer[this.index - 2];\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.buffer[this.index - 1];\n    }\n  }, {\n    key: \"pos\",\n    get: function get() {\n      return this.index;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      this.index -= 4;\n    }\n  }, {\n    key: \"fork\",\n    value: function fork() {\n      return new FlatBufferCursor(this.buffer, this.index);\n    }\n  }]);\n\n  return FlatBufferCursor;\n}();\n\nvar BalanceBranchFactor = 8;\n\nfunction buildTree(data) {\n  var _a;\n\n  var buffer = data.buffer,\n      nodeSet = data.nodeSet,\n      _data$topID = data.topID,\n      topID = _data$topID === void 0 ? 0 : _data$topID,\n      _data$maxBufferLength = data.maxBufferLength,\n      maxBufferLength = _data$maxBufferLength === void 0 ? DefaultBufferLength : _data$maxBufferLength,\n      _data$reused = data.reused,\n      reused = _data$reused === void 0 ? [] : _data$reused,\n      _data$minRepeatType = data.minRepeatType,\n      minRepeatType = _data$minRepeatType === void 0 ? nodeSet.types.length : _data$minRepeatType;\n  var cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n  var types = nodeSet.types;\n  var contextHash = 0;\n\n  function takeNode(parentStart, minPos, children, positions, inRepeat) {\n    var id = cursor.id,\n        start = cursor.start,\n        end = cursor.end,\n        size = cursor.size;\n    var startPos = start - parentStart;\n\n    if (size < 0) {\n      if (size == -1) {\n        // Reused node\n        children.push(reused[id]);\n        positions.push(startPos);\n      } else {\n        // Context change\n        contextHash = id;\n      }\n\n      cursor.next();\n      return;\n    }\n\n    var type = types[id],\n        node,\n        buffer;\n\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      var _data = new Uint16Array(buffer.size - buffer.skip);\n\n      var endPos = cursor.pos - buffer.size,\n          index = _data.length;\n\n      while (cursor.pos > endPos) {\n        index = copyToBuffer(buffer.start, _data, index, inRepeat);\n      }\n\n      node = new TreeBuffer(_data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);\n      startPos = buffer.start - parentStart;\n    } else {\n      // Make it a node\n      var _endPos = cursor.pos - size;\n\n      cursor.next();\n      var localChildren = [],\n          localPositions = [];\n      var localInRepeat = id >= minRepeatType ? id : -1;\n\n      while (cursor.pos > _endPos) {\n        if (cursor.id == localInRepeat) cursor.next();else takeNode(start, _endPos, localChildren, localPositions, localInRepeat);\n      }\n\n      localChildren.reverse();\n      localPositions.reverse();\n      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor) node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start, contextHash);else node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash);\n    }\n\n    children.push(node);\n    positions.push(startPos);\n  }\n\n  function findBufferSize(maxSize, inRepeat) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    var fork = cursor.fork();\n    var size = 0,\n        start = 0,\n        skip = 0,\n        minStart = fork.end - maxBufferLength;\n    var result = {\n      size: 0,\n      start: 0,\n      skip: 0\n    };\n\n    scan: for (var minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size;\n        result.start = start;\n        result.skip = skip;\n        skip += 4;\n        size += 4;\n        fork.next();\n        continue;\n      }\n\n      var nodeSize = fork.size,\n          startPos = fork.pos - nodeSize;\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n      var localSkipped = fork.id >= minRepeatType ? 4 : 0;\n      var nodeStart = fork.start;\n      fork.next();\n\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan;\n        if (fork.id >= minRepeatType) localSkipped += 4;\n        fork.next();\n      }\n\n      start = nodeStart;\n      size += nodeSize;\n      skip += localSkipped;\n    }\n\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size;\n      result.start = start;\n      result.skip = skip;\n    }\n\n    return result.size > 4 ? result : undefined;\n  }\n\n  function copyToBuffer(bufferStart, buffer, index, inRepeat) {\n    var id = cursor.id,\n        start = cursor.start,\n        end = cursor.end,\n        size = cursor.size;\n    cursor.next();\n    if (id == inRepeat) return index;\n    var startIndex = index;\n\n    if (size > 4) {\n      var endPos = cursor.pos - (size - 4);\n\n      while (cursor.pos > endPos) {\n        index = copyToBuffer(bufferStart, buffer, index, inRepeat);\n      }\n    }\n\n    if (id < minRepeatType) {\n      // Don't copy repeat nodes into buffers\n      buffer[--index] = startIndex;\n      buffer[--index] = end - bufferStart;\n      buffer[--index] = start - bufferStart;\n      buffer[--index] = id;\n    }\n\n    return index;\n  }\n\n  var children = [],\n      positions = [];\n\n  while (cursor.pos > 0) {\n    takeNode(data.start || 0, 0, children, positions, -1);\n  }\n\n  var length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n  return new Tree(types[topID], children.reverse(), positions.reverse(), length);\n}\n\nfunction balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length, contextHash) {\n  var localChildren = [],\n      localPositions = [];\n\n  if (length <= maxBufferLength) {\n    for (var i = from; i < to; i++) {\n      localChildren.push(children[i]);\n      localPositions.push(positions[i] - start);\n    }\n  } else {\n    var maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));\n\n    for (var _i2 = from; _i2 < to;) {\n      var groupFrom = _i2,\n          groupStart = positions[_i2];\n      _i2++;\n\n      for (; _i2 < to; _i2++) {\n        var nextEnd = positions[_i2] + children[_i2].length;\n        if (nextEnd - groupStart > maxChild) break;\n      }\n\n      if (_i2 == groupFrom + 1) {\n        var only = children[groupFrom];\n\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) {\n          // Too big, collapse\n          for (var j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j]);\n            localPositions.push(only.positions[j] + groupStart - start);\n          }\n\n          continue;\n        }\n\n        localChildren.push(only);\n      } else if (_i2 == groupFrom + 1) {\n        localChildren.push(children[groupFrom]);\n      } else {\n        var inner = balanceRange(innerType, innerType, children, positions, groupFrom, _i2, groupStart, maxBufferLength, positions[_i2 - 1] + children[_i2 - 1].length - groupStart, contextHash);\n        if (innerType != NodeType.none && !containsType(inner.children, innerType)) inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash);\n        localChildren.push(inner);\n      }\n\n      localPositions.push(groupStart - start);\n    }\n  }\n\n  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash);\n}\n\nfunction containsType(nodes, type) {\n  var _iterator5 = _createForOfIteratorHelper(nodes),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var elt = _step5.value;\n      if (elt.type == type) return true;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return false;\n} /// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\n\n\nvar TreeFragment = /*#__PURE__*/function () {\n  function TreeFragment( /// The start of the unchanged range pointed to by this fragment.\n  /// This refers to an offset in the _updated_ document (as opposed\n  /// to the original tree).\n  from, /// The end of the unchanged range.\n  to, /// The tree that this fragment is based on.\n  tree, /// The offset between the fragment's tree and the document that\n  /// this fragment can be used against. Add this when going from\n  /// document to tree positions, subtract it to go from tree to\n  /// document positions.\n  offset, open) {\n    _classCallCheck(this, TreeFragment);\n\n    this.from = from;\n    this.to = to;\n    this.tree = tree;\n    this.offset = offset;\n    this.open = open;\n  }\n\n  _createClass(TreeFragment, [{\n    key: \"openStart\",\n    get: function get() {\n      return (this.open & 1\n      /* Start */\n      ) > 0;\n    }\n  }, {\n    key: \"openEnd\",\n    get: function get() {\n      return (this.open & 2\n      /* End */\n      ) > 0;\n    } /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n\n  }], [{\n    key: \"applyChanges\",\n    value: function applyChanges(fragments, changes) {\n      var minGap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 128;\n      if (!changes.length) return fragments;\n      var result = [];\n      var fI = 1,\n          nextF = fragments.length ? fragments[0] : null;\n      var cI = 0,\n          pos = 0,\n          off = 0;\n\n      for (;;) {\n        var nextC = cI < changes.length ? changes[cI++] : null;\n        var nextPos = nextC ? nextC.fromA : 1e9;\n        if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n          var cut = nextF;\n\n          if (pos >= cut.from || nextPos <= cut.to || off) {\n            var fFrom = Math.max(cut.from, pos) - off,\n                fTo = Math.min(cut.to, nextPos) - off;\n            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1\n            /* Start */\n            : 0) | (nextC ? 2\n            /* End */\n            : 0));\n          }\n\n          if (cut) result.push(cut);\n          if (nextF.to > nextPos) break;\n          nextF = fI < fragments.length ? fragments[fI++] : null;\n        }\n        if (!nextC) break;\n        pos = nextC.toA;\n        off = nextC.toA - nextC.toB;\n      }\n\n      return result;\n    } /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the token at its\n    /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n\n  }, {\n    key: \"addTree\",\n    value: function addTree(tree) {\n      var fragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var partial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2\n      /* End */\n      : 0)];\n\n      var _iterator6 = _createForOfIteratorHelper(fragments),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var f = _step6.value;\n          if (f.to > tree.length) result.push(f);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return result;\n    }\n  }]);\n\n  return TreeFragment;\n}(); // Creates an `Input` that is backed by a single, flat string.\n\n\nfunction stringInput(input) {\n  return new StringInput(input);\n}\n\nvar StringInput = /*#__PURE__*/function () {\n  function StringInput(string) {\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : string.length;\n\n    _classCallCheck(this, StringInput);\n\n    this.string = string;\n    this.length = length;\n  }\n\n  _createClass(StringInput, [{\n    key: \"get\",\n    value: function get(pos) {\n      return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);\n    }\n  }, {\n    key: \"lineAfter\",\n    value: function lineAfter(pos) {\n      if (pos < 0) return \"\";\n      var end = this.string.indexOf(\"\\n\", pos);\n      return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));\n    }\n  }, {\n    key: \"read\",\n    value: function read(from, to) {\n      return this.string.slice(from, Math.min(this.length, to));\n    }\n  }, {\n    key: \"clip\",\n    value: function clip(at) {\n      return new StringInput(this.string, at);\n    }\n  }]);\n\n  return StringInput;\n}();\n\nexport { DefaultBufferLength, NodeProp, NodeSet, NodeType, Tree, TreeBuffer, TreeCursor, TreeFragment, stringInput };","map":{"version":3,"sources":["../src/tree.ts"],"names":[],"mappings":"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","sourcesContent":["/// The default maximum length of a `TreeBuffer` node.\nexport const DefaultBufferLength = 1024\n\nlet nextPropID = 0\n\nconst CachedNode = new WeakMap<Tree, TreeNode>()\n\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nexport class NodeProp<T> {\n  /// @internal\n  id: number\n\n  /// A method that deserializes a value of this prop from a string.\n  /// Can be used to allow a prop to be directly written in a grammar\n  /// file. Defaults to raising an error.\n  deserialize: (str: string) => T\n\n  /// Create a new node prop type. You can optionally pass a\n  /// `deserialize` function.\n  constructor({deserialize}: {deserialize?: (str: string) => T} = {}) {\n    this.id = nextPropID++\n    this.deserialize = deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\")\n    })\n  }\n\n  /// Create a string-valued node prop whose deserialize function is\n  /// the identity function.\n  static string() { return new NodeProp<string>({deserialize: str => str}) }\n\n  /// Create a number-valued node prop whose deserialize function is\n  /// just `Number`.\n  static number() { return new NodeProp<number>({deserialize: Number}) }\n\n  /// Creates a boolean-valued node prop whose deserialize function\n  /// returns true for any input.\n  static flag() { return new NodeProp<boolean>({deserialize: () => true}) }\n\n  /// Store a value for this prop in the given object. This can be\n  /// useful when building up a prop object to pass to the\n  /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n  /// argument.\n  set(propObj: {[prop: number]: any}, value: T) {\n    propObj[this.id] = value\n    return propObj\n  }\n\n  /// This is meant to be used with\n  /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n  /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n  /// values for each node type in the set. Takes a [match\n  /// object](#tree.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  add(match: {[selector: string]: T} | ((type: NodeType) => T | undefined)): NodePropSource {\n    if (typeof match != \"function\") match = NodeType.match(match)\n    return (type) => {\n      let result = (match as (type: NodeType) => T | undefined)(type)\n      return result === undefined ? null : [this, result]\n    }\n  }\n\n  /// Prop that is used to describe matching delimiters. For opening\n  /// delimiters, this holds an array of node names (written as a\n  /// space-separated string when declaring this prop in a grammar)\n  /// for the node types of closing delimiters that match it.\n  static closedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n  /// attached to closing delimiters, holding an array of node names\n  /// of types of matching opening delimiters.\n  static openedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// Used to assign node types to groups (for example, all node\n  /// types that represent an expression could be tagged with an\n  /// `\"Expression\"` group).\n  static group = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n}\n\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node set.\nexport type NodePropSource = (type: NodeType) => null | [NodeProp<any>, any]\n\n// Note: this is duplicated in lezer/src/constants.ts\nconst enum NodeFlag {\n  Top = 1,\n  Skipped = 2,\n  Error = 4,\n  Anonymous = 8\n}\n\nconst noProps: {[propID: number]: any} = Object.create(null)\n\n/// Each node in a syntax tree has a node type associated with it.\nexport class NodeType {\n  /// @internal\n  constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    readonly name: string,\n    /// @internal\n    readonly props: {readonly [prop: number]: any},\n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    readonly id: number,\n    /// @internal\n    readonly flags: number = 0) {}\n\n  static define(spec: {\n    /// The ID of the node type. When this type is used in a\n    /// [set](#tree.NodeSet), the ID must correspond to its index in\n    /// the type array.\n    id: number, \n    /// The name of the node type. Leave empty to define an anonymous\n    /// node.\n    name?: string,\n    /// [Node props](#tree.NodeProp) to assign to the type. The value\n    /// given for any given prop should correspond to the prop's type.\n    props?: readonly ([NodeProp<any>, any] | NodePropSource)[],\n    /// Whether is is a [top node](#tree.NodeType.isTop).\n    top?: boolean,\n    /// Whether this node counts as an [error\n    /// node](#tree.NodeType.isError).\n    error?: boolean,\n    /// Whether this node is a [skipped](#tree.NodeType.isSkipped)\n    /// node.\n    skipped?: boolean\n  }) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps\n    let flags = (spec.top ? NodeFlag.Top : 0) | (spec.skipped ? NodeFlag.Skipped : 0) |\n      (spec.error ? NodeFlag.Error : 0) | (spec.name == null ? NodeFlag.Anonymous : 0)\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags)\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type)!\n      if (src) src[0].set(props, src[1])\n    }\n    return type\n  }\n\n  /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n  prop<T>(prop: NodeProp<T>): T | undefined { return this.props[prop.id] }\n\n  /// True when this is the top node of a grammar.\n  get isTop() { return (this.flags & NodeFlag.Top) > 0 }\n\n  /// True when this node is produced by a skip rule.\n  get isSkipped() { return (this.flags & NodeFlag.Skipped) > 0 }\n\n  /// Indicates whether this is an error node.\n  get isError() { return (this.flags & NodeFlag.Error) > 0 }\n\n  /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n  get isAnonymous() { return (this.flags & NodeFlag.Anonymous) > 0 }\n\n  /// Returns true when this node's name or one of its\n  /// [groups](#tree.NodeProp^group) matches the given string.\n  is(name: string | number) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true\n      let group = this.prop(NodeProp.group)\n      return group ? group.indexOf(name) > -1 : false\n    }\n    return this.id == name\n  }\n\n  /// An empty dummy node type to use when no actual type is available.\n  static none: NodeType = new NodeType(\"\", Object.create(null), 0, NodeFlag.Anonymous)\n\n  /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#tree.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n  static match<T>(map: {[selector: string]: T}): (node: NodeType) => T | undefined {\n    let direct = Object.create(null)\n    for (let prop in map)\n      for (let name of prop.split(\" \")) direct[name] = map[prop]\n    return (node: NodeType) => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups![i]]\n        if (found) return found\n      }\n    }\n  }\n}\n\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nexport class NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor(\n    /// The node types in this set, by id.\n    readonly types: readonly NodeType[]\n  ) {\n    for (let i = 0; i < types.length; i++) if (types[i].id != i)\n      throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\")\n  }\n\n  /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#tree.NodeProp.add).\n  extend(...props: NodePropSource[]): NodeSet {\n    let newTypes: NodeType[] = []\n    for (let type of this.types) {\n      let newProps = null\n      for (let source of props) {\n        let add = source(type)\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props)\n          add[0].set(newProps, add[1])\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type)\n    }\n    return new NodeSet(newTypes)\n  }\n}\n\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\nexport class Tree {\n  /// Construct a new tree. You usually want to go through\n  /// [`Tree.build`](#tree.Tree^build) instead.\n  constructor(\n    readonly type: NodeType,\n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    readonly children: readonly (Tree | TreeBuffer)[],\n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    readonly positions: readonly number[],\n    /// The total length of this tree\n    readonly length: number\n  ) {}\n\n  /// @internal\n  toString(): string {\n    let children = this.children.map(c => c.toString()).join()\n    return !this.type.name ? children :\n      (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n      (children.length ? \"(\" + children + \")\" : \"\")\n  }\n\n  /// The empty tree\n  static empty = new Tree(NodeType.none, [], [], 0)\n\n  /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n  /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n  /// to the given position and side.\n  cursor(pos?: number, side: -1 | 0 | 1 = 0): TreeCursor {\n    let scope = (pos != null && CachedNode.get(this)) || (this.topNode as TreeNode)\n    let cursor = new TreeCursor(scope)\n    if (pos != null) {\n      cursor.moveTo(pos, side)\n      CachedNode.set(this, cursor._tree)\n    }\n    return cursor\n  }\n\n  /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n  /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n  /// nodes.\n  fullCursor(): TreeCursor {\n    return new TreeCursor(this.topNode as TreeNode, true)\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n  /// tree.\n  get topNode(): SyntaxNode {\n    return new TreeNode(this, 0, 0, null)\n  }\n\n  /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor(pos, side).node\n  }\n\n  /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, the given node\n  /// will not have its children iterated over (or `leave` called).\n  iterate(spec: {\n    enter(type: NodeType, from: number, to: number): false | void,\n    leave?(type: NodeType, from: number, to: number): void,\n    from?: number,\n    to?: number\n  }) {\n    let {enter, leave, from = 0, to = this.length} = spec\n    for (let c = this.cursor();;) {\n      let mustLeave = false\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n        if (c.firstChild()) continue\n        if (!c.type.isAnonymous) mustLeave = true\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to)\n        mustLeave = c.type.isAnonymous\n        if (c.nextSibling()) break\n        if (!c.parent()) return\n        mustLeave = true\n      }\n    }\n  }\n\n  /// Balance the direct children of this tree.\n  balance(maxBufferLength = DefaultBufferLength) {\n    return this.children.length <= BalanceBranchFactor ? this\n      : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0,\n                     maxBufferLength, this.length, 0)\n  }\n\n  /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n  static build(data: BuildData) { return buildTree(data) }\n}\n\n// For trees that need a context hash attached, we're using this\n// kludge which assigns an extra property directly after\n// initialization (creating a single new object shape).\nfunction withHash(tree: Tree, hash: number) {\n  if (hash) (tree as any).contextHash = hash\n  return tree\n}\n\ntype BuildData = {\n  /// The buffer or buffer cursor to read the node data from.\n  ///\n  /// When this is an array, it should contain four values for every\n  /// node in the tree.\n  ///\n  ///  - The first holds the node's type, as a node ID pointing into\n  ///    the given `NodeSet`.\n  ///  - The second holds the node's start offset.\n  ///  - The third the end offset.\n  ///  - The fourth the amount of space taken up in the array by this\n  ///    node and its children. Since there's four values per node,\n  ///    this is the total number of nodes inside this node (children\n  ///    and transitive children) plus one for the node itself, times\n  ///    four.\n  ///\n  /// Parent nodes should appear _after_ child nodes in the array. As\n  /// an example, a node of type 10 spanning positions 0 to 4, with\n  /// two children, of type 11 and 12, might look like this:\n  ///\n  ///     [11, 0, 1, 4, 12, 2, 4, 4, 10, 0, 4, 12]\n  buffer: BufferCursor | readonly number[],\n  /// The node types to use.\n  nodeSet: NodeSet,\n  /// The id of the top node type, if any.\n  topID?: number,\n  /// The position the tree should start at. Defaults to 0.\n  start?: number,\n  /// The length of the wrapping node. The end offset of the last\n  /// child is used when not provided.\n  length?: number,\n  /// The maximum buffer length to use. Defaults to\n  /// [`DefaultBufferLength`](#tree.DefaultBufferLength).\n  maxBufferLength?: number,\n  /// An optional set of reused nodes that the buffer can refer to.\n  reused?: (Tree | TreeBuffer)[],\n  /// The first node type that indicates repeat constructs in this\n  /// grammar.\n  minRepeatType?: number\n}\n\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nexport class TreeBuffer {\n  /// Create a tree buffer @internal\n  constructor(\n    /// @internal\n    readonly buffer: Uint16Array,\n    // The total length of the group of nodes in the buffer.\n    readonly length: number,\n    /// @internal\n    readonly set: NodeSet,\n    readonly type = NodeType.none\n  ) {}\n\n  /// @internal\n  toString() {\n    let result: string[] = []\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result.join(\",\")\n  }\n\n  /// @internal\n  childString(index: number): string {\n    let id = this.buffer[index], endIndex = this.buffer[index + 3]\n    let type = this.set.types[id], result = type.name\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result)\n    index += 4\n    if (endIndex == index) return result\n    let children: string[] = []\n    while (index < endIndex) {\n      children.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result + \"(\" + children.join(\",\") + \")\"\n  }\n\n  /// @internal\n  findChild(startIndex: number, endIndex: number, dir: 1 | -1, after: number) {\n    let {buffer} = this, pick = -1\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (after != After.None) {\n        let start = buffer[i + 1], end = buffer[i + 2]\n        if (dir > 0) {\n          if (end > after) pick = i\n          if (end > after) break\n        } else {\n          if (start < after) pick = i\n          if (end >= after) break\n        }\n      } else {\n        pick = i\n        if (dir > 0) break\n      }\n    }\n    return pick\n  }\n}\n\nconst enum After { None = -1e8 }\n\n/// A syntax node provides an immutable pointer at a given node in a\n/// tree. When iterating over large amounts of nodes, you may want to\n/// use a mutable [cursor](#tree.TreeCursor) instead, which is more\n/// efficient.\nexport interface SyntaxNode {\n  /// The type of the node.\n  type: NodeType\n  /// The name of the node (`.type.name`).\n  name: string\n  /// The start position of the node.\n  from: number\n  /// The end position of the node.\n  to: number\n\n  /// The node's parent node, if any.\n  parent: SyntaxNode | null\n  /// The first child, if the node has children.\n  firstChild: SyntaxNode | null\n  /// The node's last child, if available.\n  lastChild: SyntaxNode | null\n  /// The first child that starts at or after `pos`.\n  childAfter(pos: number): SyntaxNode | null\n  /// The last child that ends at or before `pos`.\n  childBefore(pos: number): SyntaxNode | null\n  /// This node's next sibling, if any.\n  nextSibling: SyntaxNode | null\n  /// This node's previous sibling.\n  prevSibling: SyntaxNode | null\n  /// A [tree cursor](#tree.TreeCursor) starting at this node.\n  cursor: TreeCursor\n  /// Find the node around, before (if `side` is -1), or after (`side`\n  /// is 1) the given position. Will look in parent nodes if the\n  /// position is outside this node.\n  resolve(pos: number, side?: -1 | 0 | 1): SyntaxNode\n\n  /// Get the first child of the given type (which may be a [node\n  /// name](#tree.NodeProp.name) or a [group\n  /// name](#tree.NodeProp^group)). If `before` is non-null, only\n  /// return children that occur somewhere after a node with that name\n  /// or group. If `after` is non-null, only return children that\n  /// occur somewhere before a node with that name or group.\n  getChild(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode | null\n\n  /// Like [`getChild`](#tree.SyntaxNode.getChild), but return all\n  /// matching children, not just the first.\n  getChildren(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode[]\n}\n\nclass TreeNode implements SyntaxNode {\n  constructor(readonly node: Tree,\n              readonly from: number,\n              readonly index: number,\n              readonly _parent: TreeNode | null) {}\n\n  get type() { return this.node.type }\n\n  get name() { return this.node.type.name }\n\n  get to() { return this.from + this.node.length }\n\n  nextChild(i: number, dir: 1 | -1, after: number, full = false): TreeNode | BufferNode | null {\n    for (let parent: TreeNode = this;;) {\n      for (let {children, positions} = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i], start = positions[i] + parent.from\n        if (after != After.None && (dir < 0 ? start >= after : start + next.length <= after))\n          continue\n        if (next instanceof TreeBuffer) {\n          let index = next.findChild(0, next.buffer.length, dir, after == After.None ? After.None : after - start)\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index)\n        } else if (full || (!next.type.isAnonymous || hasChild(next))) {\n          let inner = new TreeNode(next, start, i, parent)\n          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after)\n        }\n      }\n      if (full || !parent.type.isAnonymous) return null\n      i = parent.index + dir\n      parent = parent._parent!\n      if (!parent) return null\n    }\n  }\n\n  get firstChild() { return this.nextChild(0, 1, After.None) }\n  get lastChild() { return this.nextChild(this.node.children.length - 1, -1, After.None) }\n\n  childAfter(pos: number) { return this.nextChild(0, 1, pos) }\n  childBefore(pos: number) { return this.nextChild(this.node.children.length - 1, -1, pos) }\n\n  nextSignificantParent() {\n    let val: TreeNode = this\n    while (val.type.isAnonymous && val._parent) val = val._parent\n    return val\n  }\n\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null\n  }\n\n  get nextSibling() {\n    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null\n  }\n  get prevSibling() {\n    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n\n  /// @internal\n  toString() { return this.node.toString() }\n}\n\nfunction getChildren(node: SyntaxNode, type: string | number, before: string | number | null, after: string | number | null): SyntaxNode[] {\n  let cur = node.cursor, result: SyntaxNode[] = []\n  if (!cur.firstChild()) return result\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result\n    if (cur.type.is(type)) result.push(cur.node)\n    if (!cur.nextSibling()) return after == null ? result : []\n  }\n}\n\nclass BufferContext {\n  constructor(readonly parent: TreeNode,\n              readonly buffer: TreeBuffer,\n              readonly index: number,\n              readonly start: number) {}\n}\n\nclass BufferNode implements SyntaxNode {\n  type: NodeType\n\n  get name() { return this.type.name }\n\n  get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] }\n\n  get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] }\n\n  constructor(readonly context: BufferContext,\n              readonly _parent: BufferNode | null,\n              readonly index: number) {\n    this.type = context.buffer.set.types[context.buffer.buffer[index]]\n  }\n\n  child(dir: 1 | -1, after: number): BufferNode | null {\n    let {buffer} = this.context\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.context.start)\n    return index < 0 ? null : new BufferNode(this.context, this, index)\n  }\n\n  get firstChild() { return this.child(1, After.None) }\n  get lastChild() { return this.child(-1, After.None) }\n\n  childAfter(pos: number) { return this.child(1, pos) }\n  childBefore(pos: number) { return this.child(-1, pos) }\n\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent()\n  }\n\n  externalSibling(dir: 1 | -1) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1)\n  }\n\n  get nextSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let after = buffer.buffer[this.index + 3]\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n      return new BufferNode(this.context, this._parent, after)\n    return this.externalSibling(1)\n  }\n\n  get prevSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let parentStart = this._parent ? this._parent.index + 4 : 0\n    if (this.index == parentStart) return this.externalSibling(-1)\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, After.None))\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  /// @internal\n  toString() { return this.context.buffer.childString(this.index) }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n}\n\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nexport class TreeCursor {\n  /// The node's type.\n  type!: NodeType\n\n  /// Shorthand for `.type.name`.\n  get name() { return this.type.name }\n\n  /// The start source offset of this node.\n  from!: number\n\n  /// The end source offset.\n  to!: number\n\n  /// @internal\n  _tree!: TreeNode\n  private buffer: BufferContext | null = null\n  private stack: number[] = []\n  private index: number = 0\n  private bufferNode: BufferNode | null = null\n\n  /// @internal\n  constructor(node: TreeNode | BufferNode, readonly full = false) {\n    if (node instanceof TreeNode) {\n      this.yieldNode(node)\n    } else {\n      this._tree = node.context.parent\n      this.buffer = node.context\n      for (let n: BufferNode | null = node._parent; n; n = n._parent) this.stack.unshift(n.index)\n      this.bufferNode = node\n      this.yieldBuf(node.index)\n    }\n  }\n\n  private yieldNode(node: TreeNode | null) {\n    if (!node) return false\n    this._tree = node\n    this.type = node.type\n    this.from = node.from\n    this.to = node.to\n    return true\n  }\n\n  private yieldBuf(index: number, type?: NodeType) {\n    this.index = index\n    let {start, buffer} = this.buffer!\n    this.type = type || buffer.set.types[buffer.buffer[index]]\n    this.from = start + buffer.buffer[index + 1]\n    this.to = start + buffer.buffer[index + 2]\n    return true\n  }\n\n  private yield(node: TreeNode | BufferNode | null) {\n    if (!node) return false\n    if (node instanceof TreeNode) {\n      this.buffer = null\n      return this.yieldNode(node)\n    }\n    this.buffer = node.context\n    return this.yieldBuf(node.index, node.type)\n  }\n\n  /// @internal\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()\n  }\n\n  /// @internal\n  enter(dir: 1 | -1, after: number) {\n    if (!this.buffer)\n      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full))\n\n    let {buffer} = this.buffer\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.buffer.start)\n    if (index < 0) return false\n    this.stack.push(this.index)\n    return this.yieldBuf(index)\n  }\n\n  /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n  firstChild() { return this.enter(1, After.None) }\n\n  /// Move the cursor to this node's last child.\n  lastChild() { return this.enter(-1, After.None) }\n\n  /// Move the cursor to the first child that starts at or after `pos`.\n  childAfter(pos: number) { return this.enter(1, pos) }\n\n  /// Move to the last child that ends at or before `pos`.\n  childBefore(pos: number) { return this.enter(-1, pos) }\n\n  /// Move the node's parent node, if this isn't the top node.\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent)\n    if (this.stack.length) return this.yieldBuf(this.stack.pop()!)\n    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent()\n    this.buffer = null\n    return this.yieldNode(parent)\n  }\n\n  /// @internal\n  sibling(dir: 1 | -1) {\n    if (!this.buffer)\n      return !this._tree._parent ? false\n        : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, After.None, this.full))\n\n    let {buffer} = this.buffer, d = this.stack.length - 1\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4\n      if (this.index != parentStart)\n        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, After.None))\n    } else {\n      let after = buffer.buffer[this.index + 3]\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n        return this.yieldBuf(after)\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, After.None, this.full)) : false\n  }\n\n  /// Move to this node's next sibling, if any.\n  nextSibling() { return this.sibling(1) }\n\n  /// Move to this node's previous sibling, if any.\n  prevSibling() { return this.sibling(-1) }\n\n  private atLastNode(dir: 1 | -1) {\n    let index, parent: TreeNode | null, {buffer} = this\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false\n      }\n      ;({index, parent} = buffer)\n    } else {\n      ({index, _parent: parent} = this._tree)\n    }\n    for (; parent; {index, _parent: parent} = parent) {\n      for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i]\n        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child)) return false\n      }\n    }\n    return true\n  }\n\n  private move(dir: 1 | -1) {\n    if (this.enter(dir, After.None)) return true\n    for (;;) {\n      if (this.sibling(dir)) return true\n      if (this.atLastNode(dir) || !this.parent()) return false\n    }\n  }\n\n  /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty, its next sibling or the next sibling of\n  /// the first parent node that has one.\n  next() { return this.move(1) }\n\n  /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by ist last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n  prev() { return this.move(-1) }\n\n  /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n  moveTo(pos: number, side: -1 | 0 | 1 = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to ||\n           (side < 1 ? this.from >= pos : this.from > pos) ||\n           (side > -1 ? this.to <= pos : this.to < pos))\n      if (!this.parent()) break\n\n    // Then scan down into child nodes as far as possible\n    for (;;) {\n      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos)) break\n      if (this.from == this.to ||\n          (side < 1 ? this.from >= pos : this.from > pos) ||\n          (side > -1 ? this.to <= pos : this.to < pos)) {\n        this.parent()\n        break\n      }\n    }\n    return this\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n  /// position.\n  get node(): SyntaxNode {\n    if (!this.buffer) return this._tree\n    \n    let cache = this.bufferNode, result: BufferNode | null = null, depth = 0\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c: BufferNode | null = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c\n          result = c\n          depth = d + 1\n          break scan\n        }\n        index = this.stack[--d]\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i])\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index)\n  }\n\n  /// Get the [tree](#tree.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#tree.TreeBuffer).\n  get tree(): Tree | null {\n    return this.buffer ? null : this._tree.node\n  }\n}\n\nfunction hasChild(tree: Tree): boolean {\n  return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch))\n}\n\n/// This is used by `Tree.build` as an abstraction for iterating over\n/// a tree buffer. A cursor initially points at the very last element\n/// in the buffer. Every time `next()` is called it moves on to the\n/// previous one.\nexport interface BufferCursor {\n  /// The current buffer position (four times the number of nodes\n  /// remaining).\n  pos: number\n  /// The node ID of the next node in the buffer.\n  id: number\n  /// The start position of the next node in the buffer.\n  start: number\n  /// The end position of the next node.\n  end: number\n  /// The size of the next node (the number of nodes inside, counting\n  /// the node itself, times 4).\n  size: number\n  /// Moves `this.pos` down by 4.\n  next(): void\n  /// Create a copy of this cursor.\n  fork(): BufferCursor\n}\n\nclass FlatBufferCursor implements BufferCursor {\n  constructor(readonly buffer: readonly number[], public index: number) {}\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  get pos() { return this.index }\n\n  next() { this.index -= 4 }\n\n  fork() { return new FlatBufferCursor(this.buffer, this.index) }\n}\n\nconst BalanceBranchFactor = 8\n\nfunction buildTree(data: BuildData) {\n  let {buffer, nodeSet, topID = 0,\n       maxBufferLength = DefaultBufferLength,\n       reused = [],\n       minRepeatType = nodeSet.types.length} = data as BuildData\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer as BufferCursor\n  let types = nodeSet.types\n\n  let contextHash = 0\n\n  function takeNode(parentStart: number, minPos: number,\n                    children: (Tree | TreeBuffer)[], positions: number[],\n                    inRepeat: number) {\n    let {id, start, end, size} = cursor\n    let startPos = start - parentStart\n    if (size < 0) {\n      if (size == -1) { // Reused node\n        children.push(reused[id])\n        positions.push(startPos)\n      } else { // Context change\n        contextHash = id\n      }\n      cursor.next()\n      return\n    }\n\n    let type = types[id], node, buffer: {size: number, start: number, skip: number} | undefined\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip)\n      let endPos = cursor.pos - buffer.size, index = data.length\n      while (cursor.pos > endPos)\n        index = copyToBuffer(buffer.start, data, index, inRepeat)\n      node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat])\n      startPos = buffer.start - parentStart\n    } else { // Make it a node\n      let endPos = cursor.pos - size\n      cursor.next()\n      let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n      let localInRepeat = id >= minRepeatType ? id : -1\n      while (cursor.pos > endPos) {\n        if (cursor.id == localInRepeat) cursor.next()\n        else takeNode(start, endPos, localChildren, localPositions, localInRepeat)\n      }\n      localChildren.reverse(); localPositions.reverse()\n\n      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)\n        node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength,\n                            end - start, contextHash)\n      else\n        node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash)\n    }\n\n    children.push(node)\n    positions.push(startPos)\n  }\n\n  function findBufferSize(maxSize: number, inRepeat: number) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork()\n    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength\n    let result = {size: 0, start: 0, skip: 0}\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size; result.start = start; result.skip = skip\n        skip += 4; size += 4\n        fork.next()\n        continue\n      }\n      let nodeSize = fork.size, startPos = fork.pos - nodeSize\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0\n      let nodeStart = fork.start\n      fork.next()\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan\n        if (fork.id >= minRepeatType) localSkipped += 4\n        fork.next()\n      }\n      start = nodeStart\n      size += nodeSize\n      skip += localSkipped\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size; result.start = start; result.skip = skip\n    }\n    return result.size > 4 ? result : undefined\n  }\n\n  function copyToBuffer(bufferStart: number, buffer: Uint16Array, index: number, inRepeat: number): number {\n    let {id, start, end, size} = cursor\n    cursor.next()\n    if (id == inRepeat) return index\n    let startIndex = index\n    if (size > 4) {\n      let endPos = cursor.pos - (size - 4)\n      while (cursor.pos > endPos)\n        index = copyToBuffer(bufferStart, buffer, index, inRepeat)\n    }\n    if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n      buffer[--index] = startIndex\n      buffer[--index] = end - bufferStart\n      buffer[--index] = start - bufferStart\n      buffer[--index] = id\n    }\n    return index\n  }\n\n  let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n  while (cursor.pos > 0) takeNode(data.start || 0, 0, children, positions, -1)\n  let length = data.length ?? (children.length ? positions[0] + children[0].length : 0)\n  return new Tree(types[topID], children.reverse(), positions.reverse(), length)\n}\n\nfunction balanceRange(outerType: NodeType, innerType: NodeType,\n                      children: readonly (Tree | TreeBuffer)[], positions: readonly number[],\n                      from: number, to: number,\n                      start: number, maxBufferLength: number,\n                      length: number, contextHash: number): Tree {\n  let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n  if (length <= maxBufferLength) {\n    for (let i = from; i < to; i++) {\n      localChildren.push(children[i])\n      localPositions.push(positions[i] - start)\n    }\n  } else {\n    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor))\n    for (let i = from; i < to;) {\n      let groupFrom = i, groupStart = positions[i]\n      i++\n      for (; i < to; i++) {\n        let nextEnd = positions[i] + children[i].length\n        if (nextEnd - groupStart > maxChild) break\n      }\n      if (i == groupFrom + 1) {\n        let only = children[groupFrom]\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n          for (let j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j])\n            localPositions.push(only.positions[j] + groupStart - start)\n          }\n          continue\n        }\n        localChildren.push(only)\n      } else if (i == groupFrom + 1) {\n        localChildren.push(children[groupFrom])\n      } else {\n        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart,\n                                 maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash)\n        if (innerType != NodeType.none && !containsType(inner.children, innerType))\n          inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash)\n        localChildren.push(inner)\n      }\n      localPositions.push(groupStart - start)\n    }\n  }\n  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash)\n}\n\nfunction containsType(nodes: readonly (Tree | TreeBuffer)[], type: NodeType) {\n  for (let elt of nodes) if (elt.type == type) return true\n  return false\n}\n\n/// The [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges)\n/// method expects changed ranges in this format.\nexport interface ChangedRange {\n  /// The start of the change in the start document\n  fromA: number\n  /// The end of the change in the start document\n  toA: number\n  /// The start of the replacement in the new document\n  fromB: number\n  /// The end of the replacement in the new document\n  toB: number\n}\n\nconst enum Open { Start = 1, End = 2 }\n\n/// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\nexport class TreeFragment {\n  constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    readonly from: number,\n    /// The end of the unchanged range.\n    readonly to: number,\n    /// The tree that this fragment is based on.\n    readonly tree: Tree,\n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    readonly offset: number,\n    private open: number\n  ) {}\n\n  get openStart() { return (this.open & Open.Start) > 0 }\n\n  get openEnd() { return (this.open & Open.End) > 0 }\n\n  /// Apply a set of edits to an array of fragments, removing or\n  /// splitting fragments as necessary to remove edited ranges, and\n  /// adjusting offsets for fragments that moved.\n  static applyChanges(fragments: readonly TreeFragment[], changes: readonly ChangedRange[], minGap = 128) {\n    if (!changes.length) return fragments\n    let result: TreeFragment[] = []\n    let fI = 1, nextF = fragments.length ? fragments[0] : null\n    let cI = 0, pos = 0, off = 0\n    for (;;) {\n      let nextC = cI < changes.length ? changes[cI++] : null\n      let nextPos = nextC ? nextC.fromA : 1e9\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut: TreeFragment | null = nextF\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off\n          cut = fFrom >= fTo ? null :\n            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off,\n                             (cI > 0 ? Open.Start : 0) | (nextC ? Open.End : 0))\n        }\n        if (cut) result.push(cut)\n        if (nextF.to > nextPos) break\n        nextF = fI < fragments.length ? fragments[fI++] : null\n      }\n      if (!nextC) break\n      pos = nextC.toA\n      off = nextC.toA - nextC.toB\n    }\n    return result\n  }\n\n  /// Create a set of fragments from a freshly parsed tree, or update\n  /// an existing set of fragments by replacing the ones that overlap\n  /// with a tree with content from the new tree. When `partial` is\n  /// true, the parse is treated as incomplete, and the token at its\n  /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n  static addTree(tree: Tree, fragments: readonly TreeFragment[] = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? Open.End : 0)]\n    for (let f of fragments) if (f.to > tree.length) result.push(f)\n    return result\n  }\n}\n\n/// Interface used to represent an in-progress parse, which can be\n/// moved forward piece-by-piece.\nexport interface PartialParse {\n  /// Advance the parse state by some amount.\n  advance(): Tree | null\n  /// The current parse position.\n  pos: number\n  /// Get the currently parsed content as a tree, even though the\n  /// parse hasn't finished yet.\n  forceFinish(): Tree\n}\n\n/// A parse context is an object providing additional information to the\n/// parser. It is passed through to nested parsers.\nexport interface ParseContext {\n  /// A set of fragments from a previous parse to be used for incremental\n  /// parsing. These should be aligned with the current document\n  /// (through a call to\n  /// [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges))\n  /// if any changes were made since they were produced. The parser\n  /// will try to reuse nodes from the fragments in the new parse,\n  /// greatly speeding up the parse when it can do so for most of the\n  /// document.\n  fragments?: readonly TreeFragment[]\n}\n\n/// This is the interface the parser uses to access the document. It\n/// exposes a sequence of UTF16 code units. Most (but not _all_)\n/// access, especially through `get`, will be sequential, so\n/// implementations can optimize for that.\nexport interface Input {\n  /// The end of the stream.\n  length: number\n  /// Get the code unit at the given position. Will return -1 when\n  /// asked for a point below 0 or beyond the end of the stream.\n  get(pos: number): number\n  /// Returns the string between `pos` and the next newline character\n  /// or the end of the document. Not used by the built-in tokenizers,\n  /// but can be useful in custom tokenizers or completely custom\n  /// parsers.\n  lineAfter(pos: number): string\n  /// Read part of the stream as a string\n  read(from: number, to: number): string\n  /// Return a new `Input` over the same data, but with a lower\n  /// `length`. Used, for example, when nesting grammars to give the\n  /// inner grammar a narrower view of the input.\n  clip(at: number): Input\n}\n\n// Creates an `Input` that is backed by a single, flat string.\nexport function stringInput(input: string): Input { return new StringInput(input) }\n\nclass StringInput implements Input {\n  constructor(readonly string: string, readonly length = string.length) {}\n\n  get(pos: number) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos)\n  }\n\n  lineAfter(pos: number) {\n    if (pos < 0) return \"\"\n    let end = this.string.indexOf(\"\\n\", pos)\n    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length))\n  }\n  \n  read(from: number, to: number): string { return this.string.slice(from, Math.min(this.length, to)) }\n\n  clip(at: number) { return new StringInput(this.string, at) }\n}\n"]},"metadata":{},"sourceType":"module"}