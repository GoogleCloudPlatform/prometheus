{"ast":null,"code":"import _createForOfIteratorHelper from \"/usr/local/google/home/freinartz/repos/src/github.com/GoogleCloudPlatform/prometheus-clean/web/ui/react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { And, BinaryExpr, BinModifiers, GroupingLabel, GroupingLabelList, GroupingLabels, GroupLeft, GroupRight, On, OnOrIgnoring, Or, Unless } from 'lezer-promql';\nimport { VectorMatchCardinality } from '../types';\nimport { containsAtLeastOneChild, retrieveAllRecursiveNodes } from './path-finder';\nexport function buildVectorMatching(state, binaryNode) {\n  if (!binaryNode || binaryNode.type.id !== BinaryExpr) {\n    return null;\n  }\n\n  var result = {\n    card: VectorMatchCardinality.CardOneToOne,\n    matchingLabels: [],\n    on: false,\n    include: []\n  };\n  var binModifiers = binaryNode.getChild(BinModifiers);\n\n  if (binModifiers) {\n    var onOrIgnoring = binModifiers.getChild(OnOrIgnoring);\n\n    if (onOrIgnoring) {\n      result.on = onOrIgnoring.getChild(On) !== null;\n      var labels = retrieveAllRecursiveNodes(onOrIgnoring.getChild(GroupingLabels), GroupingLabelList, GroupingLabel);\n\n      if (labels.length > 0) {\n        var _iterator = _createForOfIteratorHelper(labels),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var label = _step.value;\n            result.matchingLabels.push(state.sliceDoc(label.from, label.to));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n\n    var groupLeft = binModifiers.getChild(GroupLeft);\n    var groupRight = binModifiers.getChild(GroupRight);\n\n    if (groupLeft || groupRight) {\n      result.card = groupLeft ? VectorMatchCardinality.CardManyToOne : VectorMatchCardinality.CardOneToMany;\n      var includeLabels = retrieveAllRecursiveNodes(binModifiers.getChild(GroupingLabels), GroupingLabelList, GroupingLabel);\n\n      if (includeLabels.length > 0) {\n        var _iterator2 = _createForOfIteratorHelper(includeLabels),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _label = _step2.value;\n            result.include.push(state.sliceDoc(_label.from, _label.to));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }\n\n  var isSetOperator = containsAtLeastOneChild(binaryNode, And, Or, Unless);\n\n  if (isSetOperator && result.card === VectorMatchCardinality.CardOneToOne) {\n    result.card = VectorMatchCardinality.CardManyToMany;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../../src/lang-promql/parser/vector.ts"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,SACE,GADF,EAEE,UAFF,EAGE,YAHF,EAIE,aAJF,EAKE,iBALF,EAME,cANF,EAOE,SAPF,EAQE,UARF,EASE,EATF,EAUE,YAVF,EAWE,EAXF,EAYE,MAZF,QAaO,cAbP;AAcA,SAAS,sBAAT,QAAuD,UAAvD;AACA,SAAS,uBAAT,EAAkC,yBAAlC,QAAmE,eAAnE;AAEA,OAAM,SAAU,mBAAV,CAA8B,KAA9B,EAAkD,UAAlD,EAAwE;AAC5E,MAAI,CAAC,UAAD,IAAe,UAAU,CAAC,IAAX,CAAgB,EAAhB,KAAuB,UAA1C,EAAsD;AACpD,WAAO,IAAP;AACD;;AACD,MAAM,MAAM,GAAmB;AAC7B,IAAA,IAAI,EAAE,sBAAsB,CAAC,YADA;AAE7B,IAAA,cAAc,EAAE,EAFa;AAG7B,IAAA,EAAE,EAAE,KAHyB;AAI7B,IAAA,OAAO,EAAE;AAJoB,GAA/B;AAMA,MAAM,YAAY,GAAG,UAAU,CAAC,QAAX,CAAoB,YAApB,CAArB;;AACA,MAAI,YAAJ,EAAkB;AAChB,QAAM,YAAY,GAAG,YAAY,CAAC,QAAb,CAAsB,YAAtB,CAArB;;AACA,QAAI,YAAJ,EAAkB;AAChB,MAAA,MAAM,CAAC,EAAP,GAAY,YAAY,CAAC,QAAb,CAAsB,EAAtB,MAA8B,IAA1C;AACA,UAAM,MAAM,GAAG,yBAAyB,CAAC,YAAY,CAAC,QAAb,CAAsB,cAAtB,CAAD,EAAwC,iBAAxC,EAA2D,aAA3D,CAAxC;;AACA,UAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB;AAAA,mDACD,MADC;AAAA;;AAAA;AACrB,8DAA4B;AAAA,gBAAjB,KAAiB;AAC1B,YAAA,MAAM,CAAC,cAAP,CAAsB,IAAtB,CAA2B,KAAK,CAAC,QAAN,CAAe,KAAK,CAAC,IAArB,EAA2B,KAAK,CAAC,EAAjC,CAA3B;AACD;AAHoB;AAAA;AAAA;AAAA;AAAA;AAItB;AACF;;AAED,QAAM,SAAS,GAAG,YAAY,CAAC,QAAb,CAAsB,SAAtB,CAAlB;AACA,QAAM,UAAU,GAAG,YAAY,CAAC,QAAb,CAAsB,UAAtB,CAAnB;;AACA,QAAI,SAAS,IAAI,UAAjB,EAA6B;AAC3B,MAAA,MAAM,CAAC,IAAP,GAAc,SAAS,GAAG,sBAAsB,CAAC,aAA1B,GAA0C,sBAAsB,CAAC,aAAxF;AACA,UAAM,aAAa,GAAG,yBAAyB,CAAC,YAAY,CAAC,QAAb,CAAsB,cAAtB,CAAD,EAAwC,iBAAxC,EAA2D,aAA3D,CAA/C;;AACA,UAAI,aAAa,CAAC,MAAd,GAAuB,CAA3B,EAA8B;AAAA,oDACR,aADQ;AAAA;;AAAA;AAC5B,iEAAmC;AAAA,gBAAxB,MAAwB;AACjC,YAAA,MAAM,CAAC,OAAP,CAAe,IAAf,CAAoB,KAAK,CAAC,QAAN,CAAe,MAAK,CAAC,IAArB,EAA2B,MAAK,CAAC,EAAjC,CAApB;AACD;AAH2B;AAAA;AAAA;AAAA;AAAA;AAI7B;AACF;AACF;;AAED,MAAM,aAAa,GAAG,uBAAuB,CAAC,UAAD,EAAa,GAAb,EAAkB,EAAlB,EAAsB,MAAtB,CAA7C;;AACA,MAAI,aAAa,IAAI,MAAM,CAAC,IAAP,KAAgB,sBAAsB,CAAC,YAA5D,EAA0E;AACxE,IAAA,MAAM,CAAC,IAAP,GAAc,sBAAsB,CAAC,cAArC;AACD;;AACD,SAAO,MAAP;AACD","sourceRoot":"","sourcesContent":["// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { And, BinaryExpr, BinModifiers, GroupingLabel, GroupingLabelList, GroupingLabels, GroupLeft, GroupRight, On, OnOrIgnoring, Or, Unless, } from 'lezer-promql';\nimport { VectorMatchCardinality } from '../types';\nimport { containsAtLeastOneChild, retrieveAllRecursiveNodes } from './path-finder';\nexport function buildVectorMatching(state, binaryNode) {\n    if (!binaryNode || binaryNode.type.id !== BinaryExpr) {\n        return null;\n    }\n    const result = {\n        card: VectorMatchCardinality.CardOneToOne,\n        matchingLabels: [],\n        on: false,\n        include: [],\n    };\n    const binModifiers = binaryNode.getChild(BinModifiers);\n    if (binModifiers) {\n        const onOrIgnoring = binModifiers.getChild(OnOrIgnoring);\n        if (onOrIgnoring) {\n            result.on = onOrIgnoring.getChild(On) !== null;\n            const labels = retrieveAllRecursiveNodes(onOrIgnoring.getChild(GroupingLabels), GroupingLabelList, GroupingLabel);\n            if (labels.length > 0) {\n                for (const label of labels) {\n                    result.matchingLabels.push(state.sliceDoc(label.from, label.to));\n                }\n            }\n        }\n        const groupLeft = binModifiers.getChild(GroupLeft);\n        const groupRight = binModifiers.getChild(GroupRight);\n        if (groupLeft || groupRight) {\n            result.card = groupLeft ? VectorMatchCardinality.CardManyToOne : VectorMatchCardinality.CardOneToMany;\n            const includeLabels = retrieveAllRecursiveNodes(binModifiers.getChild(GroupingLabels), GroupingLabelList, GroupingLabel);\n            if (includeLabels.length > 0) {\n                for (const label of includeLabels) {\n                    result.include.push(state.sliceDoc(label.from, label.to));\n                }\n            }\n        }\n    }\n    const isSetOperator = containsAtLeastOneChild(binaryNode, And, Or, Unless);\n    if (isSetOperator && result.card === VectorMatchCardinality.CardOneToOne) {\n        result.card = VectorMatchCardinality.CardManyToMany;\n    }\n    return result;\n}\n//# sourceMappingURL=vector.js.map"]},"metadata":{},"sourceType":"module"}