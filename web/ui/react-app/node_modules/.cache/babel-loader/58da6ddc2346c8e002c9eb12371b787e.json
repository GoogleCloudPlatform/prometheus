{"ast":null,"code":"// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n// walkBackward will iterate other the tree from the leaf to the root until it founds the given `exit` node.\n// It returns null if the exit is not found.\nexport function walkBackward(node, exit) {\n  var cursor = node.cursor;\n  var cursorIsMoving = true;\n\n  while (cursorIsMoving && cursor.type.id !== exit) {\n    cursorIsMoving = cursor.parent();\n  }\n\n  return cursor.type.id === exit ? cursor.node : null;\n} // walkThrough is going to follow the path passed in parameter.\n// If it succeeds to reach the last id/name of the path, then it will return the corresponding Subtree.\n// Otherwise if it's not possible to reach the last id/name of the path, it will return `null`\n// Note: the way followed during the iteration of the tree to find the given path, is only from the root to the leaf.\n\nexport function walkThrough(node) {\n  var cursor = node.cursor;\n  var i = 0;\n  var cursorIsMoving = true;\n\n  for (var _len = arguments.length, path = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    path[_key - 1] = arguments[_key];\n  }\n\n  path.unshift(cursor.type.id);\n\n  while (i < path.length && cursorIsMoving) {\n    if (cursor.type.id === path[i] || cursor.type.name === path[i]) {\n      i++;\n\n      if (i < path.length) {\n        cursorIsMoving = cursor.next();\n      }\n    } else {\n      cursorIsMoving = cursor.nextSibling();\n    }\n  }\n\n  if (i >= path.length) {\n    return cursor.node;\n  }\n\n  return null;\n}\nexport function containsAtLeastOneChild(node) {\n  var cursor = node.cursor;\n\n  if (!cursor.next()) {\n    // let's try to move directly to the children level and\n    // return false immediately if the current node doesn't have any child\n    return false;\n  }\n\n  var result = false;\n\n  for (var _len2 = arguments.length, child = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    child[_key2 - 1] = arguments[_key2];\n  }\n\n  do {\n    result = child.some(function (n) {\n      return cursor.type.id === n || cursor.type.name === n;\n    });\n  } while (!result && cursor.nextSibling());\n\n  return result;\n}\nexport function containsChild(node) {\n  var cursor = node.cursor;\n\n  if (!cursor.next()) {\n    // let's try to move directly to the children level and\n    // return false immediately if the current node doesn't have any child\n    return false;\n  }\n\n  var i = 0;\n\n  for (var _len3 = arguments.length, child = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    child[_key3 - 1] = arguments[_key3];\n  }\n\n  do {\n    if (cursor.type.id === child[i] || cursor.type.name === child[i]) {\n      i++;\n    }\n  } while (i < child.length && cursor.nextSibling());\n\n  return i >= child.length;\n}\nexport function retrieveAllRecursiveNodes(parentNode, recursiveNode, leaf) {\n  var nodes = [];\n\n  function recursiveRetrieveNode(node, nodes) {\n    var subNode = node === null || node === void 0 ? void 0 : node.getChild(recursiveNode);\n    var le = node === null || node === void 0 ? void 0 : node.lastChild;\n\n    if (subNode && subNode.type.id === recursiveNode) {\n      recursiveRetrieveNode(subNode, nodes);\n    }\n\n    if (le && le.type.id === leaf) {\n      nodes.push(le);\n    }\n  }\n\n  recursiveRetrieveNode(parentNode, nodes);\n  return nodes;\n}","map":{"version":3,"sources":["../../../src/lang-promql/parser/path-finder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// The MIT License (MIT)\n//\n// Copyright (c) 2020 The Prometheus Authors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n// walkBackward will iterate other the tree from the leaf to the root until it founds the given `exit` node.\n// It returns null if the exit is not found.\nexport function walkBackward(node, exit) {\n    const cursor = node.cursor;\n    let cursorIsMoving = true;\n    while (cursorIsMoving && cursor.type.id !== exit) {\n        cursorIsMoving = cursor.parent();\n    }\n    return cursor.type.id === exit ? cursor.node : null;\n}\n// walkThrough is going to follow the path passed in parameter.\n// If it succeeds to reach the last id/name of the path, then it will return the corresponding Subtree.\n// Otherwise if it's not possible to reach the last id/name of the path, it will return `null`\n// Note: the way followed during the iteration of the tree to find the given path, is only from the root to the leaf.\nexport function walkThrough(node, ...path) {\n    const cursor = node.cursor;\n    let i = 0;\n    let cursorIsMoving = true;\n    path.unshift(cursor.type.id);\n    while (i < path.length && cursorIsMoving) {\n        if (cursor.type.id === path[i] || cursor.type.name === path[i]) {\n            i++;\n            if (i < path.length) {\n                cursorIsMoving = cursor.next();\n            }\n        }\n        else {\n            cursorIsMoving = cursor.nextSibling();\n        }\n    }\n    if (i >= path.length) {\n        return cursor.node;\n    }\n    return null;\n}\nexport function containsAtLeastOneChild(node, ...child) {\n    const cursor = node.cursor;\n    if (!cursor.next()) {\n        // let's try to move directly to the children level and\n        // return false immediately if the current node doesn't have any child\n        return false;\n    }\n    let result = false;\n    do {\n        result = child.some((n) => cursor.type.id === n || cursor.type.name === n);\n    } while (!result && cursor.nextSibling());\n    return result;\n}\nexport function containsChild(node, ...child) {\n    const cursor = node.cursor;\n    if (!cursor.next()) {\n        // let's try to move directly to the children level and\n        // return false immediately if the current node doesn't have any child\n        return false;\n    }\n    let i = 0;\n    do {\n        if (cursor.type.id === child[i] || cursor.type.name === child[i]) {\n            i++;\n        }\n    } while (i < child.length && cursor.nextSibling());\n    return i >= child.length;\n}\nexport function retrieveAllRecursiveNodes(parentNode, recursiveNode, leaf) {\n    const nodes = [];\n    function recursiveRetrieveNode(node, nodes) {\n        const subNode = node === null || node === void 0 ? void 0 : node.getChild(recursiveNode);\n        const le = node === null || node === void 0 ? void 0 : node.lastChild;\n        if (subNode && subNode.type.id === recursiveNode) {\n            recursiveRetrieveNode(subNode, nodes);\n        }\n        if (le && le.type.id === leaf) {\n            nodes.push(le);\n        }\n    }\n    recursiveRetrieveNode(parentNode, nodes);\n    return nodes;\n}\n//# sourceMappingURL=path-finder.js.map"]},"metadata":{},"sourceType":"module"}