"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var t=e(require("postcss-value-parser"));function n(e,n,r,a){const o=[];let l=!1;if(e.nodes.forEach((e=>{"word"!==e.type?function(e){return"function"===e.type&&"var"===e.value}(e)&&(l=!0):o.push(e)})),l)return void u(n,r,`Failed to transform ${n.value} as variables can't be processed.`,a);if(2!==o.length)return void u(n,r,`Failed to transform ${n.value} as it's expecting 2 arguments instead of ${o.length}`,a);const i=t.default.unit(o[0].value),s=t.default.unit(o[1].value);if(i&&s){if(i.unit===s.unit)return[i,s];u(n,r,`Failed to transform ${n.value} as the units don't match`,a)}}function u(e,t,n,u){"warn"===u.onInvalid&&e.warn(t,n)}function r(e){delete e.nodes;const t=e;return t.type="word",t}var a;!function(e){e.Nearest="nearest",e.Up="up",e.Down="down",e.ToZero="to-zero"}(a||(a={}));const o=/^[a-z|-]+$/i;const l=e=>{const l=Object.assign({preserve:!1,onInvalid:""},e);return{postcssPlugin:"postcss-stepped-value-functions",Declaration(e,{result:i}){const s=["mod(","rem(","round("].some((t=>e.value.includes(t)));if(!e||!s)return;const c=e.clone();if(e.value.includes("mod(")){const e=function(e,u,a){const o=t.default(e.value);return o.walk((t=>{if("function"!==t.type||"mod"!==t.value)return;const o=n(t,e,u,a);if(!o)return;const[l,i]=o,s=Number(l.number),c=Number(i.number),d=(s%c+c)%c;"number"!=typeof d||isNaN(d)||(r(t).value=0===d?"0":`${d}${l.unit}`)})),o.toString()}(c,i,l);e&&(c.value=e)}if(c.value.includes("rem(")){const e=function(e,u,a){const o=t.default(e.value);return o.walk((t=>{if("function"!==t.type||"rem"!==t.value)return;const o=n(t,e,u,a);if(!o)return;const[l,i]=o,s=Number(l.number)%Number(i.number);("number"==typeof s||isNaN(s))&&(r(t).value=0===s?"0":`${s}${l.unit}`)})),o.toString()}(c,i,l);e&&(c.value=e)}if(c.value.includes("round(")){const e=function(e,n,l){const i=t.default(e.value);return i.walk((i=>{if("function"!==i.type||"round"!==i.value)return;if(3!==i.nodes.length&&5!==i.nodes.length)return void u(e,n,`Failed to transform ${e.value} as the amount of arguments isn't valid`,l);const s=i.nodes.filter((e=>"word"===e.type)),c=s[0].value;let d,f,v;if(o.test(c)){var m,p;if(!Object.values(a).includes(c))return void u(e,n,`Failed to transform ${e.value} as ${c} is not a valid rounding strategy.`,l);d=c,f=t.default.unit((null==s||null==(m=s[1])?void 0:m.value)||""),v=t.default.unit((null==s||null==(p=s[2])?void 0:p.value)||"")}else{var b,h;d=a.Nearest,f=t.default.unit((null==s||null==(b=s[0])?void 0:b.value)||""),v=t.default.unit((null==s||null==(h=s[1])?void 0:h.value)||"")}if(!f||!v)return;if(f.unit!==v.unit)return void u(e,n,`Failed to transform ${e.value} as the units don't match`,l);const N=Number(f.number),$=Number(v.number);let g;switch(d){case a.Down:g=Math.floor(N/$)*$;break;case a.Up:g=Math.ceil(N/$)*$;break;case a.ToZero:g=Math.trunc(N/$)*$;break;case a.Nearest:default:g=Math.round(N/$)*$}"number"!=typeof g||isNaN(g)||(r(i).value=0===g?"0":`${g}${f.unit}`)})),i.toString()}(c,i,l);e&&(c.value=e)}e.value!==c.value&&(l.preserve?e.cloneBefore({value:c.value}):e.value=c.value)}}};l.postcss=!0,module.exports=l;
