import e from"postcss-value-parser";function n(n,u,r,o){const a=[];let l=!1;if(n.nodes.forEach((e=>{"word"!==e.type?function(e){return"function"===e.type&&"var"===e.value}(e)&&(l=!0):a.push(e)})),l)return void t(u,r,`Failed to transform ${u.value} as variables can't be processed.`,o);if(2!==a.length)return void t(u,r,`Failed to transform ${u.value} as it's expecting 2 arguments instead of ${a.length}`,o);const s=e.unit(a[0].value),i=e.unit(a[1].value);if(s&&i){if(s.unit===i.unit)return[s,i];t(u,r,`Failed to transform ${u.value} as the units don't match`,o)}}function t(e,n,t,u){"warn"===u.onInvalid&&e.warn(n,t)}function u(e){delete e.nodes;const n=e;return n.type="word",n}var r;!function(e){e.Nearest="nearest",e.Up="up",e.Down="down",e.ToZero="to-zero"}(r||(r={}));const o=/^[a-z|-]+$/i;const a=a=>{const l=Object.assign({preserve:!1,onInvalid:""},a);return{postcssPlugin:"postcss-stepped-value-functions",Declaration(a,{result:s}){const i=["mod(","rem(","round("].some((e=>a.value.includes(e)));if(!a||!i)return;const c=a.clone();if(a.value.includes("mod(")){const t=function(t,r,o){const a=e(t.value);return a.walk((e=>{if("function"!==e.type||"mod"!==e.value)return;const a=n(e,t,r,o);if(!a)return;const[l,s]=a,i=Number(l.number),c=Number(s.number),v=(i%c+c)%c;"number"!=typeof v||isNaN(v)||(u(e).value=0===v?"0":`${v}${l.unit}`)})),a.toString()}(c,s,l);t&&(c.value=t)}if(c.value.includes("rem(")){const t=function(t,r,o){const a=e(t.value);return a.walk((e=>{if("function"!==e.type||"rem"!==e.value)return;const a=n(e,t,r,o);if(!a)return;const[l,s]=a,i=Number(l.number)%Number(s.number);("number"==typeof i||isNaN(i))&&(u(e).value=0===i?"0":`${i}${l.unit}`)})),a.toString()}(c,s,l);t&&(c.value=t)}if(c.value.includes("round(")){const n=function(n,a,l){const s=e(n.value);return s.walk((s=>{if("function"!==s.type||"round"!==s.value)return;if(3!==s.nodes.length&&5!==s.nodes.length)return void t(n,a,`Failed to transform ${n.value} as the amount of arguments isn't valid`,l);const i=s.nodes.filter((e=>"word"===e.type)),c=i[0].value;let v,d,f;if(o.test(c)){var m,p;if(!Object.values(r).includes(c))return void t(n,a,`Failed to transform ${n.value} as ${c} is not a valid rounding strategy.`,l);v=c,d=e.unit((null==i||null==(m=i[1])?void 0:m.value)||""),f=e.unit((null==i||null==(p=i[2])?void 0:p.value)||"")}else{var b,h;v=r.Nearest,d=e.unit((null==i||null==(b=i[0])?void 0:b.value)||""),f=e.unit((null==i||null==(h=i[1])?void 0:h.value)||"")}if(!d||!f)return;if(d.unit!==f.unit)return void t(n,a,`Failed to transform ${n.value} as the units don't match`,l);const N=Number(d.number),$=Number(f.number);let g;switch(v){case r.Down:g=Math.floor(N/$)*$;break;case r.Up:g=Math.ceil(N/$)*$;break;case r.ToZero:g=Math.trunc(N/$)*$;break;case r.Nearest:default:g=Math.round(N/$)*$}"number"!=typeof g||isNaN(g)||(u(s).value=0===g?"0":`${g}${d.unit}`)})),s.toString()}(c,s,l);n&&(c.value=n)}a.value!==c.value&&(l.preserve?a.cloneBefore({value:c.value}):a.value=c.value)}}};a.postcss=!0;export{a as default};
